<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Programmer Liu</title>
  
  <subtitle>精彩生活，不惧挑战，做一只有理想的的程序猿</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-23T02:42:47.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>刘伟</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>FFmpeg+SDL2实现视频流播放</title>
    <link href="http://yoursite.com/2019/04/22/FFmpeg-SDL2%E5%AE%9E%E7%8E%B0%E8%A7%86%E9%A2%91%E6%B5%81%E6%92%AD%E6%94%BE/"/>
    <id>http://yoursite.com/2019/04/22/FFmpeg-SDL2实现视频流播放/</id>
    <published>2019-04-22T07:47:51.000Z</published>
    <updated>2019-04-23T02:42:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>SDL2文章列表</p><p><a href="https://david1840.github.io/2019/04/11/SDL2%E9%9F%B3%E8%A7%86%E9%A2%91%E6%B8%B2%E6%9F%93%E5%85%A5%E9%97%A8/" target="_blank" rel="noopener">SDL2入门</a></p><p><a href="https://david1840.github.io/2019/04/15/SDL2%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/" target="_blank" rel="noopener">SDL2事件处理</a></p><p><a href="https://david1840.github.io/2019/04/16/SDL2%E7%BA%B9%E7%90%86%E6%B8%B2%E6%9F%93/" target="_blank" rel="noopener">SDL2纹理渲染</a></p><p><a href="https://david1840.github.io/2019/04/19/SDL2%E9%9F%B3%E9%A2%91%E6%92%AD%E6%94%BE/" target="_blank" rel="noopener">SDL2音频播放</a></p><p>本篇博客使用FFmpeg+SDL2完成播放视频流Demo（仅播放视频），所有相关知识在之前的博客中都有提到，稍作整理完成。</p><h3 id="流程图："><a href="#流程图：" class="headerlink" title="流程图："></a>流程图：</h3><p>FFmpeg解码视频流：</p><p><img src="/2019/04/22/FFmpeg-SDL2实现视频流播放/FFmpeg.png" alt=""></p><p>SDL2显示YUV数据：</p><p><img src="/2019/04/22/FFmpeg-SDL2实现视频流播放/SDL2.png" alt=""></p><p>### </p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;SDL.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavcodec/avcodec.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libswscale/swscale.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">WinMain</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">char</span> *file = <span class="string">"C:\\Users\\lenovo\\Desktop\\fengjing.mp4"</span>;</span><br><span class="line">    </span><br><span class="line">    AVFormatContext *pFormatCtx = <span class="literal">NULL</span>; </span><br><span class="line">    <span class="keyword">int</span> i, videoStream;</span><br><span class="line">    AVCodecParameters *pCodecParameters = <span class="literal">NULL</span>; </span><br><span class="line">    AVCodecContext *pCodecCtx = <span class="literal">NULL</span>;</span><br><span class="line">    AVCodec *pCodec = <span class="literal">NULL</span>;</span><br><span class="line">    AVFrame *pFrame = <span class="literal">NULL</span>;</span><br><span class="line">    AVPacket packet;</span><br><span class="line"></span><br><span class="line">    SDL_Rect rect;</span><br><span class="line">    Uint32 pixformat;</span><br><span class="line">    SDL_Window *win = <span class="literal">NULL</span>;</span><br><span class="line">    SDL_Renderer *renderer = <span class="literal">NULL</span>;</span><br><span class="line">    SDL_Texture *texture = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//默认窗口大小</span></span><br><span class="line">    <span class="keyword">int</span> w_width = <span class="number">640</span>;</span><br><span class="line">    <span class="keyword">int</span> w_height = <span class="number">480</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//SDL初始化</span></span><br><span class="line">    <span class="keyword">if</span> (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER)) &#123;</span><br><span class="line">        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, <span class="string">"Could not initialize SDL - %s\n"</span>, SDL_GetError());</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开输入文件</span></span><br><span class="line">    <span class="keyword">if</span> (avformat_open_input(&amp;pFormatCtx, file, <span class="literal">NULL</span>, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, <span class="string">"Couldn't open  video file!"</span>);</span><br><span class="line">        <span class="keyword">goto</span> __FAIL; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//找到视频流</span></span><br><span class="line">    videoStream = av_find_best_stream(pFormatCtx, AVMEDIA_TYPE_VIDEO, <span class="number">-1</span>, <span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (videoStream == <span class="number">-1</span>) &#123;</span><br><span class="line">        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, <span class="string">"Din't find a video stream!"</span>);</span><br><span class="line">        <span class="keyword">goto</span> __FAIL;<span class="comment">// Didn't find a video stream</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 流参数</span></span><br><span class="line">    pCodecParameters = pFormatCtx-&gt;streams[videoStream]-&gt;codecpar;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取解码器</span></span><br><span class="line">    pCodec = avcodec_find_decoder(pCodecParameters-&gt;codec_id);</span><br><span class="line">    <span class="keyword">if</span> (pCodec == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, <span class="string">"Unsupported codec!\n"</span>);</span><br><span class="line">        <span class="keyword">goto</span> __FAIL; <span class="comment">// Codec not found</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化一个编解码上下文</span></span><br><span class="line">    pCodecCtx = avcodec_alloc_context3(pCodec);</span><br><span class="line">    <span class="keyword">if</span> (avcodec_parameters_to_context(pCodecCtx, pCodecParameters) != <span class="number">0</span>) &#123;</span><br><span class="line">        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, <span class="string">"Couldn't copy codec context"</span>);</span><br><span class="line">        <span class="keyword">goto</span> __FAIL;<span class="comment">// Error copying codec context</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开解码器</span></span><br><span class="line">    <span class="keyword">if</span> (avcodec_open2(pCodecCtx, pCodec, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, <span class="string">"Failed to open decoder!\n"</span>);</span><br><span class="line">        <span class="keyword">goto</span> __FAIL; <span class="comment">// Could not open codec</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate video frame</span></span><br><span class="line">    pFrame = av_frame_alloc();</span><br><span class="line"></span><br><span class="line">    w_width = pCodecCtx-&gt;width;</span><br><span class="line">    w_height = pCodecCtx-&gt;height;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建窗口</span></span><br><span class="line">    win = SDL_CreateWindow(<span class="string">"Media Player"</span>,</span><br><span class="line">                           SDL_WINDOWPOS_UNDEFINED,</span><br><span class="line">                           SDL_WINDOWPOS_UNDEFINED,</span><br><span class="line">                           w_width, w_height,</span><br><span class="line">                           SDL_WINDOW_OPENGL | SDL_WINDOW_RESIZABLE);</span><br><span class="line">    <span class="keyword">if</span> (!win) &#123;</span><br><span class="line">        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, <span class="string">"Failed to create window by SDL"</span>);</span><br><span class="line">        <span class="keyword">goto</span> __FAIL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建渲染器</span></span><br><span class="line">    renderer = SDL_CreateRenderer(win, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!renderer) &#123;</span><br><span class="line">        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, <span class="string">"Failed to create Renderer by SDL"</span>);</span><br><span class="line">        <span class="keyword">goto</span> __FAIL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pixformat = SDL_PIXELFORMAT_IYUV;<span class="comment">//YUV格式</span></span><br><span class="line">    <span class="comment">// 创建纹理</span></span><br><span class="line">    texture = SDL_CreateTexture(renderer,</span><br><span class="line">                                pixformat,</span><br><span class="line">                                SDL_TEXTUREACCESS_STREAMING,</span><br><span class="line">                                w_width,</span><br><span class="line">                                w_height);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取数据</span></span><br><span class="line">    <span class="keyword">while</span> (av_read_frame(pFormatCtx, &amp;packet) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (packet.stream_index == videoStream) &#123;</span><br><span class="line">            <span class="comment">//解码</span></span><br><span class="line">            avcodec_send_packet(pCodecCtx, &amp;packet);</span><br><span class="line">            <span class="keyword">while</span> (avcodec_receive_frame(pCodecCtx, pFrame) == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                SDL_UpdateYUVTexture(texture, <span class="literal">NULL</span>,</span><br><span class="line">                                     pFrame-&gt;data[<span class="number">0</span>], pFrame-&gt;linesize[<span class="number">0</span>],</span><br><span class="line">                                     pFrame-&gt;data[<span class="number">1</span>], pFrame-&gt;linesize[<span class="number">1</span>],</span><br><span class="line">                                     pFrame-&gt;data[<span class="number">2</span>], pFrame-&gt;linesize[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Set Size of Window</span></span><br><span class="line">                rect.x = <span class="number">0</span>;</span><br><span class="line">                rect.y = <span class="number">0</span>;</span><br><span class="line">                rect.w = pCodecCtx-&gt;width;</span><br><span class="line">                rect.h = pCodecCtx-&gt;height;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//展示</span></span><br><span class="line">                SDL_RenderClear(renderer);</span><br><span class="line">                SDL_RenderCopy(renderer, texture, <span class="literal">NULL</span>, &amp;rect);</span><br><span class="line">                SDL_RenderPresent(renderer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        av_packet_unref(&amp;packet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 事件处理</span></span><br><span class="line">        SDL_Event event;</span><br><span class="line">        SDL_PollEvent(&amp;event);</span><br><span class="line">        <span class="keyword">switch</span> (event.type) &#123;</span><br><span class="line">            <span class="keyword">case</span> SDL_QUIT:</span><br><span class="line">                <span class="keyword">goto</span> __QUIT;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    __QUIT:</span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    __FAIL:</span><br><span class="line">    <span class="comment">// Free the YUV frame</span></span><br><span class="line">    <span class="keyword">if</span> (pFrame) &#123;</span><br><span class="line">        av_frame_free(&amp;pFrame);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Close the codec</span></span><br><span class="line">    <span class="keyword">if</span> (pCodecCtx) &#123;</span><br><span class="line">        avcodec_close(pCodecCtx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pCodecParameters) &#123;</span><br><span class="line">        avcodec_parameters_free(&amp;pCodecParameters);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Close the video file</span></span><br><span class="line">    <span class="keyword">if</span> (pFormatCtx) &#123;</span><br><span class="line">        avformat_close_input(&amp;pFormatCtx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (win) &#123;</span><br><span class="line">        SDL_DestroyWindow(win);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (renderer) &#123;</span><br><span class="line">        SDL_DestroyRenderer(renderer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (texture) &#123;</span><br><span class="line">        SDL_DestroyTexture(texture);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SDL_Quit();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/04/22/FFmpeg-SDL2实现视频流播放/1.png" alt=""></p><p>这个Demo目前只是通过一个while循环将视频播放出来，所以可以播放视频但是速度不正常，并且没有声音，这些问题会在后面一一解决，最后完成一个简易的播放器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SDL2文章列表&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://david1840.github.io/2019/04/11/SDL2%E9%9F%B3%E8%A7%86%E9%A2%91%E6%B8%B2%E6%9F%93%E5%85%A5%E9%97%A8/&quot; tar
      
    
    </summary>
    
      <category term="SDL2" scheme="http://yoursite.com/categories/SDL2/"/>
    
    
      <category term="FFmpeg" scheme="http://yoursite.com/tags/FFmpeg/"/>
    
      <category term="音视频" scheme="http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="SDL2" scheme="http://yoursite.com/tags/SDL2/"/>
    
  </entry>
  
  <entry>
    <title>SDL2音频播放</title>
    <link href="http://yoursite.com/2019/04/19/SDL2%E9%9F%B3%E9%A2%91%E6%92%AD%E6%94%BE/"/>
    <id>http://yoursite.com/2019/04/19/SDL2音频播放/</id>
    <published>2019-04-19T01:47:03.000Z</published>
    <updated>2019-04-20T08:35:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>SDL2文章列表</p><p><a href="https://david1840.github.io/2019/04/11/SDL2%E9%9F%B3%E8%A7%86%E9%A2%91%E6%B8%B2%E6%9F%93%E5%85%A5%E9%97%A8/" target="_blank" rel="noopener">SDL2入门</a></p><p><a href="https://david1840.github.io/2019/04/15/SDL2%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/" target="_blank" rel="noopener">SDL2事件处理</a></p><p><a href="https://david1840.github.io/2019/04/16/SDL2%E7%BA%B9%E7%90%86%E6%B8%B2%E6%9F%93/" target="_blank" rel="noopener">SDL2纹理渲染</a></p><p>本来计划写FFmpeg+SDL2视频播放，但是发现要说的内容有点多，所以还是先从简单的音频数据播放开始，一步一步来。</p><h3 id="打开音频设备"><a href="#打开音频设备" class="headerlink" title="打开音频设备"></a>打开音频设备</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> SDLCALL <span class="title">SDL_OpenAudio</span><span class="params">(SDL_AudioSpec * desired,</span></span></span><br><span class="line"><span class="function"><span class="params">                          SDL_AudioSpec * obtained)</span></span>;</span><br><span class="line"><span class="comment">// desired：期望的参数。</span></span><br><span class="line"><span class="comment">// obtained：实际音频设备的参数，一般情况下设置为NULL即可。</span></span><br></pre></td></tr></table></figure><h4 id="SDL-AudioSpec"><a href="#SDL-AudioSpec" class="headerlink" title="SDL_AudioSpec"></a>SDL_AudioSpec</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在这个结构体中包含了音频的各种参数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SDL_AudioSpec</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> freq;                   <span class="comment">/**&lt; 音频采样率*/</span></span><br><span class="line">    SDL_AudioFormat format;     <span class="comment">/**&lt; 音频数据格式 */</span></span><br><span class="line">    Uint8 channels;             <span class="comment">/**&lt; 声道数: 1 单声道, 2 立体声 */</span></span><br><span class="line">    Uint8 silence;              <span class="comment">/**&lt; 设置静音的值*/</span></span><br><span class="line">    Uint16 samples;             <span class="comment">/**&lt; 音频缓冲区中的采样个数，要求必须是2的n次*/</span></span><br><span class="line">    Uint16 padding;             <span class="comment">/**&lt; 考虑到兼容性的一个参数*/</span></span><br><span class="line">    Uint32 size;                <span class="comment">/**&lt; 音频缓冲区的大小，以字节为单位*/</span></span><br><span class="line">    SDL_AudioCallback callback; <span class="comment">/**&lt; 填充音频缓冲区的回调函数 */</span></span><br><span class="line">    <span class="keyword">void</span> *userdata;             <span class="comment">/**&lt; 用户自定义的数据 */</span></span><br><span class="line">&#125; SDL_AudioSpec;</span><br></pre></td></tr></table></figure><h4 id="SDL-AudioCallback"><a href="#SDL-AudioCallback" class="headerlink" title="SDL_AudioCallback"></a>SDL_AudioCallback</h4><p>当音频设备需要更多数据的时候会调用该回调函数。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// userdata：SDL_AudioSpec结构中的用户自定义数据，一般情况下可以不用。</span></span><br><span class="line"><span class="comment">// stream：该指针指向需要填充的音频缓冲区。</span></span><br><span class="line"><span class="comment">// len：音频缓冲区的大小（以字节为单位）。</span></span><br><span class="line"><span class="type">void</span> (SDLCALL * SDL_AudioCallback) (<span class="type">void</span> *userdata,</span><br><span class="line">                                    Uint8 *<span class="keyword">stream</span>,</span><br><span class="line">                                    <span class="type">int</span> len);</span><br></pre></td></tr></table></figure><h3 id="播放音频数据"><a href="#播放音频数据" class="headerlink" title="播放音频数据"></a>播放音频数据</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当pause_on设置为0的时候即可开始播放音频数据。设置为1的时候，将会播放静音的值。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> SDLCALL <span class="title">SDL_PauseAudio</span><span class="params">(<span class="keyword">int</span> pause_on)</span></span></span><br></pre></td></tr></table></figure><h3 id="播放PCM音频Demo"><a href="#播放PCM音频Demo" class="headerlink" title="播放PCM音频Demo"></a>播放PCM音频Demo</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;SDL_types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SDL.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Uint8 *audio_chunk;</span><br><span class="line"><span class="keyword">static</span> Uint32 audio_len;</span><br><span class="line"><span class="keyword">static</span> Uint8 *audio_pos;</span><br><span class="line"><span class="keyword">int</span> pcm_buffer_size = <span class="number">4096</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//回调函数，音频设备需要更多数据的时候会调用该回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_audio_data</span><span class="params">(<span class="keyword">void</span> *udata, Uint8 *stream, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    SDL_memset(stream, <span class="number">0</span>, len);</span><br><span class="line">    <span class="keyword">if</span> (audio_len == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    len = (len &gt; audio_len ? audio_len : len);</span><br><span class="line"></span><br><span class="line">    SDL_MixAudio(stream, audio_pos, len, SDL_MIX_MAXVOLUME);</span><br><span class="line">    audio_pos += len;</span><br><span class="line">    audio_len -= len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">WinMain</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (SDL_Init(SDL_INIT_AUDIO | SDL_INIT_TIMER)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Could not initialize SDL - %s\n"</span>, SDL_GetError());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    SDL_AudioSpec spec;</span><br><span class="line">    spec.freq = <span class="number">44100</span>;<span class="comment">//根据你录制的PCM采样率决定</span></span><br><span class="line">    spec.format = AUDIO_S16SYS;</span><br><span class="line">    spec.channels = <span class="number">1</span>; <span class="comment">//单声道</span></span><br><span class="line">    spec.silence = <span class="number">0</span>;</span><br><span class="line">    spec.samples = <span class="number">1024</span>;</span><br><span class="line">    spec.callback = read_audio_data;</span><br><span class="line">    spec.userdata = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (SDL_OpenAudio(&amp;spec, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"can't open audio.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FILE *fp = fopen(<span class="string">"C:\\Users\\lenovo\\Desktop\\1111111.pcm"</span>, <span class="string">"rb+"</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"cannot open this file\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> *pcm_buffer = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(pcm_buffer_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//播放</span></span><br><span class="line">    SDL_PauseAudio(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fread(pcm_buffer, <span class="number">1</span>, pcm_buffer_size, fp) != pcm_buffer_size) &#123; <span class="comment">//从文件中读取数据，剩下的就交给音频设备去完成了，它播放完一段数据后会执行回调函数，获取等多的数据</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        audio_chunk = (Uint8 *) pcm_buffer;</span><br><span class="line">        audio_len = pcm_buffer_size; <span class="comment">//长度为读出数据长度，在read_audio_data中做减法</span></span><br><span class="line">        audio_pos = audio_chunk;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (audio_len &gt; <span class="number">0</span>) <span class="comment">//判断是否播放完毕</span></span><br><span class="line">            SDL_Delay(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(pcm_buffer);</span><br><span class="line">    SDL_Quit();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK！第一步完成，能正常播放出声音了。</p><p>想要录制PCM自己试一下？可以试试用这个<a href="https://david1840.github.io/2019/02/11/Android%E9%9F%B3%E8%A7%86%E9%A2%91-%E4%BA%94-OpenSL-ES%E6%92%AD%E6%94%BE%E9%9F%B3%E9%A2%91/" target="_blank" rel="noopener">Android音视频(五) OpenSL ES录制、播放音频(带源码)</a>录制一段。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SDL2文章列表&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://david1840.github.io/2019/04/11/SDL2%E9%9F%B3%E8%A7%86%E9%A2%91%E6%B8%B2%E6%9F%93%E5%85%A5%E9%97%A8/&quot; tar
      
    
    </summary>
    
      <category term="SDL2" scheme="http://yoursite.com/categories/SDL2/"/>
    
    
      <category term="音视频" scheme="http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="SDL2" scheme="http://yoursite.com/tags/SDL2/"/>
    
  </entry>
  
  <entry>
    <title>SDL2纹理渲染</title>
    <link href="http://yoursite.com/2019/04/16/SDL2%E7%BA%B9%E7%90%86%E6%B8%B2%E6%9F%93/"/>
    <id>http://yoursite.com/2019/04/16/SDL2纹理渲染/</id>
    <published>2019-04-16T02:43:16.000Z</published>
    <updated>2019-04-20T08:34:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>SDL2第三篇。</p><p><a href="https://david1840.github.io/2019/04/11/SDL2%E9%9F%B3%E8%A7%86%E9%A2%91%E6%B8%B2%E6%9F%93%E5%85%A5%E9%97%A8/" target="_blank" rel="noopener">SDL2入门</a></p><p><a href="https://david1840.github.io/2019/04/15/SDL2%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/" target="_blank" rel="noopener">SDL2事件处理</a></p><p>接下来就看下如何使用SDL如何通过SDL_Texture在窗口绘制图像。</p><p>先了解几个纹理渲染相关API：</p><h4 id="创建纹理"><a href="#创建纹理" class="headerlink" title="创建纹理"></a>创建纹理</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SDL_Texture* <span class="title">SDL_CreateTexture</span><span class="params">(SDL_Renderer * renderer, </span></span></span><br><span class="line"><span class="function"><span class="params">Uint32 format, </span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">int</span> access,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">int</span> w, <span class="keyword">int</span> h)</span></span>;</span><br></pre></td></tr></table></figure><p>format: 像素格式，YUV或RGB</p><p>access: 指明Texture的类型。可以是 Stream(视频)，也可以是Target一般的类型。</p><h4 id="销毁纹理"><a href="#销毁纹理" class="headerlink" title="销毁纹理"></a>销毁纹理</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SDL_DestroyTexture</span><span class="params">(SDL_Texture* texture)</span></span></span><br></pre></td></tr></table></figure><h4 id="渲染目标"><a href="#渲染目标" class="headerlink" title="渲染目标"></a>渲染目标</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将渲染目标定为纹理</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SDL_SetRenderTarget</span><span class="params">(SDL_Renderer *renderer,</span></span></span><br><span class="line"><span class="function"><span class="params">                        SDL_Texture *texture)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="纹理拷贝"><a href="#纹理拷贝" class="headerlink" title="纹理拷贝"></a>纹理拷贝</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//会将纹理拷贝到显卡上去，显卡会计算出最终图形并渲染到窗口中</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SDL_RenderCopy</span><span class="params">(SDL_Renderer*   renderer,</span></span></span><br><span class="line"><span class="function"><span class="params">                   SDL_Texture*    texture,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">const</span> SDL_Rect* srcrect,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">const</span> SDL_Rect* dstrect)</span></span></span><br></pre></td></tr></table></figure><p>srcrect: 指定 Texture 中要渲染的一部分。如果将 Texture全部输出，可以设置它为 NULL。</p><p>dstrect: 指定输出的空间大小。</p><h3 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h3><p>在前面Demo的基础上做了一定修改，简单实现一个正方形在界面中随机显示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;SDL2/SDL.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">WinMain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> quit = <span class="number">1</span>;</span><br><span class="line">    SDL_Window *window = <span class="literal">NULL</span>;</span><br><span class="line">    SDL_Renderer *renderer = <span class="literal">NULL</span>;</span><br><span class="line">    SDL_Texture *sdlTexture = <span class="literal">NULL</span>;</span><br><span class="line">    SDL_Event event;</span><br><span class="line">    SDL_Rect rect; <span class="comment">// 长方形，原点在左上角</span></span><br><span class="line">    rect.w = <span class="number">50</span>;</span><br><span class="line">    rect.h = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    SDL_Init(SDL_INIT_VIDEO);<span class="comment">//初始化函数,可以确定希望激活的子系统</span></span><br><span class="line"></span><br><span class="line">    window = SDL_CreateWindow(<span class="string">"My First Window"</span>,</span><br><span class="line">                              SDL_WINDOWPOS_UNDEFINED,</span><br><span class="line">                              SDL_WINDOWPOS_UNDEFINED,</span><br><span class="line">                              <span class="number">640</span>,</span><br><span class="line">                              <span class="number">480</span>,</span><br><span class="line">                              SDL_WINDOW_OPENGL | SDL_WINDOW_RESIZABLE);<span class="comment">// 创建窗口</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!window) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    renderer = SDL_CreateRenderer(window, <span class="number">-1</span>, <span class="number">0</span>);<span class="comment">//基于窗口创建渲染器</span></span><br><span class="line">    <span class="keyword">if</span> (!renderer) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255); //设置渲染器颜色</span></span><br><span class="line"><span class="comment">//    SDL_RenderClear(renderer); //用指定的颜色清空缓冲区</span></span><br><span class="line"><span class="comment">//    SDL_RenderPresent(renderer); //将缓冲区中的内容输出到目标窗口上</span></span><br><span class="line"></span><br><span class="line">    sdlTexture = SDL_CreateTexture(renderer,</span><br><span class="line">                                   SDL_PIXELFORMAT_RGBA8888,</span><br><span class="line">                                   SDL_TEXTUREACCESS_TARGET,</span><br><span class="line">                                   <span class="number">640</span>,</span><br><span class="line">                                   <span class="number">480</span>); <span class="comment">//创建纹理</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!sdlTexture) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (quit) &#123;</span><br><span class="line">        SDL_PollEvent(&amp;event); <span class="comment">// SDL_WaitEvent在这里就不太适合，只有在事件发生时才会触发，其余时间都是阻塞状态</span></span><br><span class="line">        <span class="keyword">switch</span> (event.type) &#123;</span><br><span class="line">            <span class="keyword">case</span> SDL_QUIT:</span><br><span class="line">                SDL_Log(<span class="string">"quit"</span>);</span><br><span class="line">                quit = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                SDL_Log(<span class="string">"event type:%d"</span>, event.type);</span><br><span class="line">        &#125;</span><br><span class="line">        rect.x = rand() % <span class="number">600</span>;</span><br><span class="line">        rect.y = rand() % <span class="number">400</span>;</span><br><span class="line"></span><br><span class="line">        SDL_SetRenderTarget(renderer, sdlTexture); <span class="comment">// 设置渲染目标为纹理</span></span><br><span class="line">        SDL_SetRenderDrawColor(renderer, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 纹理背景为黑色</span></span><br><span class="line">        SDL_RenderClear(renderer); <span class="comment">//清屏</span></span><br><span class="line"></span><br><span class="line">        SDL_RenderDrawRect(renderer, &amp;rect); <span class="comment">//绘制一个长方形</span></span><br><span class="line">        SDL_SetRenderDrawColor(renderer, <span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>); <span class="comment">//长方形为白色</span></span><br><span class="line">        SDL_RenderFillRect(renderer, &amp;rect);</span><br><span class="line"></span><br><span class="line">        SDL_SetRenderTarget(renderer, <span class="literal">NULL</span>); <span class="comment">//恢复默认，渲染目标为窗口</span></span><br><span class="line">        SDL_RenderCopy(renderer, sdlTexture, <span class="literal">NULL</span>, <span class="literal">NULL</span>); <span class="comment">//拷贝纹理到CPU</span></span><br><span class="line"></span><br><span class="line">        SDL_RenderPresent(renderer); <span class="comment">//输出到目标窗口上</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SDL_DestroyTexture(sdlTexture);</span><br><span class="line">    SDL_DestroyRenderer(renderer);</span><br><span class="line">    SDL_DestroyWindow(window); <span class="comment">//销毁窗口</span></span><br><span class="line">    SDL_Quit();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个Demo就是最简单的纹理渲染流程。</p><p>接下来再认识两个API：</p><h4 id="更新纹理"><a href="#更新纹理" class="headerlink" title="更新纹理"></a>更新纹理</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两个API功能相同，但是SDL_UpdateYUVTexture直接将Y、U、V分量传入，可以减少CPU计算量，更快一些</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SDL_UpdateTexture</span><span class="params">(SDL_Texture * texture, <span class="comment">//想要更新的纹理</span></span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">const</span> SDL_Rect * rect, <span class="comment">//更新的像素矩形，传NULL则表示为整个纹理</span></span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">const</span> <span class="keyword">void</span> *pixels, <span class="comment">//像素数据</span></span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">int</span> pitch)</span></span>;<span class="comment">//一行像素数据的字节数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SDL_UpdateYUVTexture</span><span class="params">(SDL_Texture * texture,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">const</span> SDL_Rect * rect,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">const</span> Uint8 *Yplane, <span class="keyword">int</span> Ypitch,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">const</span> Uint8 *Uplane, <span class="keyword">int</span> Upitch,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">const</span> Uint8 *Vplane, <span class="keyword">int</span> Vpitch)</span></span>;</span><br></pre></td></tr></table></figure><p>这两个API将会在视频播放中发挥重要作用，下一篇博客将会结合FFmpeg实现一个视频播放器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SDL2第三篇。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://david1840.github.io/2019/04/11/SDL2%E9%9F%B3%E8%A7%86%E9%A2%91%E6%B8%B2%E6%9F%93%E5%85%A5%E9%97%A8/&quot; tar
      
    
    </summary>
    
      <category term="SDL2" scheme="http://yoursite.com/categories/SDL2/"/>
    
    
      <category term="音视频" scheme="http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="SDL2" scheme="http://yoursite.com/tags/SDL2/"/>
    
  </entry>
  
  <entry>
    <title>SDL2事件处理</title>
    <link href="http://yoursite.com/2019/04/15/SDL2%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2019/04/15/SDL2事件处理/</id>
    <published>2019-04-15T07:51:06.000Z</published>
    <updated>2019-04-20T08:31:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇<a href="https://david1840.github.io/2019/04/11/SDL2%E9%9F%B3%E8%A7%86%E9%A2%91%E6%B8%B2%E6%9F%93%E5%85%A5%E9%97%A8/" target="_blank" rel="noopener">SDL2音视频渲染入门</a>中，我们只是展示了一个窗口，3秒钟后自动消失。如何让这个窗口像其他正常应用的窗口一样可以进行拖动、最小化、关闭等操作，这个时候就需要SDL的事件处理了。这里所指的事件处理就是我们通常所说的，键盘事件，鼠标事件，窗口事件等，SDL对这些事件都做了封装，提供了统一的API。</p><h3 id="SDL事件处理"><a href="#SDL事件处理" class="headerlink" title="SDL事件处理"></a>SDL事件处理</h3><p>在SDL中，将所有的事件都存放在一个队列中，然后通过一个循环从队列中取出数据，进行处理，所有对事件的操作，其实就是对队列的操作。</p><p>将上一篇中的代码<code>SDL_Delay(3000); // 延时3秒</code>改为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (quit) &#123;</span><br><span class="line">    SDL_WaitEvent(&amp;event);</span><br><span class="line">    <span class="keyword">switch</span> (event.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> SDL_QUIT:<span class="comment">//退出事件</span></span><br><span class="line">            SDL_Log(<span class="string">"quit"</span>);</span><br><span class="line">            quit = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            SDL_Log(<span class="string">"event type:%d"</span>, event.type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现一个点击窗口“x”号关闭窗口的功能。</p><h4 id="事件轮训方式"><a href="#事件轮训方式" class="headerlink" title="事件轮训方式"></a>事件轮训方式</h4><p>SDL_WaitEvent: 事件驱动方式，当列表中有事件存在才会触发处理流程，否则处于阻塞状态，释放 CPU</p><p>SDL_PollEvent: 轮训方式，定时不断从列表中取出数据处理（可能会导致CPU 100%） </p><p>SDL_WaitEventTimeout: 与SDL_WaitEvent的区别时，当到达超时时间后，退出阻塞状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">即然有 SDL_WaitEvent了，为什么还要有SDL_PollEvent呢？这主要是由于使用的场景不同。对于游戏来说，它要求事件的实时处理，就使用SDL_PollEvent； 而对于一些其它实时性不高的情况来说，则可以使用 SDL_WaitEvent了。</span><br></pre></td></tr></table></figure><h4 id="SDL事件类型"><a href="#SDL事件类型" class="headerlink" title="SDL事件类型"></a>SDL事件类型</h4><p>SDL_WindowEvent : Window窗口相关的事件。</p><p>SDL_KeyboardEvent : 键盘相关的事件。</p><p>SDL_MouseMotionEvent : 鼠标移动相关的事件。</p><p>SDL_QuitEvent : 退出事件。</p><p>SDL_UserEvent : 用户自定义事件。</p><p>具体信息可以查看<a href="https://wiki.libsdl.org/SDL_Event" target="_blank" rel="noopener">SDL Wiki</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在上一篇&lt;a href=&quot;https://david1840.github.io/2019/04/11/SDL2%E9%9F%B3%E8%A7%86%E9%A2%91%E6%B8%B2%E6%9F%93%E5%85%A5%E9%97%A8/&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="SDL2" scheme="http://yoursite.com/categories/SDL2/"/>
    
    
      <category term="音视频" scheme="http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="SDL2" scheme="http://yoursite.com/tags/SDL2/"/>
    
  </entry>
  
  <entry>
    <title>SDL2音视频渲染入门</title>
    <link href="http://yoursite.com/2019/04/11/SDL2%E9%9F%B3%E8%A7%86%E9%A2%91%E6%B8%B2%E6%9F%93%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2019/04/11/SDL2音视频渲染入门/</id>
    <published>2019-04-11T06:23:25.000Z</published>
    <updated>2019-04-20T08:31:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>SDL， “Simple DirectMedia Layer”，它是一套开放源代码的跨平台多媒体开发库，使用C语言写成。其主要用于游戏开发中的多媒体处理，如视频渲染，音频播放，鼠标/键盘控制等操作。它对外接供了一套统一的接口，但在内部，它会根据不同平台调用不同的底层 API库。如在 Linux 系统下，它会使用 opengl 做渲染，而在 Window 下它会调用 D3D API进行渲染。</p><h2 id="SDL2安装"><a href="#SDL2安装" class="headerlink" title="SDL2安装"></a>SDL2安装</h2><p>SDL官网下载：<a href="https://www.libsdl.org/download-2.0.php" target="_blank" rel="noopener">https://www.libsdl.org/download-2.0.php</a></p><p>下载Source Code（以后去看源代码也比较方便），然后进行编译安装：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">configure --<span class="built_in">prefix</span>=/usr/<span class="built_in">local</span></span><br></pre></td></tr></table></figure><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">make</span> &amp;&amp; <span class="built_in">make</span> install</span><br></pre></td></tr></table></figure><p>在/usr/local下就可以找到编译后的SDL2相关文件</p><h2 id="SDL2使用"><a href="#SDL2使用" class="headerlink" title="SDL2使用"></a>SDL2使用</h2><p>运行环境Windows + CLion，代码通用，不同平台只需要更改依赖的SDL库即可</p><h3 id="CMakeList"><a href="#CMakeList" class="headerlink" title="CMakeList"></a>CMakeList</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.12</span>)</span><br><span class="line"><span class="keyword">project</span>(SimplePlayer C)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_C_STANDARD <span class="number">99</span>)</span><br><span class="line"><span class="keyword">set</span>(SOURCE_FILES main.c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里我使用的是自己机器上安装的SDL库，根据自己的安装路径替换</span></span><br><span class="line"><span class="keyword">set</span>(INC_DIR_SDL C:/cygwin64/usr/local/<span class="keyword">include</span>/SDL2/)</span><br><span class="line"><span class="keyword">set</span>(LINK_DIR_SDL C:/cygwin64/usr/local/lib/)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;INC_DIR_SDL&#125;</span>)</span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;LINK_DIR_SDL&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(SimplePlayer <span class="variable">$&#123;SOURCE_FILES&#125;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(</span><br><span class="line">        SimplePlayer</span><br><span class="line">        SDL2</span><br><span class="line">        SDL2main)</span><br></pre></td></tr></table></figure><h3 id="SDL的基本流程"><a href="#SDL的基本流程" class="headerlink" title="SDL的基本流程"></a>SDL的基本流程</h3><p>1、初始化SDL<br>2、创建窗口<br>3、创建渲染器<br>4、清空缓冲区<br>5、绘制要显示的内容<br>6、最终将缓冲区内容渲染到window窗口上。<br>7、销毁渲染器<br>8、销毁窗口<br>9、退出SDL</p><p>下面是一个最简单的SDL程序，会显示一个640*480的窗口，窗口内部为红色，显示3秒后消失</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;SDL2/SDL.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">WinMain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SDL_Window *window = <span class="literal">NULL</span>;</span><br><span class="line">    SDL_Renderer *renderer = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    SDL_Init(SDL_INIT_VIDEO);<span class="comment">// 初始化函数,可以确定希望激活的子系统</span></span><br><span class="line"></span><br><span class="line">    window = SDL_CreateWindow(<span class="string">"My First Window"</span>,</span><br><span class="line">                              SDL_WINDOWPOS_UNDEFINED,</span><br><span class="line">                              SDL_WINDOWPOS_UNDEFINED,</span><br><span class="line">                              <span class="number">640</span>,</span><br><span class="line">                              <span class="number">480</span>,</span><br><span class="line">                              SDL_WINDOW_OPENGL | SDL_WINDOW_RESIZABLE);<span class="comment">//  创建窗口</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!window) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    renderer = SDL_CreateRenderer(window, <span class="number">-1</span>, <span class="number">0</span>);<span class="comment">//基于窗口创建渲染器</span></span><br><span class="line">    <span class="keyword">if</span> (!renderer) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    SDL_SetRenderDrawColor(renderer, <span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>); <span class="comment">//设置渲染器颜色 r、g、b、a</span></span><br><span class="line">    SDL_RenderClear(renderer);<span class="comment">//用指定的颜色清空缓冲区</span></span><br><span class="line">    SDL_RenderPresent(renderer); <span class="comment">//将缓冲区中的内容输出到目标窗口上。</span></span><br><span class="line">    SDL_Delay(<span class="number">3000</span>); <span class="comment">// 延时3秒</span></span><br><span class="line">    SDL_DestroyRenderer(renderer); <span class="comment">//销毁渲染器</span></span><br><span class="line">    SDL_DestroyWindow(window); <span class="comment">// 销毁窗口</span></span><br><span class="line">    SDL_Quit(); <span class="comment">//退出SDL</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/SDL2音视频渲染入门/SDL2-1.png" alt=""></p><h3 id="SDL-API简介"><a href="#SDL-API简介" class="headerlink" title="SDL API简介"></a>SDL API简介</h3><ol><li><p>SDL_Init 初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SDL_Init</span><span class="params">(Uint32 flags)</span></span></span><br></pre></td></tr></table></figure><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flages：</span><br><span class="line">SDL_INIT_TIMER 定时器子系统</span><br><span class="line">SDL_INIT_AUDIO 音频子系统</span><br><span class="line">SDL_INIT_VIDEO 视频子系统，同时会初始化事件子系统</span><br><span class="line">SDL_INIT_EVENTS 事件子系统</span><br><span class="line">SDL_INIT_EVERYTHING 初始化所有子系统=</span><br></pre></td></tr></table></figure></li><li><p>SDL_CreateWindow 创建窗口</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SDL_Window* <span class="title">SDL_CreateWindow</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *title,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> w,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">int</span> h, Uint32 flags)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">title：窗口标题</span><br><span class="line">x,y,w,h：窗口坐标</span><br><span class="line"><span class="symbol">flags:</span></span><br><span class="line"> ::SDL_WINDOW_FULLSCREEN,<span class="regexp">//</span>全屏         ::SDL_WINDOW_OPENGL,<span class="regexp">//</span>使用OpenGL上下文</span><br><span class="line"> ::SDL_WINDOW_HIDDEN, <span class="regexp">//</span>窗口不可见       ::SDL_WINDOW_BORDERLESS, <span class="regexp">//</span>无边框</span><br><span class="line"> ::SDL_WINDOW_RESIZABLE,<span class="regexp">//</span>窗口大小可变    ::SDL_WINDOW_MAXIMIZED, <span class="regexp">//</span>窗口最大化</span><br><span class="line"> ::SDL_WINDOW_MINIMIZED,<span class="regexp">//</span>窗口最小化      ::SDL_WINDOW_INPUT_GRABBED,<span class="regexp">//</span>输入捕获</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>SDL_CreateRenderer 创建渲染器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SDL_Renderer* <span class="title">SDL_CreateRenderer</span><span class="params">(SDL_Window* window,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> index,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 Uint32 flags)</span></span></span><br></pre></td></tr></table></figure><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">window: 指明在哪个窗口里进行渲染</span><br><span class="line">index: 指定渲染驱动的索引号。一般指定为 -<span class="number">1</span>.</span><br><span class="line">flags：</span><br><span class="line"> SDL_RENDERER_SOFTWARE <span class="comment">//The renderer is a software fallback 软件备份</span></span><br><span class="line"> SDL_RENDERER_ACCELERATED <span class="comment">//The renderer uses hardware acceleration 硬件加速</span></span><br><span class="line"> SDL_RENDERER_PRESENTVSYNC <span class="comment">//Present is synchronized with the refresh rate 刷新率同步</span></span><br><span class="line"> SDL_RENDERER_TARGETTEXTURE <span class="comment">//The renderer supports rendering to texture 支持渲染纹理</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SDL， “Simple DirectMedia Layer”，它是一套开放源代码的跨平台多媒体开发库，使用C语言写成。其主要用于游戏开发中的多媒体处理，如视频渲染，音频播放，鼠标/键盘控制等操作。它对外接供了一套统一的接口，但在内部，它会根据不同平台调用不同的底层 API
      
    
    </summary>
    
      <category term="SDL2" scheme="http://yoursite.com/categories/SDL2/"/>
    
    
      <category term="音视频" scheme="http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="SDL2" scheme="http://yoursite.com/tags/SDL2/"/>
    
  </entry>
  
  <entry>
    <title>Android JNI学习-异常处理</title>
    <link href="http://yoursite.com/2019/02/14/Android-JNI%E5%AD%A6%E4%B9%A0-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2019/02/14/Android-JNI学习-异常处理/</id>
    <published>2019-02-14T13:25:55.000Z</published>
    <updated>2019-02-16T06:01:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>异常我们已经很熟悉了，空指针、数组越界等等，在Java中，当抛出一个异常，虚拟机会停止执行代码块并进入调用栈反向检查能处理特定异常的异常处理程序代码块，虚拟机清除异常并将控制权交给异常处理程序。而JNI不同，JNI没有像Java一样有try…catch…final这样的异常处理机制，面且在本地代码中调用某个JNI接口时如果发生了异常，后续的本地代码不会立即停止执行，而会继续往下执行后面的代码，这就要求开发人员在异常发生后显式地实现异常处理。</p><h3 id="1-捕获异常"><a href="#1-捕获异常" class="headerlink" title="1 捕获异常"></a>1 捕获异常</h3><p>在一个方法执行之后，可以调用<code>(*env)-&gt;ExceptionCheck</code>或者 <code>(*env)-&gt;ExceptionOccurred</code>（两者的区别在于返回值不一样）</p><p><code>ExceptionCheck</code>：检查是否发生了异常，若有异常返回JNI_TRUE，否则返回JNI_FALSE  <code>ExceptionOccurred</code>：检查是否发生了异常，若用异常返回该异常的引用，否则返回NULL </p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> jchar *<span class="function"><span class="title">cstr</span> = <span class="params">(*env)</span>-&gt;</span>GetStringChars(env, jstr);</span><br><span class="line"><span class="keyword">if</span> (c_str == NULL) &#123;</span><br><span class="line">    <span class="keyword">return</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="function"><span class="params">((*env)-&gt;ExceptionCheck(env))</span> &#123; /* 异常检查 */</span></span><br><span class="line"><span class="function">    <span class="params">(*env)</span>-&gt;</span>ReleaseStringChars(env, jstr, cstr); <span class="regexp">// 发生异常后释放分配内存</span></span><br><span class="line"><span class="regexp">    return; </span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="2-抛出异常"><a href="#2-抛出异常" class="headerlink" title="2 抛出异常"></a>2 抛出异常</h3><p>ThrowNew：在当前线程触发一个异常，并自定义输出异常信息<br><code>jint (JNICALL *ThrowNew) (JNIEnv *env, jclass clazz, const char *msg);</code> </p><p>Throw：丢弃一个现有的异常对象，在当前线程触发一个新的异常<br><code>jint (JNICALL *Throw) (JNIEnv *env, jthrowable obj);</code> </p><p>FatalError：致命异常，用于输出一个异常信息，并终止当前VM实例（即退出程序） </p><p><code>void (JNICALL *FatalError) (JNIEnv *env, const char *msg);</code></p><h3 id="3-示例"><a href="#3-示例" class="headerlink" title="3 示例"></a>3 示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">jclass jclass1 = (*env)-&gt;FindClass(env, <span class="string">"com/test/JNIController"</span>);</span><br><span class="line">    <span class="keyword">if</span> (jclass1 == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    jmethodID methodID = (*env)-&gt;GetMethodID(env, jclass1, <span class="string">"exitProcessCallBack"</span>, <span class="string">"(III)V"</span>);</span><br><span class="line">    <span class="keyword">if</span> (methodID == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    (*env)-&gt;CallVoidMethod(env, local_object, methodID, code, uploaded, all);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((*env)-&gt;ExceptionCheck)&#123;</span><br><span class="line">        (*env)-&gt;ExceptionDescribe(env);     <span class="comment">// 打印异常的堆栈信息 </span></span><br><span class="line">        (*env)-&gt;ExceptionClear(env);        <span class="comment">// 清除异常堆栈信息 </span></span><br><span class="line">        (*env)-&gt;ThrowNew(env,(*env)-&gt;FindClass(env,<span class="string">"java/lang/Exception"</span>),<span class="string">"JNI出现异常！"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h3><ol><li>当调用一个JNI函数后，必须先检查、处理、清除异常后再做其它 JNI 函数调用，否则会产生不可预知的结果。 </li><li>一旦发生异常，立即返回，让调用者处理这个异常。或 调用 ExceptionClear 清除异常，然后执行自己的异常处理代码。 </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;异常我们已经很熟悉了，空指针、数组越界等等，在Java中，当抛出一个异常，虚拟机会停止执行代码块并进入调用栈反向检查能处理特定异常的异常处理程序代码块，虚拟机清除异常并将控制权交给异常处理程序。而JNI不同，JNI没有像Java一样有try…catch…final这样的异常
      
    
    </summary>
    
      <category term="Android开发" scheme="http://yoursite.com/categories/Android%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JNI" scheme="http://yoursite.com/tags/JNI/"/>
    
      <category term="NDK" scheme="http://yoursite.com/tags/NDK/"/>
    
  </entry>
  
  <entry>
    <title>Android JNI学习-线程操作</title>
    <link href="http://yoursite.com/2019/02/14/Android-JNI%E5%AD%A6%E4%B9%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/02/14/Android-JNI学习-多线程/</id>
    <published>2019-02-14T12:30:18.000Z</published>
    <updated>2019-02-16T06:01:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>Android Native中支持的线程标准是 POSIX 线程。POSIX 线程也被简称为Pthreads，是一个线程的POSIX 标准，它为创建和处理线程定义了一个通用的API。</p><p>POSIX Thread 的Android实现是Bionic标准库的一部分，在编译的时候不需要链接任何其他的库，只需要包含一个头文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><p>线程创建函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">pthread_t</span>* thread, </span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">pthread_attr_t</span> <span class="keyword">const</span>* attr, </span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">void</span>* (*start_routine)(<span class="keyword">void</span>*), </span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">void</span>* arg)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>thread：指向 pthread_t 类型变量的指针，用它代表返回线程的句柄</p></li><li><p>attr：指向 pthread_attr_t 结构的指针形式存在的新线程属性，可以通过该结构来指定新线程的一些属性，比如栈大小、调度优先级等，具体看 pthread_attr_t 结构的内容。如果没有特殊要求，可使用默认值，把该变量取值为 NULL 。</p></li><li><p>第三个参数是指向启动函数的函数指针，它的函数签名格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">start_routine</span><span class="params">(<span class="keyword">void</span>* args)</span></span></span><br></pre></td></tr></table></figure><p>启动程序将线程参数看成 void 指针，返回 void 指针类型结果。</p></li><li><p>线程启动程序的参数，也就是函数的参数，如果不需要传递参数，它可以为 NULL 。</p></li></ul><p><code>pthread_create</code> 函数如果执行成功了则返回 0 ，如果返回其他错误代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">void</span> *)</span></span>&#123;</span><br><span class="line">    LOGE(<span class="string">"say %s"</span>,<span class="string">"hello"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JNIEXPORT jint JNICALL Java_com_david_JNIController_sayhello</span><br><span class="line">        (JNIEnv *jniEnv, jobject instance) &#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> handles; <span class="comment">// 线程句柄</span></span><br><span class="line">    <span class="keyword">int</span> ret = pthread_create(&amp;handles, <span class="literal">NULL</span>, sayHello, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"create thread failed"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LOGD(<span class="string">"create thread success"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用函数就可以在线程执行打印say hello了。</p><h3 id="附着在Java虚拟机上"><a href="#附着在Java虚拟机上" class="headerlink" title="附着在Java虚拟机上"></a>附着在Java虚拟机上</h3><p>创建了线程后，只能做一些简单的Native操作，如果想要对Java层做一些操作就不行了，因为它没有Java虚拟机环境，这个时候为了和Java空间进行交互，就要把POSIX 线程附着在Java虚拟机上，然后就可以获得当前线程的 JNIEnv 指针了。</p><p>通过 <code>AttachCurrentThread</code> 方法可以将当前线程附着到 Java 虚拟机上，并且可以获得 JNIEnv 指针。而<code>AttachCurrentThread</code> 方法是由 JavaVM 指针调用的，可以在<code>JNI_OnLoad</code>函数中将JavaVM 保存为全局变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> JavaVM *jVm = <span class="literal">NULL</span>;</span><br><span class="line"><span class="function">JNIEXPORT <span class="keyword">int</span> JNICALL <span class="title">JNI_OnLoad</span><span class="params">(JavaVM *vm, <span class="keyword">void</span> *reserved)</span> </span>&#123;</span><br><span class="line">    jVm = vm;</span><br><span class="line">    <span class="keyword">return</span> JNI_VERSION_1_6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上一个例子，我们想要在sayHello函数中调用一个Java层的函数<code>javaSayHello()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">javaSayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Log.e(TAG,<span class="string">"java say hello"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">void</span> *)</span></span>&#123;</span><br><span class="line">    LOGE(<span class="string">"say %s"</span>,<span class="string">"hello"</span>);</span><br><span class="line">     JNIEnv *env = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 将当前线程添加到 Java 虚拟机上</span></span><br><span class="line">    <span class="keyword">if</span> (jVm-&gt;AttachCurrentThread(&amp;env, <span class="literal">NULL</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line">        env-&gt;CallVoidMethod(Obj, javaSayHello);</span><br><span class="line">        <span class="comment">// 从 Java 虚拟机上分离当前线程</span></span><br><span class="line">        jVm-&gt;DetachCurrentThread();  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就在 Native 线程中调用 Java 相关的函数了。</p><h3 id="等待线程返回结果"><a href="#等待线程返回结果" class="headerlink" title="等待线程返回结果"></a>等待线程返回结果</h3><p>前面提到的方法是新线程运行后，该方法也就立即返回退出，执行完了。我们也可以通过另一个函数可以在等待线程执行完毕后，拿到线程执行完的结果之后再退出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> pthread, <span class="keyword">void</span>** ret_value)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>pthread 代表创建线程的句柄</li><li>ret_value代表线程运行函数返回的结果</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_t</span>* handles = <span class="keyword">new</span> <span class="keyword">pthread_t</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">       <span class="keyword">pthread_t</span> pthread;</span><br><span class="line">       <span class="comment">// 创建线程，</span></span><br><span class="line">       <span class="keyword">int</span> result = pthread_create(&amp;handles[i], <span class="literal">NULL</span>, run, <span class="literal">NULL</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">       <span class="keyword">void</span> *result = <span class="literal">NULL</span>; <span class="comment">// 线程执行返回结果</span></span><br><span class="line">       <span class="comment">// 等待线程执行结束</span></span><br><span class="line">       <span class="keyword">if</span> (pthread_join(handles[i], &amp;result) != <span class="number">0</span>) &#123;</span><br><span class="line">           env-&gt;ThrowNew(env, runtimeException, <span class="string">"Unable to join thread"</span>);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LOGD(<span class="string">"return value is %d"</span>,result);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p> pthread_join 返回为 0 代表执行成功，非 0 则执行失败。</p><h3 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h3><p>在Java中，JDK为我们提供了synchronized来处理多线程同步代码块。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (object.class) &#123;</span><br><span class="line">       <span class="comment">// 业务处理</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>本地代码中，JNI提供了两个函数来完成上面的同步：</p><p>（1）MonitorEnter：进入同步代码块</p><p>（2）MonitorExit：退出同步代码块</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(env-&gt;MonitorEnter(obj)!= JNI_OK)&#123;</span><br><span class="line">    <span class="comment">// 错误处理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步代码块</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 出现错误释放代码块</span></span><br><span class="line"><span class="keyword">if</span>(env-&gt;ExceptionCheck())&#123;</span><br><span class="line">    <span class="keyword">if</span>(env-&gt;MonitorExit(obj)!= JNI_OK);</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(env-&gt;MonitorExit(obj)!= JNI_OK)&#123;</span><br><span class="line">    <span class="comment">// 错误处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现在本地代码中处理同步代码块要比Java中复杂的多，所以，尽量用Java来做同步吧，把与同步相关的代码都移到Java中去。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Android Native中支持的线程标准是 POSIX 线程。POSIX 线程也被简称为Pthreads，是一个线程的POSIX 标准，它为创建和处理线程定义了一个通用的API。&lt;/p&gt;
&lt;p&gt;POSIX Thread 的Android实现是Bionic标准库的一部分，
      
    
    </summary>
    
      <category term="Android开发" scheme="http://yoursite.com/categories/Android%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JNI" scheme="http://yoursite.com/tags/JNI/"/>
    
      <category term="NDK" scheme="http://yoursite.com/tags/NDK/"/>
    
  </entry>
  
  <entry>
    <title>Android native层动态加载so库</title>
    <link href="http://yoursite.com/2019/02/13/Android-native%E5%B1%82%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BDso%E5%BA%93/"/>
    <id>http://yoursite.com/2019/02/13/Android-native层动态加载so库/</id>
    <published>2019-02-13T13:40:33.000Z</published>
    <updated>2019-02-16T06:01:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>随着App功能的不断增多，Native层的代码规模也在迅速膨胀，为了Native层的代码结构清晰，会按照模块分别构建成独立的so库，使用一个JNI层so库引用其他实现具体功能的功能实现so库，Java层只加载这个JNI层so库，来间接调用功能实现so库。</p><p><img src="/2019/02/13/Android-native层动态加载so库/native-so1.png" alt=""></p><p>so库之间通过引用头文件和运行时指定共享库依赖的方式形成了依赖关系。但是这样也会有一些问题。</p><ol><li>我们常常会用到第三方的 so 库，如果单个库可能没问题，如果多个第三方 so 库文件，同时加载可能会出现冲突，比如说腾讯的YSDK和BUGLY。</li><li>加载JNI层so库的时候，即使这次JNI调用有些功能实现so库里面的数据结构或函数没有被调用到，只要这个so库被JNI层so库声明为运行时需要依赖的共享库，也需要跟JNI层so库一起被加载，这无形中增大了Native层的常驻内存。</li></ol><p>这个时候就需要在Native层直接动态加载so库，由JNI层so库动态加载功能实现so库。如下图所示，会有一个统一接口so库，在这个库中定义好不可轻易修改的接口函数，调用方只需要知道这些接口即可，不需要依赖头文件就能调用这些函数，这样调用方和so库之间就不存在直接的依赖，具体的工作就可以交给统一接口so库完成，它通过动态调用再去执行功能so库中的函数。</p><p><img src="/2019/02/13/Android-native层动态加载so库/native-so2.png" alt=""></p><h3 id="so库动态加载的实现"><a href="#so库动态加载的实现" class="headerlink" title="so库动态加载的实现"></a>so库动态加载的实现</h3><p>在Native层的C/C++代码环境，so库动态加载是使用<code>dlopen()</code>、<code>dlsym()</code>和<code>dlclose()</code>这三个函数实现的。它们的作用分别是：<code>dlopen()</code>打开一个动态链接库，返回一个动态链接库的句柄；<code>dlsym()</code>根据动态链接库句柄和符号名，返回动态链接库内的符号地址，这个地址既可以是变量指针，也可以是函数指针；<code>dlclose()</code>关闭动态链接库句柄，并对动态链接库的引用计数减1，当这个库的引用计数为0，这个库将会被系统卸载。</p><p>一般使用C/C++实现so库动态加载的流程如下：</p><ol><li>首先调用<code>dlopen()</code>函数，这个函数所需的参数，一个是so库的路径，一个是加载模式。一般使用的加载模式有两个：<code>RTLD_NOW</code>在返回前解析出所有未定义符号，如果解析不出来，<code>dlopen()</code>返回<code>NULL</code>；<code>RTLD_LAZY</code>则只解析当前需要的符号（只对函数生效，变量定义仍然是全部解析）。显然对于动态加载，加载方只需知道当前被加载的so库里面自己需要用的函数和变量定义，所以这里选择的是后者。如果这个调用成功将返回一个so库的句柄；</li><li>在上一步得到so库句柄之后，这时就可以调用<code>dlsym()</code>函数，传入so库句柄和所需的函数或变量名称，返回相应的函数指针或变量指针；加载方这时就可以使用返回的指针调用被加载so库之中定义的函数和数据结构；</li><li>当so库的调用结束，调用<code>dlclose()</code>函数关闭卸载so库；</li><li>如果在打开关闭so库，或者获取so库里操作对象的指针出现错误的时候，可以调用<code>dlerror()</code>函数获取具体的错误原因。</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>比如，在硬件功能so库中有一个<code>int test_open(int port)</code>的函数，该如何最终调用到这个方法呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、声明函数接口</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*Func_test_open)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">int</span> port)</span></span>&#123;</span><br><span class="line">    <span class="comment">//2、获取so句柄</span></span><br><span class="line">    <span class="keyword">void</span> *handle = dlopen(<span class="string">"libtest.so"</span>,RTLD_LAZY);</span><br><span class="line">    <span class="keyword">if</span>(!handle )&#123;</span><br><span class="line">        LOGE(<span class="string">"%s"</span>,dlerror());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、获取函数指针</span></span><br><span class="line">    Func_test_open func_test_open = (Func_test_open) dlsym (handle,<span class="string">"test_open"</span>);</span><br><span class="line">    <span class="keyword">if</span>(!func_test_open)&#123;</span><br><span class="line">        LOGE(<span class="string">"%s"</span>,dlerror());</span><br><span class="line">        dlclose(handle);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//4、调用函数</span></span><br><span class="line">     <span class="keyword">int</span> ret = func_test_open(<span class="number">8080</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//5、关闭so</span></span><br><span class="line">     dlclose(handle); </span><br><span class="line">     </span><br><span class="line">     <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样JNI层只需要去调用<code>open(int port)</code>方法就可以调用到硬件功能so库中的<code>test_open(int port)</code>函数</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>刚开始使用动态加载so库的方案时，会比较担心性能问题，但在实测时跟直接依赖对比，对性能并没有明显的影响，功能实现的so库与JNI层完全解耦，有高度的独立内聚性。同时支持动态加载卸载so库，也一定程度上减少了Native层的常驻内存。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;随着App功能的不断增多，Native层的代码规模也在迅速膨胀，为了Native层的代码结构清晰，会按照模块分别构建成独立的so库，使用一个JNI层so库引用其他实现具体功能的功能实现so库，Java层只加载这个JNI层so库，来间接调用功能实现so库。&lt;/p&gt;
&lt;p&gt;&lt;i
      
    
    </summary>
    
      <category term="Android开发" scheme="http://yoursite.com/categories/Android%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JNI" scheme="http://yoursite.com/tags/JNI/"/>
    
      <category term="NDK" scheme="http://yoursite.com/tags/NDK/"/>
    
  </entry>
  
  <entry>
    <title>Android音视频(五) OpenSL ES录制、播放音频</title>
    <link href="http://yoursite.com/2019/02/11/Android%E9%9F%B3%E8%A7%86%E9%A2%91-%E4%BA%94-OpenSL-ES%E6%92%AD%E6%94%BE%E9%9F%B3%E9%A2%91/"/>
    <id>http://yoursite.com/2019/02/11/Android音视频-五-OpenSL-ES播放音频/</id>
    <published>2019-02-11T14:36:31.000Z</published>
    <updated>2019-02-16T06:01:22.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://david1840.github.io/2019/01/04/Android%E9%9F%B3%E8%A7%86%E9%A2%91-%E4%B8%80-Camera2-API%E9%87%87%E9%9B%86%E6%95%B0%E6%8D%AE/" target="_blank" rel="noopener">Android音视频(一) Camera2 API采集数据</a></p><p><a href="https://david1840.github.io/2019/01/06/Android%E9%9F%B3%E8%A7%86%E9%A2%91-%E4%BA%8C-%E9%9F%B3%E9%A2%91AudioRecord%E5%92%8CAudioTrack/" target="_blank" rel="noopener">Android音视频(二)音频AudioRecord和AudioTrack</a></p><p><a href="https://david1840.github.io/2019/01/07/Android%E9%9F%B3%E8%A7%86%E9%A2%91-%E5%9B%9B-FFmpeg-Camera2%E6%8E%A8%E6%B5%81%E7%9B%B4%E6%92%AD/" target="_blank" rel="noopener">Android音视频(三)FFmpeg Camera2推流直播</a></p><p><a href="https://david1840.github.io/2019/01/08/Android%E9%9F%B3%E8%A7%86%E9%A2%91-%E4%B8%89-MediaCodec%E7%A1%AC%E7%BC%96%E7%A1%AC%E8%A7%A3/" target="_blank" rel="noopener">Android音视频(四)MediaCodec编解码AAC</a></p><p>OpenSL ES (Open Sound Library for Embedded Systems)是无授权费、跨平台、针对嵌入式系统精心优化的硬件音频加速API。它为嵌入式移动多媒体设备上的本地应用程序开发者提供标准化, 高性能,低响应时间的音频功能实现方法，并实现软/硬件音频性能的直接跨平台部署，降低执行难度，促进高级音频市场的发展。简单来说OpenSL ES是一个嵌入式跨平台免费的音频处理库。 </p><p>在Android中一般使用AudioRecord、MediaRecorder对音频进行采集,使用MediaPlayer、AudioTrack、SoundPool进行音频播放。但这些都是在Java层上的接口，如果使用FFmpeg在C/C++层做音视频处理，那么调用这几个方法就比较麻烦了，所以Android NDK也提供了一个叫做OpenSL的C语言引擎用于声音的处理，这篇博客就是简单使用OpenSL去录制、播放音频。</p><h2 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h2><p>OpenSL ES 的开发流程主要有如下6个步骤：</p><p><strong>1、创建接口对象</strong></p><p><strong>2、设置混音器</strong></p><p><strong>3、创建播放器（录音器）</strong></p><p><strong>4、设置缓冲队列和回调函数</strong></p><p><strong>5、设置播放状态</strong></p><p><strong>6、启动回调函数</strong></p><p>其中第4步和第6步是OpenSL ES 播放PCM等数据格式的音频是需要用到的。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="定义Native方法"><a href="#定义Native方法" class="headerlink" title="定义Native方法"></a>定义Native方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//播放音频</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">play</span><span class="params">(String filePath)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//停止播放音频</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">playStop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//录制音频</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">record</span><span class="params">(String filePath)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//停止录制音频</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">stopRecod</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h3 id="录音"><a href="#录音" class="headerlink" title="录音"></a>录音</h3><h4 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置IO设备（麦克风）</span></span><br><span class="line">SLDataLocator_IODevice io_device = &#123;</span><br><span class="line">        SL_DATALOCATOR_IODEVICE,         <span class="comment">//类型 这里只能是SL_DATALOCATOR_IODEVICE</span></span><br><span class="line">        SL_IODEVICE_AUDIOINPUT,          <span class="comment">//device类型  选择了音频输入类型</span></span><br><span class="line">        SL_DEFAULTDEVICEID_AUDIOINPUT,   <span class="comment">//deviceID 对应的是SL_DEFAULTDEVICEID_AUDIOINPUT</span></span><br><span class="line">        <span class="literal">NULL</span>                             <span class="comment">//device实例</span></span><br><span class="line">&#125;;</span><br><span class="line">SLDataSource data_src = &#123;</span><br><span class="line">        &amp;io_device,                      <span class="comment">//SLDataLocator_IODevice配置输入</span></span><br><span class="line">        <span class="literal">NULL</span>                             <span class="comment">//输入格式，采集的并不需要</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置输出buffer队列</span></span><br><span class="line">SLDataLocator_AndroidSimpleBufferQueue buffer_queue = &#123;</span><br><span class="line">        SL_DATALOCATOR_ANDROIDSIMPLEBUFFERQUEUE,    <span class="comment">//类型 这里只能是SL_DATALOCATOR_ANDROIDSIMPLEBUFFERQUEUE</span></span><br><span class="line">        <span class="number">2</span>                                           <span class="comment">//buffer的数量</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//设置输出数据的格式</span></span><br><span class="line">SLDataFormat_PCM format_pcm = &#123;</span><br><span class="line">        SL_DATAFORMAT_PCM,                             <span class="comment">//输出PCM格式的数据</span></span><br><span class="line">        <span class="number">1</span>,                                             <span class="comment">//输出的声道数量</span></span><br><span class="line">        SL_SAMPLINGRATE_44_1,                          <span class="comment">//输出的采样频率，这里是44100Hz</span></span><br><span class="line">        SL_PCMSAMPLEFORMAT_FIXED_16,                   <span class="comment">//输出的采样格式，这里是16bit</span></span><br><span class="line">        SL_PCMSAMPLEFORMAT_FIXED_16,                   <span class="comment">//一般来说，跟随上一个参数</span></span><br><span class="line">        SL_SPEAKER_FRONT_LEFT,  <span class="comment">//双声道配置，如果单声道可以用 SL_SPEAKER_FRONT_CENTER</span></span><br><span class="line">        SL_BYTEORDER_LITTLEENDIAN                      <span class="comment">//PCM数据的大小端排列</span></span><br><span class="line">&#125;;</span><br><span class="line">SLDataSink audioSink = &#123;</span><br><span class="line">        &amp;buffer_queue,                   <span class="comment">//SLDataFormat_PCM配置输出</span></span><br><span class="line">        &amp;format_pcm                      <span class="comment">//输出数据格式</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="录音流程"><a href="#录音流程" class="headerlink" title="录音流程"></a>录音流程</h4><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1 创建引擎</span></span><br><span class="line">SLEngineItf eng = CreateRecordSL();</span><br><span class="line"><span class="keyword">if</span> (eng) &#123;</span><br><span class="line">    LOGE(<span class="string">"CreateSL success！ "</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    LOGE(<span class="string">"CreateSL failed！ "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建录制的对象，并且指定开放SL_IID_ANDROIDSIMPLEBUFFERQUEUE这个接口</span></span><br><span class="line">const SLInterfaceID id[<span class="number">1</span>] = &#123;SL_IID_ANDROIDSIMPLEBUFFERQUEUE&#125;;</span><br><span class="line">const SLboolean req[<span class="number">1</span>] = &#123;SL_BOOLEAN_TRUE&#125;;</span><br><span class="line"><span class="function"><span class="title">re</span> = (*eng)-&gt;</span>CreateAudioRecorder(eng,        <span class="comment">//引擎接口</span></span><br><span class="line">                                 &amp;recorder_object,   <span class="comment">//录制对象地址，用于传出对象</span></span><br><span class="line">                                 &amp;data_src,          <span class="comment">//输入配置</span></span><br><span class="line">                                 &amp;audioSink,         <span class="comment">//输出配置</span></span><br><span class="line">                                 <span class="number">1</span>,                  <span class="comment">//支持的接口数量</span></span><br><span class="line">                                 id,                 <span class="comment">//具体的要支持的接口</span></span><br><span class="line">                                 req                 <span class="comment">//具体的要支持的接口是开放的还是关闭的</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (re != SL_RESULT_SUCCESS) &#123;</span><br><span class="line">    LOGE(<span class="string">"CreateAudioRecorder failed!"</span>);</span><br><span class="line">    return -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例化这个录制对象</span></span><br><span class="line"><span class="function"><span class="title">re</span> = (*recorder_object)-&gt;</span>Realize(recorder_object, SL_BOOLEAN_FALSE);</span><br><span class="line"><span class="keyword">if</span> (re != SL_RESULT_SUCCESS) &#123;</span><br><span class="line">    LOGE(<span class="string">"Realize failed!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取录制接口</span></span><br><span class="line"><span class="function"><span class="title">re</span> = (*recorder_object)-&gt;</span>GetInterface(recorder_object, SL_IID_RECORD, &amp;recordItf);</span><br><span class="line"><span class="keyword">if</span> (re != SL_RESULT_SUCCESS) &#123;</span><br><span class="line">    LOGE(<span class="string">"GetInterface1 failed!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取Buffer接口</span></span><br><span class="line"><span class="function"><span class="title">re</span> = (*recorder_object)-&gt;</span>GetInterface(recorder_object, SL_IID_ANDROIDSIMPLEBUFFERQUEUE,</span><br><span class="line">                                      &amp;recorder_buffer_queue);</span><br><span class="line"><span class="keyword">if</span> (re != SL_RESULT_SUCCESS) &#123;</span><br><span class="line">    LOGE(<span class="string">"GetInterface2 failed!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//申请一块内存，注意RECORDER_FRAMES是自定义的一个宏，指的是采集的frame数量，具体还要根据你的采集格式(例如16bit)计算</span></span><br><span class="line">pcm_data = malloc(BUFFER_SIZE_IN_BYTES);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置数据回调接口bqRecorderCallback，最后一个参数是可以传输自定义的上下文引用</span></span><br><span class="line"><span class="function"><span class="title">re</span> = (*recorder_buffer_queue)-&gt;</span>RegisterCallback(recorder_buffer_queue, bqRecorderCallback, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (re != SL_RESULT_SUCCESS) &#123;</span><br><span class="line">    LOGE(<span class="string">"RegisterCallback failed!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置录制器为录制状态 SL_RECORDSTATE_RECORDING</span></span><br><span class="line"><span class="function"><span class="title">re</span> = (*recordItf)-&gt;</span>SetRecordState(recordItf, SL_RECORDSTATE_RECORDING);</span><br><span class="line"><span class="keyword">if</span> (re != SL_RESULT_SUCCESS) &#123;</span><br><span class="line">    LOGE(<span class="string">"SetRecordState failed!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在设置完录制状态后一定需要先Enqueue一次，这样的话才会开始采集回调</span></span><br><span class="line"><span class="function"><span class="title">re</span> = (*recorder_buffer_queue)-&gt;</span>Enqueue(recorder_buffer_queue, pcm_data, <span class="number">8192</span>);</span><br><span class="line"><span class="keyword">if</span> (re != SL_RESULT_SUCCESS) &#123;</span><br><span class="line">    LOGE(<span class="string">"Enqueue failed!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据回调函数</span></span><br><span class="line"><span class="selector-tag">void</span> <span class="selector-tag">bqRecorderCallback</span>(SLAndroidSimpleBufferQueueItf bq, void *context) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">fwrite</span>(pcm_data, BUFFER_SIZE_IN_BYTES, <span class="number">1</span>, gFile);</span><br><span class="line">    <span class="comment">//取完数据，需要调用Enqueue触发下一次数据回调</span></span><br><span class="line">    (*bq)<span class="selector-tag">-</span>&gt;<span class="selector-tag">Enqueue</span>(bq, pcm_data, BUFFER_SIZE_IN_BYTES);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="播放"><a href="#播放" class="headerlink" title="播放"></a>播放</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1 创建引擎</span></span><br><span class="line">SLEngineItf eng = CreateSL();</span><br><span class="line"><span class="keyword">if</span> (eng) &#123;</span><br><span class="line">    LOGE(<span class="string">"CreateSL success！ "</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    LOGE(<span class="string">"CreateSL failed！ "</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2 创建混音器</span></span><br><span class="line">SLObjectItf mix = <span class="keyword">NULL</span>;</span><br><span class="line">SLresult re = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">re = (*eng)-&gt;CreateOutputMix(eng, &amp;mix, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (re != SL_RESULT_SUCCESS) &#123;</span><br><span class="line">    LOGE(<span class="string">"SL_RESULT_SUCCESS failed!"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">re = (*mix)-&gt;Realize(mix, SL_BOOLEAN_FALSE);</span><br><span class="line"><span class="keyword">if</span> (re != SL_RESULT_SUCCESS) &#123;</span><br><span class="line">    LOGE(<span class="string">"(*mix)-&gt;Realize failed!"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SLDataLocator_OutputMix outmix = &#123;SL_DATALOCATOR_OUTPUTMIX, mix&#125;;</span><br><span class="line">SLDataSink audioSink = &#123;&amp;outmix, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3 配置音频信息</span></span><br><span class="line"><span class="comment">//数据定位器 就是定位要播放声音数据的存放位置，分为4种：内存位置，输入/输出设备位置，缓冲区队列位置，和midi缓冲区队列位置。</span></span><br><span class="line">SLDataLocator_AndroidSimpleBufferQueue que = &#123;SL_DATALOCATOR_ANDROIDSIMPLEBUFFERQUEUE, <span class="number">10</span>&#125;;</span><br><span class="line"><span class="comment">//音频格式</span></span><br><span class="line">SLDataFormat_PCM pcm = &#123;</span><br><span class="line">        SL_DATAFORMAT_PCM,</span><br><span class="line">        <span class="number">1</span>,<span class="comment">//    声道数</span></span><br><span class="line">        SL_SAMPLINGRATE_44_1,</span><br><span class="line">        SL_PCMSAMPLEFORMAT_FIXED_16,</span><br><span class="line">        SL_PCMSAMPLEFORMAT_FIXED_16,</span><br><span class="line">        SL_SPEAKER_FRONT_LEFT,</span><br><span class="line">        SL_BYTEORDER_LITTLEENDIAN <span class="comment">//字节序，小端</span></span><br><span class="line">&#125;;</span><br><span class="line">SLDataSource ds = &#123;&amp;que, &amp;pcm&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//4 创建播放器</span></span><br><span class="line">SLObjectItf player = <span class="keyword">NULL</span>;</span><br><span class="line">SLPlayItf iplayer = <span class="keyword">NULL</span>;</span><br><span class="line">SLAndroidSimpleBufferQueueItf pcmQue = <span class="keyword">NULL</span>;</span><br><span class="line"><span class="keyword">const</span> SLInterfaceID ids[] = &#123;SL_IID_BUFFERQUEUE&#125;;</span><br><span class="line"><span class="keyword">const</span> SLboolean req[] = &#123;SL_BOOLEAN_TRUE&#125;;</span><br><span class="line">re = (*eng)-&gt;CreateAudioPlayer(eng, &amp;player, &amp;ds, &amp;audioSink,</span><br><span class="line">                               sizeof(ids) / sizeof(SLInterfaceID), ids, req);</span><br><span class="line"><span class="keyword">if</span> (re != SL_RESULT_SUCCESS) &#123;</span><br><span class="line">    LOGE(<span class="string">"CreateAudioPlayer failed!"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    LOGE(<span class="string">"CreateAudioPlayer success!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">(*player)-&gt;Realize(player, SL_BOOLEAN_FALSE);</span><br><span class="line"><span class="comment">//获取player接口</span></span><br><span class="line">re = (*player)-&gt;GetInterface(player, SL_IID_PLAY, &amp;iplayer);</span><br><span class="line"><span class="keyword">if</span> (re != SL_RESULT_SUCCESS) &#123;</span><br><span class="line">    LOGE(<span class="string">"GetInterface SL_IID_PLAY failed!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">re = (*player)-&gt;GetInterface(player, SL_IID_BUFFERQUEUE, &amp;pcmQue);</span><br><span class="line"><span class="keyword">if</span> (re != SL_RESULT_SUCCESS) &#123;</span><br><span class="line">    LOGE(<span class="string">"GetInterface SL_IID_BUFFERQUEUE failed!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置回调函数，播放队列空调用</span></span><br><span class="line">(*pcmQue)-&gt;RegisterCallback(pcmQue, pcmCallBack, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//5 设置为播放状态</span></span><br><span class="line">(*iplayer)-&gt;SetPlayState(iplayer, SL_PLAYSTATE_PLAYING);</span><br><span class="line"></span><br><span class="line"><span class="comment">//6 启动队列回调</span></span><br><span class="line">(*pcmQue)-&gt;Enqueue(pcmQue, <span class="string">""</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h4 id="回调保存数据"><a href="#回调保存数据" class="headerlink" title="回调保存数据"></a>回调保存数据</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//回调函数</span></span><br><span class="line"><span class="keyword">void</span> pcmCallBack(SLAndroidSimpleBufferQueueItf bf, <span class="keyword">void</span> *contex) &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">1024</span> * <span class="number">1024</span>] = <span class="string">""</span>;</span><br><span class="line">    <span class="built_in">if</span> (feof(<span class="built_in">File</span>) == <span class="number">0</span>) &#123; <span class="comment">//没到结尾</span></span><br><span class="line">        <span class="keyword">int</span> len = (<span class="keyword">int</span>) fread(&amp;buf, <span class="number">1</span>, <span class="number">1024</span>, <span class="built_in">File</span>);</span><br><span class="line">        <span class="built_in">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 加入队列</span></span><br><span class="line">            (*bf)-&gt;Enqueue(bf, &amp;buf, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如有问题欢迎留言，<a href="https://github.com/David1840/AudioDemo" target="_blank" rel="noopener">Github源码-AudioDemo-openSLActivity</a>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://david1840.github.io/2019/01/04/Android%E9%9F%B3%E8%A7%86%E9%A2%91-%E4%B8%80-Camera2-API%E9%87%87%E9%9B%86%E6%95%B0%E6%8D
      
    
    </summary>
    
      <category term="Android音视频" scheme="http://yoursite.com/categories/Android%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="音频" scheme="http://yoursite.com/tags/%E9%9F%B3%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>Android音视频(四)MediaCodec编解码AAC</title>
    <link href="http://yoursite.com/2019/01/08/Android%E9%9F%B3%E8%A7%86%E9%A2%91-%E4%B8%89-MediaCodec%E7%A1%AC%E7%BC%96%E7%A1%AC%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/01/08/Android音视频-三-MediaCodec硬编硬解/</id>
    <published>2019-01-08T10:54:34.000Z</published>
    <updated>2019-01-12T06:43:21.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://david1840.github.io/2019/01/04/Android%E9%9F%B3%E8%A7%86%E9%A2%91-%E4%B8%80-Camera2-API%E9%87%87%E9%9B%86%E6%95%B0%E6%8D%AE/" target="_blank" rel="noopener">Android音视频(一) Camera2 API采集数据</a></p><p><a href="https://david1840.github.io/2019/01/06/Android%E9%9F%B3%E8%A7%86%E9%A2%91-%E4%BA%8C-%E9%9F%B3%E9%A2%91AudioRecord%E5%92%8CAudioTrack/" target="_blank" rel="noopener">Android音视频(二)音频AudioRecord和AudioTrack</a></p><p><a href="https://david1840.github.io/2019/01/07/Android%E9%9F%B3%E8%A7%86%E9%A2%91-%E5%9B%9B-FFmpeg-Camera2%E6%8E%A8%E6%B5%81%E7%9B%B4%E6%92%AD/" target="_blank" rel="noopener">Android音视频(三)FFmpeg Camera2推流直播</a></p><p>MediaCodec类可以访问底层媒体编解码框架（StageFright 或 OpenMAX），即编解码组件，它是Android基本的多媒体支持基础架构的一部分，通常和MediaExtractor、MediaSync、MediaMuxer、MediaCrypto、MediaDrm、Image、Surface和AudioTrack一起使用。它本身并不是Codec，它通过调用底层编解码组件获得了Codec的能力。</p><h2 id="MediaCodec的工作方式"><a href="#MediaCodec的工作方式" class="headerlink" title="MediaCodec的工作方式"></a>MediaCodec的工作方式</h2><p>MediaCodec处理输入数据产生输出数据。当异步处理数据时，使用一组输入和输出Buffer队列。通常，在逻辑上，客户端请求（或接收）数据后填入预先设定的空输入缓冲区，输入Buffer填满后将其传递到MediaCodec并进行编解码处理。之后MediaCodec编解码后的数据填充到一个输出Buffer中。最后，客户端请求（或接收）输出Buffer，消耗输出Buffer中的内容，用完后释放，给回MediaCodec重新填充输出数据。</p><p><img src="/2019/01/08/Android音视频-三-MediaCodec硬编硬解/1.png" alt="图片来自网络"></p><p>必须保证输入和输出队列同时非空，即至少有一个输入Buffer和输出Buffer才能工作。</p><h2 id="MediaCodec状态周期图"><a href="#MediaCodec状态周期图" class="headerlink" title="MediaCodec状态周期图"></a>MediaCodec状态周期图</h2><p>在MediaCodec的生命周期中存在三种状态 ：Stopped、Executing、Released。</p><p>Stopped状态实际上还可以处在三种状态：Uninitialized、Configured、Error。</p><p>Executing状态也分为三种子状态：Flushed, Running、End-of-Stream。</p><p><img src="/2019/01/08/Android音视频-三-MediaCodec硬编硬解/2.png" alt="图片来自网络"></p><p>从上图可以看出：</p><ol><li><p>当创建编解码器的时候处于未初始化状态。首先你需要调用configure(…)方法让它处于Configured状态，然后调用start()方法让其处于Executing状态。在Executing状态下，你就可以使用上面提到的缓冲区来处理数据。</p></li><li><p>Executing的状态下也分为三种子状态：Flushed, Running、End-of-Stream。在start() 调用后，编解码器处于Flushed状态，这个状态下它保存着所有的缓冲区。一旦第一个输入buffer出现了，编解码器就会自动运行到Running的状态。当带有end-of-stream标志的buffer进去后，编解码器会进入End-of-Stream状态，这种状态下编解码器不在接受输入buffer，但是仍然在产生输出的buffer。此时你可以调用flush()方法，将编解码器重置于Flushed状态。</p></li><li><p>调用stop()将编解码器返回到未初始化状态，然后可以重新配置。 完成使用编解码器后，您必须通过调用release()来释放它。</p></li><li>在极少数情况下，编解码器可能会遇到错误并转到错误状态。 这是使用来自排队操作的无效返回值或有时通过异常来传达的。 调用reset()使编解码器再次可用。 您可以从任何状态调用它来将编解码器移回未初始化状态。 否则，调用 release()动到终端释放状态。</li></ol><h2 id="MediaCodec的优缺点"><a href="#MediaCodec的优缺点" class="headerlink" title="MediaCodec的优缺点"></a>MediaCodec的优缺点</h2><p>优点：<strong>功耗低，速度快</strong></p><p>缺点：<strong>扩展性不强，不同芯片厂商提供的支持方案不同，导致程序移植性差</strong></p><p>适用场景：适合有固定的硬件方案的项目，如智能家居类；需要长时间摄像。</p><h2 id="MediaCodec-编解码实现"><a href="#MediaCodec-编解码实现" class="headerlink" title="MediaCodec 编解码实现"></a>MediaCodec 编解码实现</h2><p>做了一个Demo，使用AudioRecord录音，使用MediaCodec 编码为AAC并保存文件，然后可以从AAC解码为PCM数据，再用AudioTrack播放。</p><p><img src="/2019/01/08/Android音视频-三-MediaCodec硬编硬解/demo.png" alt="Demo截图"></p><h3 id="1、编码PCM数据，保存为AAC文件"><a href="#1、编码PCM数据，保存为AAC文件" class="headerlink" title="1、编码PCM数据，保存为AAC文件"></a>1、编码PCM数据，保存为AAC文件</h3><h4 id="初始化AudioRecord和编码器"><a href="#初始化AudioRecord和编码器" class="headerlink" title="初始化AudioRecord和编码器"></a>初始化AudioRecord和编码器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initAudioRecord</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> audioSource = MediaRecorder.AudioSource.MIC;</span><br><span class="line">    <span class="keyword">int</span> sampleRate = <span class="number">44100</span>;</span><br><span class="line">    <span class="keyword">int</span> channelConfig = AudioFormat.CHANNEL_IN_MONO;</span><br><span class="line">    <span class="keyword">int</span> audioFormat = AudioFormat.ENCODING_PCM_16BIT;</span><br><span class="line">    <span class="keyword">int</span> minBufferSize = AudioRecord.getMinBufferSize(sampleRate, channelConfig, audioFormat);</span><br><span class="line">    mAudioRecorder = <span class="keyword">new</span> AudioRecord(audioSource, sampleRate, channelConfig, audioFormat, Math.max(minBufferSize, <span class="number">2048</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化编码器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initAudioEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mAudioEncoder = MediaCodec.createEncoderByType(MediaFormat.MIMETYPE_AUDIO_AAC);</span><br><span class="line">        MediaFormat format = MediaFormat.createAudioFormat(MediaFormat.MIMETYPE_AUDIO_AAC, <span class="number">44100</span>, <span class="number">1</span>);</span><br><span class="line">        format.setInteger(MediaFormat.KEY_BIT_RATE, <span class="number">96000</span>);<span class="comment">//比特率</span></span><br><span class="line">        format.setInteger(MediaFormat.KEY_MAX_INPUT_SIZE, MAX_BUFFER_SIZE);</span><br><span class="line">        mAudioEncoder.configure(format, <span class="keyword">null</span>, <span class="keyword">null</span>, MediaCodec.CONFIGURE_FLAG_ENCODE);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mAudioEncoder == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"create mediaEncode failed"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mAudioEncoder.start(); <span class="comment">// 启动MediaCodec,等待传入数据</span></span><br><span class="line">    encodeInputBuffers = mAudioEncoder.getInputBuffers(); <span class="comment">//上面介绍的输入和输出Buffer队列</span></span><br><span class="line">    encodeOutputBuffers = mAudioEncoder.getOutputBuffers();</span><br><span class="line">    mAudioEncodeBufferInfo = <span class="keyword">new</span> MediaCodec.BufferInfo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="开始录音、编码"><a href="#开始录音、编码" class="headerlink" title="开始录音、编码"></a>开始录音、编码</h4><p>使用线程池，两条线程，一个线程去录音，另一个线程做编码操作。录音线程会将PCM数据存入一个队列中，编码线程从队列中取出数据编码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开启录音线程</span></span><br><span class="line">mExecutorService.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        startRecorder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 开启编码线程</span></span><br><span class="line">mExecutorService.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        encodePCM();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 将PCM数据存入队列</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">putPCMData</span><span class="params">(<span class="keyword">byte</span>[] pcmChunk)</span> </span>&#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"putPCMData"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            queue.put(pcmChunk);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从队列取出PCM数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] getPCMData() &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (queue.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> queue.take();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加ADTS头，如果要与视频流合并就不用添加，单独AAC文件就需要添加，否则无法正常播放</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addADTStoPacket</span><span class="params">(<span class="keyword">int</span> sampleRateType, <span class="keyword">byte</span>[] packet, <span class="keyword">int</span> packetLen)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> profile = <span class="number">2</span>; <span class="comment">// AAC LC</span></span><br><span class="line">        <span class="keyword">int</span> chanCfg = <span class="number">2</span>; <span class="comment">// CPE</span></span><br><span class="line"></span><br><span class="line">        packet[<span class="number">0</span>] = (<span class="keyword">byte</span>) <span class="number">0xFF</span>;</span><br><span class="line">        packet[<span class="number">1</span>] = (<span class="keyword">byte</span>) <span class="number">0xF9</span>;</span><br><span class="line">        packet[<span class="number">2</span>] = (<span class="keyword">byte</span>) (((profile - <span class="number">1</span>) &lt;&lt; <span class="number">6</span>) + (sampleRateType &lt;&lt; <span class="number">2</span>) + (chanCfg &gt;&gt; <span class="number">2</span>));</span><br><span class="line">        packet[<span class="number">3</span>] = (<span class="keyword">byte</span>) (((chanCfg &amp; <span class="number">3</span>) &lt;&lt; <span class="number">6</span>) + (packetLen &gt;&gt; <span class="number">11</span>));</span><br><span class="line">        packet[<span class="number">4</span>] = (<span class="keyword">byte</span>) ((packetLen &amp; <span class="number">0x7FF</span>) &gt;&gt; <span class="number">3</span>);</span><br><span class="line">        packet[<span class="number">5</span>] = (<span class="keyword">byte</span>) (((packetLen &amp; <span class="number">7</span>) &lt;&lt; <span class="number">5</span>) + <span class="number">0x1F</span>);</span><br><span class="line">        packet[<span class="number">6</span>] = (<span class="keyword">byte</span>) <span class="number">0xFC</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="音频数据"><a href="#音频数据" class="headerlink" title="音频数据"></a>音频数据</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取音频数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startRecorder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mFilePath = Environment.getExternalStorageDirectory().getAbsolutePath() + <span class="string">"/RecorderTest/"</span> + System.currentTimeMillis() + <span class="string">".aac"</span>;</span><br><span class="line">        mAudioFile = <span class="keyword">new</span> File(mFilePath);</span><br><span class="line">        <span class="keyword">if</span> (!mAudioFile.getParentFile().exists()) &#123;</span><br><span class="line">            mAudioFile.getParentFile().mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">        mAudioFile.createNewFile();</span><br><span class="line">        mFileOutputStream = <span class="keyword">new</span> FileOutputStream(mAudioFile);</span><br><span class="line">        mAudioBos = <span class="keyword">new</span> BufferedOutputStream(mFileOutputStream, <span class="number">200</span> * <span class="number">1024</span>);</span><br><span class="line">        mAudioRecorder.startRecording();</span><br><span class="line"></span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (mIsRecording) &#123;</span><br><span class="line">            <span class="keyword">int</span> read = mAudioRecorder.read(mBuffer, <span class="number">0</span>, <span class="number">2048</span>);</span><br><span class="line">            <span class="keyword">if</span> (read &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">byte</span>[] audio = <span class="keyword">new</span> <span class="keyword">byte</span>[read];</span><br><span class="line">                System.arraycopy(mBuffer, <span class="number">0</span>, audio, <span class="number">0</span>, read);</span><br><span class="line">                putPCMData(audio); <span class="comment">// PCM数据放入队列，等待编码</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | RuntimeException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mAudioRecorder != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mAudioRecorder.release();</span><br><span class="line">            mAudioRecorder = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h5><p>从队列中循环取出数据，MediaCodec 编码，将编码后的数据写入文件中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 编码PCM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">encodePCM</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> inputIndex;</span><br><span class="line">    ByteBuffer inputBuffer;</span><br><span class="line">    <span class="keyword">int</span> outputIndex;</span><br><span class="line">    ByteBuffer outputBuffer;</span><br><span class="line">    <span class="keyword">byte</span>[] chunkAudio;</span><br><span class="line">    <span class="keyword">int</span> outBitSize;</span><br><span class="line">    <span class="keyword">int</span> outPacketSize;</span><br><span class="line">    <span class="keyword">byte</span>[] chunkPCM;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (mIsRecording || !queue.isEmpty()) &#123;</span><br><span class="line">        chunkPCM = getPCMData();<span class="comment">//获取解码器所在线程输出的数据 代码后边会贴上</span></span><br><span class="line">        <span class="keyword">if</span> (chunkPCM == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inputIndex = mAudioEncoder.dequeueInputBuffer(-<span class="number">1</span>);<span class="comment">//同解码器</span></span><br><span class="line">        <span class="keyword">if</span> (inputIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            inputBuffer = encodeInputBuffers[inputIndex];<span class="comment">//同解码器</span></span><br><span class="line">            inputBuffer.clear();<span class="comment">//同解码器</span></span><br><span class="line">            inputBuffer.limit(chunkPCM.length);</span><br><span class="line">            inputBuffer.put(chunkPCM);<span class="comment">//PCM数据填充给inputBuffer</span></span><br><span class="line">            mAudioEncoder.queueInputBuffer(inputIndex, <span class="number">0</span>, chunkPCM.length, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//通知编码器 编码</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        outputIndex = mAudioEncoder.dequeueOutputBuffer(mAudioEncodeBufferInfo, <span class="number">10000</span>);</span><br><span class="line">        <span class="keyword">while</span> (outputIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            outBitSize = mAudioEncodeBufferInfo.size;</span><br><span class="line">            outPacketSize = outBitSize + <span class="number">7</span>;<span class="comment">//7为ADTS头部的大小</span></span><br><span class="line">            outputBuffer = encodeOutputBuffers[outputIndex];<span class="comment">//拿到输出Buffer</span></span><br><span class="line">            outputBuffer.position(mAudioEncodeBufferInfo.offset);</span><br><span class="line">            outputBuffer.limit(mAudioEncodeBufferInfo.offset + outBitSize);</span><br><span class="line">            chunkAudio = <span class="keyword">new</span> <span class="keyword">byte</span>[outPacketSize];</span><br><span class="line">            addADTStoPacket(<span class="number">44100</span>, chunkAudio, outPacketSize);<span class="comment">//添加ADTS</span></span><br><span class="line">            outputBuffer.get(chunkAudio, <span class="number">7</span>, outBitSize);<span class="comment">//将编码得到的AAC数据 取出到byte[]中 偏移量offset=7</span></span><br><span class="line">            outputBuffer.position(mAudioEncodeBufferInfo.offset);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mAudioBos.write(chunkAudio, <span class="number">0</span>, chunkAudio.length);<span class="comment">//BufferOutputStream 将文件保存到内存卡中 *.aac</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            mAudioEncoder.releaseOutputBuffer(outputIndex, <span class="keyword">false</span>);</span><br><span class="line">            outputIndex = mAudioEncoder.dequeueOutputBuffer(mAudioEncodeBufferInfo, <span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stopRecorder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、解码AAC-AudioTrack播放"><a href="#2、解码AAC-AudioTrack播放" class="headerlink" title="2、解码AAC AudioTrack播放"></a>2、解码AAC AudioTrack播放</h3><h4 id="初始化AudioTrack和解码器"><a href="#初始化AudioTrack和解码器" class="headerlink" title="初始化AudioTrack和解码器"></a>初始化AudioTrack和解码器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化AudioTrack，等待播放数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initAudioTrack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> streamType = AudioManager.STREAM_MUSIC;</span><br><span class="line">    <span class="keyword">int</span> sampleRate = <span class="number">44100</span>;</span><br><span class="line">    <span class="keyword">int</span> channelConfig = AudioFormat.CHANNEL_OUT_MONO;</span><br><span class="line">    <span class="keyword">int</span> audioFormat = AudioFormat.ENCODING_PCM_16BIT;</span><br><span class="line">    <span class="keyword">int</span> mode = AudioTrack.MODE_STREAM;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> minBufferSize = AudioTrack.getMinBufferSize(sampleRate, channelConfig, audioFormat);</span><br><span class="line"></span><br><span class="line">    audioTrack = <span class="keyword">new</span> AudioTrack(streamType, sampleRate, channelConfig, audioFormat,</span><br><span class="line">            Math.max(minBufferSize, <span class="number">2048</span>), mode);</span><br><span class="line">    audioTrack.play();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化解码器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initAudioDecoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mMediaExtractor = <span class="keyword">new</span> MediaExtractor();</span><br><span class="line">        mMediaExtractor.setDataSource(mFilePath);</span><br><span class="line"></span><br><span class="line">        MediaFormat format = mMediaExtractor.getTrackFormat(<span class="number">0</span>);</span><br><span class="line">        String mime = format.getString(MediaFormat.KEY_MIME);</span><br><span class="line">        <span class="keyword">if</span> (mime.startsWith(<span class="string">"audio"</span>)) &#123;<span class="comment">//获取音频轨道</span></span><br><span class="line">            mMediaExtractor.selectTrack(<span class="number">0</span>);<span class="comment">//选择此音频轨道</span></span><br><span class="line">            format.setString(MediaFormat.KEY_MIME, <span class="string">"audio/mp4a-latm"</span>);</span><br><span class="line">            format.setInteger(MediaFormat.KEY_CHANNEL_COUNT, <span class="number">1</span>);</span><br><span class="line">            format.setInteger(MediaFormat.KEY_SAMPLE_RATE, <span class="number">0</span>);</span><br><span class="line">            format.setInteger(MediaFormat.KEY_BIT_RATE, <span class="number">96000</span>);</span><br><span class="line">            format.setInteger(MediaFormat.KEY_IS_ADTS, <span class="number">1</span>);</span><br><span class="line">            format.setInteger(MediaFormat.KEY_AAC_PROFILE, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            mAudioDecoder = MediaCodec.createDecoderByType(mime);<span class="comment">//创建Decode解码器</span></span><br><span class="line">            mAudioDecoder.configure(format, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mAudioDecoder == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"mAudioDecoder is null"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mAudioDecoder.start();<span class="comment">//启动MediaCodec ，等待传入数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解码并播放"><a href="#解码并播放" class="headerlink" title="解码并播放"></a>解码并播放</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">decodeAndPlay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> isFinish = <span class="keyword">false</span>;</span><br><span class="line">    MediaCodec.BufferInfo decodeBufferInfo = <span class="keyword">new</span> MediaCodec.BufferInfo();</span><br><span class="line">    <span class="keyword">while</span> (!isFinish &amp;&amp; mIsPalying) &#123;</span><br><span class="line">        <span class="keyword">int</span> inputIdex = mAudioDecoder.dequeueInputBuffer(<span class="number">10000</span>);<span class="comment">//获取可用的inputBuffer -1代表一直等待，0表示不等待 10000表示10秒超时</span></span><br><span class="line">        <span class="keyword">if</span> (inputIdex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            isFinish = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ByteBuffer inputBuffer = mAudioDecoder.getInputBuffer(inputIdex);</span><br><span class="line">        inputBuffer.clear();<span class="comment">//清空之前传入inputBuffer内的数据</span></span><br><span class="line">        <span class="keyword">int</span> samplesize = mMediaExtractor.readSampleData(inputBuffer, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (samplesize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            mAudioDecoder.queueInputBuffer(inputIdex, <span class="number">0</span>, samplesize, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">//通知解码器 解码</span></span><br><span class="line">            mMediaExtractor.advance(); <span class="comment">//MediaExtractor移动到下一取样处</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            isFinish = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> outputIndex = mAudioDecoder.dequeueOutputBuffer(decodeBufferInfo, <span class="number">10000</span>);<span class="comment">//获取解码得到的byte[]数据</span></span><br><span class="line"></span><br><span class="line">        ByteBuffer outputBuffer;</span><br><span class="line">        <span class="keyword">byte</span>[] chunkPCM;</span><br><span class="line">        <span class="comment">//每次解码完成的数据不一定能一次吐出 所以用while循环，保证解码器吐出所有数据</span></span><br><span class="line">        <span class="keyword">while</span> (outputIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            outputBuffer = mAudioDecoder.getOutputBuffer(outputIndex);</span><br><span class="line">            chunkPCM = <span class="keyword">new</span> <span class="keyword">byte</span>[decodeBufferInfo.size];</span><br><span class="line">            outputBuffer.get(chunkPCM);</span><br><span class="line">            outputBuffer.clear();<span class="comment">//数据取出后一定记得清空此Buffer MediaCodec是循环使用这些Buffer的，不清空下次会得到同样的数</span></span><br><span class="line">            <span class="comment">// 播放解码后的PCM数据</span></span><br><span class="line">            audioTrack.write(chunkPCM, <span class="number">0</span>, decodeBufferInfo.size);</span><br><span class="line">            mAudioDecoder.releaseOutputBuffer(outputIndex, <span class="keyword">false</span>);</span><br><span class="line">            outputIndex = mAudioDecoder.dequeueOutputBuffer(decodeBufferInfo, <span class="number">10000</span>);<span class="comment">//再次获取数据</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    stopPlay();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Demo完成，手机测试效果不错。MediaCodec的使用要比我预想的复杂，网上查了好久才完成这个Demo，希望能帮到需要的人。</p><p>如有问题欢迎留言，<a href="https://github.com/David1840/AudioDemo" target="_blank" rel="noopener">Github源码 - MediaCodecActivity</a>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://david1840.github.io/2019/01/04/Android%E9%9F%B3%E8%A7%86%E9%A2%91-%E4%B8%80-Camera2-API%E9%87%87%E9%9B%86%E6%95%B0%E6%8D
      
    
    </summary>
    
      <category term="Android音视频" scheme="http://yoursite.com/categories/Android%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="MediaCodec" scheme="http://yoursite.com/tags/MediaCodec/"/>
    
  </entry>
  
  <entry>
    <title>Android音视频(三)FFmpeg Camera2推流直播</title>
    <link href="http://yoursite.com/2019/01/07/Android%E9%9F%B3%E8%A7%86%E9%A2%91-%E5%9B%9B-FFmpeg-Camera2%E6%8E%A8%E6%B5%81%E7%9B%B4%E6%92%AD/"/>
    <id>http://yoursite.com/2019/01/07/Android音视频-四-FFmpeg-Camera2推流直播/</id>
    <published>2019-01-07T03:07:25.000Z</published>
    <updated>2019-01-10T04:02:13.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://david1840.github.io/2019/01/04/Android%E9%9F%B3%E8%A7%86%E9%A2%91-%E4%B8%80-Camera2-API%E9%87%87%E9%9B%86%E6%95%B0%E6%8D%AE/" target="_blank" rel="noopener">Android音视频(一) Camera2 API采集数据</a></p><p><a href="https://david1840.github.io/2019/01/06/Android%E9%9F%B3%E8%A7%86%E9%A2%91-%E4%BA%8C-%E9%9F%B3%E9%A2%91AudioRecord%E5%92%8CAudioTrack/" target="_blank" rel="noopener">Android音视频(二)音频AudioRecord和AudioTrack</a></p><p>自己花了点时间实现了一个使用FFmpeg将Camera2视频数据推送到RTMP服务的简单Demo，在这里分享下，里面用到知识很多都是之前博客中用到的，难度不大。</p><h2 id="1、-定义方法"><a href="#1、-定义方法" class="headerlink" title="1、 定义方法"></a>1、 定义方法</h2><p>定义了三个JNI方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FFmpegHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">FFmpegHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> FFmpegHandler INSTANCE = <span class="keyword">new</span> FFmpegHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> FFmpegHandler <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonInstance.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">"ffmpeg-handler"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">init</span><span class="params">(String outUrl)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//推流，将Y、U、V数据分开传递</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">pushCameraData</span><span class="params">(<span class="keyword">byte</span>[] buffer,<span class="keyword">int</span> ylen,<span class="keyword">byte</span>[] ubuffer,<span class="keyword">int</span> ulen,<span class="keyword">byte</span>[] vbuffer,<span class="keyword">int</span> vlen)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//结束</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、Camera2实时数据"><a href="#2、Camera2实时数据" class="headerlink" title="2、Camera2实时数据"></a>2、Camera2实时数据</h2><p>具体使用可查看<a href="https://david1840.github.io/2019/01/04/Android%E9%9F%B3%E8%A7%86%E9%A2%91-%E4%B8%80-Camera2-API%E9%87%87%E9%9B%86%E6%95%B0%E6%8D%AE/" target="_blank" rel="noopener">Android音视频(一) Camera2 API采集数据</a></p><p>将ImageReader作为预览请求的Target之一，这样我们就可以将预览的数据拿到在onImageAvailable中进行处理推送。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mImageReader = ImageReader.newInstance(<span class="number">640</span>, <span class="number">480</span>,ImageFormat.YUV_420_888, <span class="number">1</span>); </span><br><span class="line">mImageReader.setOnImageAvailableListener(mOnImageAvailableListener, mBackgroundHandler);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Surface imageSurface = mImageReader.getSurface();</span><br><span class="line"></span><br><span class="line">mPreviewRequestBuilder = mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);</span><br><span class="line"></span><br><span class="line">mPreviewRequestBuilder.addTarget(surface);</span><br><span class="line">mPreviewRequestBuilder.addTarget(imageSurface);</span><br></pre></td></tr></table></figure><p>将获取的Image数据解析为YUV数据，Y、U、V数据分别存储。具体请看<a href="https://david1840.github.io/2018/12/20/YUV%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E4%B8%8EYUV_420_888/" target="_blank" rel="noopener">YUV数据格式与YUV_420_888</a>。</p><p>目前这块暂时这样写着，网上的博客都比较旧了，有点不太合适，我想应该还会有更好的方法，后面再做优化。（或者这块你有什么好的处理方法，欢迎留言）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ImageReader.OnImageAvailableListener mOnImageAvailableListener</span><br><span class="line">            = <span class="keyword">new</span> ImageReader.OnImageAvailableListener() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onImageAvailable</span><span class="params">(ImageReader reader)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">            Image image = reader.acquireLatestImage();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (image == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> Image.Plane[] planes = image.getPlanes();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> width = image.getWidth();</span><br><span class="line">            <span class="keyword">int</span> height = image.getHeight();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Y、U、V数据</span></span><br><span class="line">            <span class="keyword">byte</span>[] yBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[width * height];</span><br><span class="line">            <span class="keyword">byte</span> uBytes[] = <span class="keyword">new</span> <span class="keyword">byte</span>[width * height / <span class="number">4</span>];</span><br><span class="line">            <span class="keyword">byte</span> vBytes[] = <span class="keyword">new</span> <span class="keyword">byte</span>[width * height / <span class="number">4</span>];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//目标数组的装填到的位置</span></span><br><span class="line">            <span class="keyword">int</span> dstIndex = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> uIndex = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> vIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> pixelsStride, rowStride;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; planes.length; i++) &#123;</span><br><span class="line">                pixelsStride = planes[i].getPixelStride();</span><br><span class="line">                rowStride = planes[i].getRowStride();</span><br><span class="line"></span><br><span class="line">                ByteBuffer buffer = planes[i].getBuffer();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果pixelsStride==2，一般的Y的buffer长度=640*480，UV的长度=640*480/2-1</span></span><br><span class="line">                <span class="comment">//源数据的索引，y的数据是byte中连续的，u的数据是v向左移以为生成的，两者都是偶数位为有效数据</span></span><br><span class="line">                <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[buffer.capacity()];</span><br><span class="line">                buffer.get(bytes);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> srcIndex = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//直接取出来所有Y的有效区域，也可以存储成一个临时的bytes，到下一步再copy</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; height; j++) &#123;</span><br><span class="line">                        System.arraycopy(bytes, srcIndex, yBytes, dstIndex, width);</span><br><span class="line">                        srcIndex += rowStride;</span><br><span class="line">                        dstIndex += width;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">//根据pixelsStride取相应的数据</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; height / <span class="number">2</span>; j++) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; width / <span class="number">2</span>; k++) &#123;</span><br><span class="line">                            uBytes[uIndex++] = bytes[srcIndex];</span><br><span class="line">                            srcIndex += pixelsStride;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (pixelsStride == <span class="number">2</span>) &#123;</span><br><span class="line">                            srcIndex += rowStride - width;</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pixelsStride == <span class="number">1</span>) &#123;</span><br><span class="line">                            srcIndex += rowStride - width / <span class="number">2</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="comment">//根据pixelsStride取相应的数据</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; height / <span class="number">2</span>; j++) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; width / <span class="number">2</span>; k++) &#123;</span><br><span class="line">                            vBytes[vIndex++] = bytes[srcIndex];</span><br><span class="line">                            srcIndex += pixelsStride;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (pixelsStride == <span class="number">2</span>) &#123;</span><br><span class="line">                            srcIndex += rowStride - width;</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pixelsStride == <span class="number">1</span>) &#123;</span><br><span class="line">                            srcIndex += rowStride - width / <span class="number">2</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将YUV数据交给C层去处理。</span></span><br><span class="line">            FFmpegHandler.getInstance().pushCameraData(yBytes, yBytes.length, uBytes, uBytes.length, vBytes, vBytes.length);</span><br><span class="line">            image.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><h2 id="3、初始化FFmpeg"><a href="#3、初始化FFmpeg" class="headerlink" title="3、初始化FFmpeg"></a>3、初始化FFmpeg</h2><p>直播推送的过程整体就是一个先将视频数据编码，再将编码后的数据写入数据流中推送给服务器的过程。</p><p>下面初始化的过程就是准备好数据编码器和一条已经连上服务器的数据流</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT jint JNICALL Java_com_david_camerapush_ffmpeg_FFmpegHandler_init</span><br><span class="line">        (JNIEnv *jniEnv, jobject instance, jstring url) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *out_url = (*jniEnv)-&gt;GetStringUTFChars(jniEnv, url, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算yuv数据的长度</span></span><br><span class="line">    yuv_width = width;</span><br><span class="line">    yuv_height = height;</span><br><span class="line">    y_length = width * height;</span><br><span class="line">    uv_length = width * height / <span class="number">4</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//output initialize</span></span><br><span class="line">    <span class="keyword">int</span> ret = avformat_alloc_output_context2(&amp;ofmt_ctx, <span class="literal">NULL</span>, <span class="string">"flv"</span>, out_url);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"avformat_alloc_output_context2 error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化H264编码器</span></span><br><span class="line">    pCodec = avcodec_find_encoder(AV_CODEC_ID_H264);</span><br><span class="line">    <span class="keyword">if</span> (!pCodec) &#123;</span><br><span class="line">        LOGE(<span class="string">"Can not find encoder!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pCodecCtx = avcodec_alloc_context3(pCodec);</span><br><span class="line">    <span class="comment">//编码器的ID号，这里为264编码器</span></span><br><span class="line">    pCodecCtx-&gt;codec_id = pCodec-&gt;id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//像素的格式，也就是说采用什么样的色彩空间来表明一个像素点，这里使用YUV420P</span></span><br><span class="line">    pCodecCtx-&gt;pix_fmt = AV_PIX_FMT_YUV420P;</span><br><span class="line">    <span class="comment">//编码器编码的数据类型</span></span><br><span class="line">    pCodecCtx-&gt;codec_type = AVMEDIA_TYPE_VIDEO;</span><br><span class="line">    <span class="comment">//编码目标的视频帧大小，以像素为单位</span></span><br><span class="line">    pCodecCtx-&gt;width = width;</span><br><span class="line">    pCodecCtx-&gt;height = height;</span><br><span class="line">    <span class="comment">//帧频</span></span><br><span class="line">    pCodecCtx-&gt;framerate = (AVRational) &#123;<span class="number">15</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="comment">//时间基</span></span><br><span class="line">    pCodecCtx-&gt;time_base = (AVRational) &#123;<span class="number">1</span>, <span class="number">15</span>&#125;;</span><br><span class="line">    <span class="comment">//目标的码率，即采样的码率；显然，采样码率越大，视频大小越大</span></span><br><span class="line">    pCodecCtx-&gt;bit_rate = <span class="number">400000</span>;</span><br><span class="line">    pCodecCtx-&gt;gop_size = <span class="number">50</span>;</span><br><span class="line">    <span class="comment">/* Some formats want stream headers to be separate. */</span></span><br><span class="line">    <span class="keyword">if</span> (ofmt_ctx-&gt;oformat-&gt;flags &amp; AVFMT_GLOBALHEADER)</span><br><span class="line">        pCodecCtx-&gt;flags |= AV_CODEC_FLAG_GLOBAL_HEADER;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//H264 codec param</span></span><br><span class="line">    pCodecCtx-&gt;qcompress = <span class="number">0.6</span>;</span><br><span class="line">    <span class="comment">//最大和最小量化系数</span></span><br><span class="line">    pCodecCtx-&gt;qmin = <span class="number">10</span>;</span><br><span class="line">    pCodecCtx-&gt;qmax = <span class="number">51</span>;</span><br><span class="line">    <span class="comment">//Optional Param</span></span><br><span class="line">    <span class="comment">//两个非B帧之间允许出现多少个B帧数</span></span><br><span class="line">    <span class="comment">//设置0表示不使用B帧，b 帧越多，图片越小</span></span><br><span class="line">    pCodecCtx-&gt;max_b_frames = <span class="number">0</span>;</span><br><span class="line">    AVDictionary *param = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//H.264</span></span><br><span class="line">    <span class="keyword">if</span> (pCodecCtx-&gt;codec_id == AV_CODEC_ID_H264) &#123;</span><br><span class="line">        av_dict_set(&amp;param, <span class="string">"preset"</span>, <span class="string">"superfast"</span>, <span class="number">0</span>); <span class="comment">//x264编码速度的选项</span></span><br><span class="line">        av_dict_set(&amp;param, <span class="string">"tune"</span>, <span class="string">"zerolatency"</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开编码器</span></span><br><span class="line">    <span class="keyword">if</span> (avcodec_open2(pCodecCtx, pCodec, &amp;param) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"Failed to open encoder!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新建传输流，即将要直播的视频流</span></span><br><span class="line">    video_st = avformat_new_stream(ofmt_ctx, pCodec);</span><br><span class="line">    <span class="keyword">if</span> (video_st == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    video_st-&gt;time_base = (AVRational) &#123;<span class="number">25</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    video_st-&gt;codecpar-&gt;codec_tag = <span class="number">0</span>;</span><br><span class="line">    avcodec_parameters_from_context(video_st-&gt;codecpar, pCodecCtx);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打开数据流，表示与rtmp服务器连接</span></span><br><span class="line">    <span class="keyword">int</span> err = avio_open(&amp;ofmt_ctx-&gt;pb, out_url, AVIO_FLAG_READ_WRITE);</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"Failed to open output：%s"</span>, av_err2str(err));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Write File Header</span></span><br><span class="line">    avformat_write_header(ofmt_ctx, <span class="literal">NULL</span>);</span><br><span class="line">    av_init_packet(&amp;enc_pkt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、开始传输"><a href="#4、开始传输" class="headerlink" title="4、开始传输"></a>4、开始传输</h2><p>对YUV数据编码，并将编码后数据写入准备好的直播流中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT jint JNICALL Java_com_david_camerapush_ffmpeg_FFmpegHandler_pushCameraData</span><br><span class="line">        (JNIEnv *jniEnv, jobject instance, jbyteArray yArray, jint yLen, jbyteArray uArray, jint uLen, jbyteArray vArray, jint vLen) &#123;</span><br><span class="line">    jbyte *yin = (*jniEnv)-&gt;GetByteArrayElements(jniEnv, yArray, <span class="literal">NULL</span>);</span><br><span class="line">    jbyte *uin = (*jniEnv)-&gt;GetByteArrayElements(jniEnv, uArray, <span class="literal">NULL</span>);</span><br><span class="line">    jbyte *vin = (*jniEnv)-&gt;GetByteArrayElements(jniEnv, vArray, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 初始化Frame</span></span><br><span class="line">    pFrameYUV = av_frame_alloc();</span><br><span class="line">    <span class="comment">// 通过指定像素格式、图像宽、图像高来计算所需的内存大小</span></span><br><span class="line">    <span class="keyword">int</span> picture_size = av_image_get_buffer_size(pCodecCtx-&gt;pix_fmt, pCodecCtx-&gt;width,pCodecCtx-&gt;height, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//分配指定大小的内存空间</span></span><br><span class="line">    <span class="keyword">uint8_t</span> *buffers = (<span class="keyword">uint8_t</span> *) av_malloc(picture_size);</span><br><span class="line">    <span class="comment">//此函数类似于格式化已经申请的内存，即通过av_malloc()函数申请的内存空间。</span></span><br><span class="line">    av_image_fill_arrays(pFrameYUV-&gt;data, pFrameYUV-&gt;linesize, buffers, pCodecCtx-&gt;pix_fmt,pCodecCtx-&gt;width, pCodecCtx-&gt;height, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Frame中数据填充</span></span><br><span class="line">    <span class="built_in">memcpy</span>(pFrameYUV-&gt;data[<span class="number">0</span>], yin, (<span class="keyword">size_t</span>) yLen); <span class="comment">//Y</span></span><br><span class="line">    <span class="built_in">memcpy</span>(pFrameYUV-&gt;data[<span class="number">1</span>], uin, (<span class="keyword">size_t</span>) uLen); <span class="comment">//U</span></span><br><span class="line">    <span class="built_in">memcpy</span>(pFrameYUV-&gt;data[<span class="number">2</span>], vin, (<span class="keyword">size_t</span>) vLen); <span class="comment">//V</span></span><br><span class="line">    pFrameYUV-&gt;pts = count;</span><br><span class="line">    pFrameYUV-&gt;format = AV_PIX_FMT_YUV420P;</span><br><span class="line">    pFrameYUV-&gt;width = yuv_width;</span><br><span class="line">    pFrameYUV-&gt;height = yuv_height;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化AVPacket</span></span><br><span class="line">    enc_pkt.data = <span class="literal">NULL</span>;</span><br><span class="line">    enc_pkt.size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始编码YUV数据</span></span><br><span class="line">    ret = avcodec_send_frame(pCodecCtx, pFrameYUV);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"avcodec_send_frame error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取编码后的H264数据</span></span><br><span class="line">    ret = avcodec_receive_packet(pCodecCtx, &amp;enc_pkt);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span> || enc_pkt.size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"avcodec_receive_packet error %s"</span>, av_err2str(ret));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    enc_pkt.stream_index = video_st-&gt;index;</span><br><span class="line">    enc_pkt.pts = count * (video_st-&gt;time_base.den) / ((video_st-&gt;time_base.num) * fps);</span><br><span class="line">    enc_pkt.dts = enc_pkt.pts;</span><br><span class="line">    enc_pkt.duration = (video_st-&gt;time_base.den) / ((video_st-&gt;time_base.num) * fps);</span><br><span class="line">    enc_pkt.pos = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往直播流写数据</span></span><br><span class="line">    ret = av_interleaved_write_frame(ofmt_ctx, &amp;enc_pkt);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"av_interleaved_write_frame failed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    count++;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//释放内存，Java写多了经常会忘记这块**</span></span><br><span class="line">    av_packet_unref(&amp;enc_pkt);</span><br><span class="line">    av_frame_free(&amp;pFrameYUV);</span><br><span class="line">    av_free(buffers);</span><br><span class="line">    (*jniEnv)-&gt;ReleaseByteArrayElements(jniEnv, yArray, yin, <span class="number">0</span>);</span><br><span class="line">    (*jniEnv)-&gt;ReleaseByteArrayElements(jniEnv, uArray, uin, <span class="number">0</span>);</span><br><span class="line">    (*jniEnv)-&gt;ReleaseByteArrayElements(jniEnv, vArray, vin, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><img src="/2019/01/07/Android音视频-四-FFmpeg-Camera2推流直播/push.jpg" alt=""></p><p>这是Demo运行后的结果，推送视频OK，但是可能会有2到3秒的延迟（可能也跟网速有关）。目前就做到这种程度，后面会优化延迟、音频直播、音视频同步等都会慢慢加上去。</p><p><a href="https://github.com/David1840/CameraPush" target="_blank" rel="noopener">Github源码 — CameraPush</a></p><p><strong>Tips:</strong></p><p><a href="https://david1840.github.io/2018/11/23/FFmpeg%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/" target="_blank" rel="noopener">Mac 下搭建RTMP直播</a></p><p>图片中使用的在Windows下的<a href="https://github.com/illuspas/nginx-rtmp-win32" target="_blank" rel="noopener">nginx-rtmp-win32</a>，不需要编译，点击exe就可以运行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://david1840.github.io/2019/01/04/Android%E9%9F%B3%E8%A7%86%E9%A2%91-%E4%B8%80-Camera2-API%E9%87%87%E9%9B%86%E6%95%B0%E6%8D
      
    
    </summary>
    
      <category term="Android音视频" scheme="http://yoursite.com/categories/Android%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="Camera2" scheme="http://yoursite.com/tags/Camera2/"/>
    
      <category term="FFmpeg" scheme="http://yoursite.com/tags/FFmpeg/"/>
    
      <category term="直播" scheme="http://yoursite.com/tags/%E7%9B%B4%E6%92%AD/"/>
    
  </entry>
  
  <entry>
    <title>Android音视频(二)音频AudioRecord和AudioTrack</title>
    <link href="http://yoursite.com/2019/01/06/Android%E9%9F%B3%E8%A7%86%E9%A2%91-%E4%BA%8C-%E9%9F%B3%E9%A2%91AudioRecord%E5%92%8CAudioTrack/"/>
    <id>http://yoursite.com/2019/01/06/Android音视频-二-音频AudioRecord和AudioTrack/</id>
    <published>2019-01-06T03:19:43.000Z</published>
    <updated>2019-01-07T06:22:38.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://david1840.github.io/2019/01/04/Android%E9%9F%B3%E8%A7%86%E9%A2%91-%E4%B8%80-Camera2-API%E9%87%87%E9%9B%86%E6%95%B0%E6%8D%AE/" target="_blank" rel="noopener">Android音视频(一) Camera2 API采集数据</a></p><p>AudioRecord和AudioTrack是Android系统提供的用于实现录音、播放音频的功能类，使用这两个类做音频的采集与播放还是非常简单的。</p><h2 id="AudioRecord"><a href="#AudioRecord" class="headerlink" title="AudioRecord"></a>AudioRecord</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startRecorder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1、输出pcm文件</span></span><br><span class="line">            mAudioFile = <span class="keyword">new</span> File(Environment.getExternalStorageDirectory().getAbsolutePath() + <span class="string">"/RecorderTest/"</span> +</span><br><span class="line">                    System.currentTimeMillis() + <span class="string">".pcm"</span>);</span><br><span class="line">            mAudioFile.getParentFile().mkdirs();</span><br><span class="line">            mAudioFile.createNewFile();</span><br><span class="line">            mFileOutputStream = <span class="keyword">new</span> FileOutputStream(mAudioFile);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2、配置AudioRecord</span></span><br><span class="line">              <span class="comment">// 声音来源</span></span><br><span class="line">            <span class="keyword">int</span> audioSource = MediaRecorder.AudioSource.MIC;</span><br><span class="line">              <span class="comment">// 采样率 Hz</span></span><br><span class="line">            <span class="keyword">int</span> sampleRate = <span class="number">44100</span>;</span><br><span class="line">              <span class="comment">// 音频通道的配置 MONO 单声道</span></span><br><span class="line">            <span class="keyword">int</span> channelConfig = AudioFormat.CHANNEL_IN_MONO;</span><br><span class="line">              <span class="comment">// 返回音频数据的格式 </span></span><br><span class="line">            <span class="keyword">int</span> audioFormat = AudioFormat.ENCODING_PCM_16BIT;</span><br><span class="line">              <span class="comment">//AudioRecord能接受的最小的buffer大小</span></span><br><span class="line">            <span class="keyword">int</span> minBufferSize = AudioRecord.getMinBufferSize(sampleRate, channelConfig, audioFormat);</span><br><span class="line">            mAudioRecorder = <span class="keyword">new</span> AudioRecord(audioSource, sampleRate, channelConfig,</span><br><span class="line">                    audioFormat, Math.max(minBufferSize, <span class="number">2048</span>));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 3、开始录音</span></span><br><span class="line">            mAudioRecorder.startRecording();</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 4、一边从AudioRecord中读取声音数据到初始化的buffer，一边将buffer中数据导入数据流，写入文件中</span></span><br><span class="line">            <span class="keyword">while</span> (mIsRecording) &#123; <span class="comment">// 标志位，是否停止录音</span></span><br><span class="line">                <span class="keyword">int</span> read = mAudioRecorder.read(mBuffer, <span class="number">0</span>, <span class="number">2048</span>);</span><br><span class="line">                <span class="keyword">if</span> (read &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    mFileOutputStream.write(mBuffer, <span class="number">0</span>, read);</span><br><span class="line">                    <span class="comment">// 也可以在这里对音频数据进行处理，压缩、直播等</span></span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 5、停止录音，释放资源</span></span><br><span class="line">            mAudioRecorder.stop();</span><br><span class="line">            mAudioRecorder.release();</span><br><span class="line">            mAudioRecorder = <span class="keyword">null</span>;</span><br><span class="line">            mFileOutputStream.close();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | RuntimeException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mAudioRecorder != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mAudioRecorder.release();</span><br><span class="line">                mAudioRecorder = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="MediaRecorder-和-AudioRecord"><a href="#MediaRecorder-和-AudioRecord" class="headerlink" title="MediaRecorder 和 AudioRecord"></a>MediaRecorder 和 AudioRecord</h3><p>Android SDK 中有两套音频采集的API，分别是：MediaRecorder 和 AudioRecord。</p><ol><li><p>MediaRecorder是一个更加上层一点的API，它可以直接把手机麦克风录入的音频数据进行编码压缩（如AMR、MP3等）并存成文件</p></li><li><p>AudioRecord则更接近底层，能够更加自由灵活地控制，可以得到原始的一帧帧PCM音频数据。</p></li></ol><p>如果只是想简单地做一个录音机，录制音频文件，就使用 MediaRecorder，而如果需要对音频做进一步的算法处理、或者采用第三方的编码库进行压缩、以及网络传输、直播等应用，则建议使用 AudioRecord。</p><h2 id="AudioTrack"><a href="#AudioTrack" class="headerlink" title="AudioTrack"></a>AudioTrack</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doPaly</span><span class="params">(File mAudioFile)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 音频流的类型</span></span><br><span class="line">        <span class="comment">// STREAM_ALARM：警告声 </span></span><br><span class="line">        <span class="comment">// STREAM_MUSIC：音乐声</span></span><br><span class="line">        <span class="comment">// STREAM_RING：铃声</span></span><br><span class="line">        <span class="comment">// STREAM_SYSTEM：系统声音，例如低电提示音，锁屏音等</span></span><br><span class="line">        <span class="comment">// STREAM_VOCIE_CALL：通话声</span></span><br><span class="line">        <span class="keyword">int</span> streamType = AudioManager.STREAM_MUSIC;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 采样率 Hz</span></span><br><span class="line">        <span class="keyword">int</span> sampleRate = <span class="number">44100</span>;</span><br><span class="line">        <span class="comment">// 单声道</span></span><br><span class="line">        <span class="keyword">int</span> channelConfig = AudioFormat.CHANNEL_OUT_MONO;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 音频数据表示的格式</span></span><br><span class="line">        <span class="keyword">int</span> audioFormat = AudioFormat.ENCODING_PCM_16BIT;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// MODE_STREAM：在这种模式下，通过write一次次把音频数据写到AudioTrack中。这和平时通过</span></span><br><span class="line">        <span class="comment">// write系统调用往文件中写数据类似，但这种工作方式每次都需要把数据从用户提供的Buffer中拷贝到</span></span><br><span class="line">        <span class="comment">// AudioTrack内部的Buffer中，这在一定程度上会使引入延时。为解决这一问题，AudioTrack就引入</span></span><br><span class="line">        <span class="comment">// 了第二种模式。</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">// MODE_STATIC：这种模式下，在play之前只需要把所有数据通过一次write调用传递到AudioTrack</span></span><br><span class="line">        <span class="comment">// 中的内部缓冲区，后续就不必再传递数据了。这种模式适用于像铃声这种内存占用量较小，延时要求较</span></span><br><span class="line">        <span class="comment">// 高的文件。但它也有一个缺点，就是一次write的数据不能太多，否则系统无法分配足够的内存来存储</span></span><br><span class="line">        <span class="comment">// 全部数据。</span></span><br><span class="line">        <span class="keyword">int</span> mode = AudioTrack.MODE_STREAM;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> minBufferSize = AudioTrack.getMinBufferSize(sampleRate, channelConfig, audioFormat);</span><br><span class="line"></span><br><span class="line">        AudioTrack audioTrack = <span class="keyword">new</span> AudioTrack(streamType, sampleRate, channelConfig, audioFormat, Math.max(minBufferSize, <span class="number">2048</span>), mode);</span><br><span class="line"></span><br><span class="line">        FileInputStream mFileInputStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mFileInputStream = <span class="keyword">new</span> FileInputStream(mAudioFile);</span><br><span class="line">            <span class="keyword">int</span> read;</span><br><span class="line">            audioTrack.play();</span><br><span class="line">            <span class="keyword">while</span> ((read = mFileInputStream.read(mBuffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> ret = audioTrack.write(mBuffer, <span class="number">0</span>, read);</span><br><span class="line">                <span class="keyword">switch</span> (ret) &#123;</span><br><span class="line">                    <span class="keyword">case</span> AudioTrack.ERROR_BAD_VALUE:</span><br><span class="line">                    <span class="keyword">case</span> AudioTrack.ERROR_INVALID_OPERATION:</span><br><span class="line">                    <span class="keyword">case</span> AudioManager.ERROR_DEAD_OBJECT:</span><br><span class="line">                        palyFaile();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            palyFaile();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mIsPalying = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (mFileInputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">                closeQuietly(mFileInputStream);</span><br><span class="line">            &#125;</span><br><span class="line">            audioTrack.stop();</span><br><span class="line">            audioTrack.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="AudioTrack-与-MediaPlayer"><a href="#AudioTrack-与-MediaPlayer" class="headerlink" title="AudioTrack 与 MediaPlayer"></a>AudioTrack 与 MediaPlayer</h3><p>在Android中播放声音也是有两套API：MediaPlayer和AudioTrack，两者还是有很大的区别的。</p><ol><li><p>MediaPlayer可以播放多种格式的声音文件，例如MP3，AAC，WAV，OGG，MIDI等。MediaPlayer会在framework层创建对应的音频解码器。</p></li><li><p>AudioTrack只能播放已经解码的PCM流，如不需要解码的wav文件。</p></li></ol><p>MediaPlayer在framework层还是会创建AudioTrack，把解码后的PCM数流传递给AudioTrack，AudioTrack再传递给AudioFlinger进行混音，然后才传递给硬件播放,所以是MediaPlayer包含了AudioTrack。</p><p><a href="https://github.com/David1840/AudioDemo" target="_blank" rel="noopener">Demo</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://david1840.github.io/2019/01/04/Android%E9%9F%B3%E8%A7%86%E9%A2%91-%E4%B8%80-Camera2-API%E9%87%87%E9%9B%86%E6%95%B0%E6%8D
      
    
    </summary>
    
      <category term="Android音视频" scheme="http://yoursite.com/categories/Android%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="音频" scheme="http://yoursite.com/tags/%E9%9F%B3%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>写给安卓程序员的C/C++编译入门(交叉编译，Makefile)</title>
    <link href="http://yoursite.com/2019/01/05/%E5%AE%89%E5%8D%93%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%92%8CMakefile%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2019/01/05/安卓程序员需要知道的交叉编译和Makefile知识/</id>
    <published>2019-01-05T07:54:16.000Z</published>
    <updated>2019-01-03T06:35:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近一直在和Linux C开发打交道，开发过程中会用到交叉编译和Makefile相关知识，但是对这块真的是没有了解，所以在网上搜索，找到一篇不错的博客。本文转载自该博客<a href="https://www.jianshu.com/p/3ba79f1ade39" target="_blank" rel="noopener">写给安卓程序员的C/C++编译入门(作者：嘉伟咯)</a>。如有侵权请联系删除。</p><h2 id="为什么要学C-C-编译"><a href="#为什么要学C-C-编译" class="headerlink" title="为什么要学C/C++编译"></a>为什么要学C/C++编译</h2><p>很多的安卓程序员可能都会用Android Studio写一些简单的C/C++代码,然后通过jni去调用,但是对C/C++是如何编译的其实并没有什么概念.有人可能会问,为什么安卓程序员会需要了解C/C++是如何编译的呢?</p><p>我一直都认为,要成为一个真正的高级安卓应用开发工程师,安卓源码和C/C++是两座绕不过的大山.安卓源码自然不必多说,而C/C++流行了几十年,存在着许多优秀的开源项目,我们在处理一些特定的需求的时候,可能会需要使用到它们.如脚本语言Lua,计算机视觉库OpenCV,音视频编解码库ffmpeg,谷歌的gRPC,国产游戏引擎Cocos2dx…有些库提供了完整的安卓接口,有些提供了部分安卓接口,有些则没有.在做一些高级功能时,我们常常需要使用源码,通过裁剪和交叉编译,才能编译出可以在安卓上使用的so库.总之,安卓做深做精总避不开C/C++交叉编译。</p><h2 id="C-C-编译器"><a href="#C-C-编译器" class="headerlink" title="C/C++编译器"></a>C/C++编译器</h2><p>类似java编译器javac可以将java代码编译成class文件,C/C++也有gcc、g++、clang等多种编译器可以用于编译C/C++代码.这里我们用gcc来举例。</p><p>gcc原名为GNU C 语言编译器(GNU C Compiler),因为它原本只能处理C语言.但GCC很快地扩展,变得可处理C++。后来又扩展能够支持更多编程语言,如Fortran、Pascal、Objective-C、Java、Ada、Go以及各类处理器架构上的汇编语言等,所以改名GNU编译器套件(GNU Compiler Collection)。</p><p>使用gcc其实只需要一个命令就能将一个c文件编译成可运行程序了:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c -o test</span><br></pre></td></tr></table></figure><p>通过上面这条命令可以将test.c编译成可运行程序test.但是其实C/C++的编译是经过了好几个步骤的,我这边先给大家大概的讲一讲。</p><h3 id="C-C-的编译流程"><a href="#C-C-的编译流程" class="headerlink" title="C/C++的编译流程"></a>C/C++的编译流程</h3><p>C/C++的编译可以分为下面几个步骤:</p><p><img src="/2019/01/05/安卓程序员需要知道的交叉编译和Makefile知识/c-c++.png" alt=""></p><h4 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h4><p>相信学过C/C++的同学都知道”宏”这个东西,它在编译的时候会被展开替换成实际的代码,这个展开的步骤就是在预处理的时候进行的.当然,预处理并不仅仅只是做宏的展开,它还做了类似头文件插入、删除注释等操作.</p><p>预处理之后的产品依然还是C/C++代码,它在代码的逻辑上和输入的C/C++源代码是完全一样的.</p><p>我们来举一个简单的例子,写一个test.h文件和一个test.c文件:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TEST_H            </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> A 1     </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> B 2        </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * add 方法的声明</span></span><br><span class="line"><span class="comment"> */</span>               </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"test.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * add 方法定义</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    add(A, B);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后可以通过下面这个gcc命令预处理test.c文件,并且把预处理结果写到test.i:</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -<span class="keyword">E</span> <span class="keyword">test</span>.c -o <span class="keyword">test</span>.<span class="built_in">i</span></span><br></pre></td></tr></table></figure><p>然后就能看到预处理之后的test.c到底长什么样子了:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到这里它把test.h的内容(add方法的声明)插入到了test.c的代码中,然后将A、B两个宏展开成了1和2,将注释去掉了,还在头部加上了一些信息.但是光看代码逻辑,和之前我们写的代码是完全一样的.</p><h4 id="汇编代码"><a href="#汇编代码" class="headerlink" title="汇编代码"></a>汇编代码</h4><p>可能大家都听过汇编语言这个东西,但是年轻一点的同学不一定真正见过.简单来说汇编语言是将机器语言符号化了的语言,是机器不能直接识别的低级语言.我们可以通过下面的命令,将预处理后的代码编译成汇编语言:</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S <span class="keyword">test</span>.i -o <span class="keyword">test</span>.<span class="built_in">s</span></span><br></pre></td></tr></table></figure><p>然后就能看到生成的test.s文件了,里面就是我们写的c语言代码翻译而成的汇编代码:</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">.file   <span class="string">"test.c"</span></span><br><span class="line">        .text</span><br><span class="line">        .globl  <span class="keyword">add</span></span><br><span class="line">        .<span class="keyword">type</span>   <span class="keyword">add</span>, <span class="title">@function</span></span><br><span class="line"><span class="keyword">add</span>:</span><br><span class="line">.LFB<span class="number">0</span>:</span><br><span class="line">        .cfi_startproc</span><br><span class="line">        pushq   <span class="symbol">%rbp</span></span><br><span class="line">        .cfi_def_cfa_offset <span class="number">16</span></span><br><span class="line">        .cfi_offset <span class="number">6</span>, <span class="number">-16</span></span><br><span class="line">        movq    <span class="symbol">%rsp</span>, <span class="symbol">%rbp</span></span><br><span class="line">        .cfi_def_cfa_register <span class="number">6</span></span><br><span class="line">        movl    <span class="symbol">%edi</span>, <span class="number">-4</span>(<span class="symbol">%rbp</span>)</span><br><span class="line">        movl    <span class="symbol">%esi</span>, <span class="number">-8</span>(<span class="symbol">%rbp</span>)</span><br><span class="line">        movl    <span class="number">-4</span>(<span class="symbol">%rbp</span>), <span class="symbol">%edx</span></span><br><span class="line">        movl    <span class="number">-8</span>(<span class="symbol">%rbp</span>), <span class="symbol">%eax</span></span><br><span class="line">        addl    <span class="symbol">%edx</span>, <span class="symbol">%eax</span></span><br><span class="line">        popq    <span class="symbol">%rbp</span></span><br><span class="line">        .cfi_def_cfa <span class="number">7</span>, <span class="number">8</span></span><br><span class="line">        <span class="keyword">ret</span></span><br><span class="line">        .cfi_endproc</span><br><span class="line">.LFE<span class="number">0</span>:</span><br><span class="line">        .size   <span class="keyword">add</span>, .-<span class="keyword">add</span></span><br><span class="line">        .globl  main</span><br><span class="line">        .<span class="keyword">type</span>   main, <span class="title">@function</span></span><br><span class="line">main:</span><br><span class="line">.LFB<span class="number">1</span>:</span><br><span class="line">        .cfi_startproc</span><br><span class="line">        pushq   <span class="symbol">%rbp</span></span><br><span class="line">        .cfi_def_cfa_offset <span class="number">16</span></span><br><span class="line">        .cfi_offset <span class="number">6</span>, <span class="number">-16</span></span><br><span class="line">        movq    <span class="symbol">%rsp</span>, <span class="symbol">%rbp</span></span><br><span class="line">        .cfi_def_cfa_register <span class="number">6</span></span><br><span class="line">        subq    $<span class="number">16</span>, <span class="symbol">%rsp</span></span><br><span class="line">        movl    <span class="symbol">%edi</span>, <span class="number">-4</span>(<span class="symbol">%rbp</span>)</span><br><span class="line">        movq    <span class="symbol">%rsi</span>, <span class="number">-16</span>(<span class="symbol">%rbp</span>)</span><br><span class="line">        movl    $<span class="number">2</span>, <span class="symbol">%esi</span></span><br><span class="line">        movl    $<span class="number">1</span>, <span class="symbol">%edi</span></span><br><span class="line">        <span class="keyword">call</span>    <span class="keyword">add</span></span><br><span class="line">        movl    $<span class="number">0</span>, <span class="symbol">%eax</span></span><br><span class="line">        leave</span><br><span class="line">        .cfi_def_cfa <span class="number">7</span>, <span class="number">8</span></span><br><span class="line">        <span class="keyword">ret</span></span><br><span class="line">        .cfi_endproc</span><br><span class="line">.LFE<span class="number">1</span>:</span><br><span class="line">        .size   main, .-main</span><br><span class="line">        .ident  <span class="string">"GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.10) 5.4.0 20160609"</span></span><br><span class="line">        .<span class="keyword">section</span>        .note.GNU-stack,<span class="string">""</span>,<span class="title">@progbits</span></span><br></pre></td></tr></table></figure><h4 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h4><p>汇编这一步是将汇编代码编译成机器语言:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c <span class="keyword">test</span>.s -o <span class="keyword">test</span>.o</span><br></pre></td></tr></table></figure><p>生成的test.o文件里面就是机器代码了,我们可以通过nm命令来列出test.o里面的符号:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nm <span class="keyword">test</span>.o</span><br></pre></td></tr></table></figure><p>得到的结果如下:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">0000000000000000 </span>T add</span><br><span class="line"><span class="symbol">0000000000000014 </span>T main</span><br></pre></td></tr></table></figure><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p>由于我们的例子代码比较简单只有一个test.h和test.h,所以只生成了一个.o文件,其实一般的程序都是由多个模块组合成的.链接这一步就是将多个模块的代码组合成一个可执行程序.我们可以用gcc命令将多个.o文件或者静态库、动态库链接成一个可执行文件:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc <span class="keyword">test</span>.o -o <span class="keyword">test</span></span><br></pre></td></tr></table></figure><p>得到的就是可执行文件test了,可以直接用下面命令运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./<span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>当然是没有任何输出的,因为我们就没有做任何的打印</p><h2 id="编译so库"><a href="#编译so库" class="headerlink" title="编译so库"></a>编译so库</h2><p>在安卓中我们一般不会直接使用C/C++编译出来的可运行文件.用的更多的应该是so库.那要如何编译so库呢?</p><p>首先我们需要将test.c中的main函数去掉,因为so库中是不会带有main函数的:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"test.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * add 方法定义</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后可以使用下面命令将test.c编译成test.so:</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared <span class="keyword">test</span>.c -o <span class="keyword">test</span>.<span class="keyword">so</span></span><br></pre></td></tr></table></figure><p>其实也就是多了个-shared参数,指定编译的结果为动态链接库.</p><p>这里是直接将.c文件编译成so,当然也能像之前的例子一样先编译出.o文件再通过链接生成so文件.</p><p>当然一般编译动态链接库,我们还会带上-fPIC参数.</p><p>fPIC (Position-Independent Code)告诉编译器产生与位置无关代码,即产生的代码中没有绝对地址,全部使用相对地址.故而代码可以被加载器加载到内存的任意位置,都可以正确的执行.不加fPIC编译出来的so,是要再加载时根据加载到的位置再次重定位的.因为它里面的代码并不是位置无关代码.如果被多个应用程序共同使用,那么它们必须每个程序维护一份.so的代码副本了.因为.so被每个程序加载的位置都不同,显然这些重定位后的代码也不同,当然不能共享.</p><h2 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h2><p>通过上面的例子,我们知道了一个C/C++程序是怎么从源代码一步步编译成可运行程序或者so库的.但是我们编译出来的程序或者so库只能在相同系统的电脑上使用.</p><p>例如我使用的电脑是Linux系统的,那它编译出来的程序也就只能在Linux上运行,不能在安卓或者Windows上运行.</p><p>当然正常情况下不会有人专门去到android系统下编译出程序来给安卓去用.一般我们都是在PC上编译出安卓可用的程序,在给到安卓去跑的.这种是在一个平台上生成另一个平台上的可执行代码的编译方式就叫做交叉编译.</p><p>交叉编译有是三个比较重要的概念要先说明一下:</p><ul><li>build : 当前你使用的计算机</li><li>host : 你的目的是编译出来的程序可以在host上运行</li><li>target : 普通程序没有这个概念。对于想编译出编译器的人来说此属性决定了新编译器编译出的程序可以运行在哪</li></ul><p>如果我们想要交叉编译出安卓可运行的程序或者库的话就不能直接使用gcc去编译了.而需要使用Android NDK提供了的一套交叉编译工具链.</p><p>我们首先要下载Android NDK,然后配置好环境变量NDK_ROOT指向NDK的根目录.</p><p>然后可以通过下面命令安装交叉编译工具链:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$NDK_ROOT</span>/build/tools/make-standalone-toolchain.sh \</span><br><span class="line">    <span class="attribute">--platform</span>=android-19 \</span><br><span class="line">    <span class="attribute">--install-dir</span>=<span class="variable">$HOME</span>/Android/standalone-toolchains/android-toolchain-arm \</span><br><span class="line">    <span class="attribute">--toolchain</span>=arm-linux-androideabi-4.9 \</span><br><span class="line">    <span class="attribute">--stl</span>=gnustl</span><br></pre></td></tr></table></figure><p>然后我们就能在HOME/Android/目录下看到安装好的工具链了.进到HOME/Android/standalone-toolchains/android-toolchain-arm/bin/目录下我们可以看到有arm-linux-androideabi-gcc这个程序.</p><p>它就是gcc的安卓交叉编译版本.我们将之前使用gcc去编译的例子全部换成使用它去编译就能编译出运行在安卓上的程序了:</p><p>如下面命令生成的so库就能在安卓上通过jni调用了:</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$HOME</span>/Android/standalone-toolchains/android-toolchain-arm/bin/arm-linux-androideabi-gcc -shared -fPIC <span class="keyword">test</span>.c -o <span class="keyword">test</span>.<span class="keyword">so</span></span><br></pre></td></tr></table></figure><h3 id="不同CPU架构的编译方式"><a href="#不同CPU架构的编译方式" class="headerlink" title="不同CPU架构的编译方式"></a>不同CPU架构的编译方式</h3><p>当然安卓也有很多不同的CPU架构,不同CPU架构的程序也是不一定兼容的,相信大家之前在使用Android Studio去编译so的时候也有看到编译出来的库有很多个版本像armeabi、armeabi-v7a、mips、x86等.</p><p>那这些不同CPU架构的程序又要如何编译了.</p><p>我们可以在$NDK_ROOT/toolchains目录下看到者几个目录:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">arm-linux-androideabi-4</span><span class="selector-class">.9</span></span><br><span class="line"><span class="selector-tag">aarch64-linux-android-4</span><span class="selector-class">.9</span></span><br><span class="line"><span class="selector-tag">mipsel-linux-android-4</span><span class="selector-class">.9</span></span><br><span class="line"><span class="selector-tag">mips64el-linux-android-4</span><span class="selector-class">.9</span></span><br><span class="line"><span class="selector-tag">x86-4</span><span class="selector-class">.9</span></span><br><span class="line"><span class="selector-tag">x86_64-4</span><span class="selector-class">.9</span></span><br></pre></td></tr></table></figure><p>这就是不同CPU架构的交叉编译工具链了.还记得我们安装工具链的命令吗?</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$NDK_ROOT</span>/build/tools/make-standalone-toolchain.sh \</span><br><span class="line">    <span class="attribute">--platform</span>=android-19 \</span><br><span class="line">    <span class="attribute">--install-dir</span>=<span class="variable">$HOME</span>/Android/standalone-toolchains/android-toolchain-arm \</span><br><span class="line">    <span class="attribute">--toolchain</span>=arm-linux-androideabi-4.9 \</span><br><span class="line">    <span class="attribute">--stl</span>=gnust</span><br></pre></td></tr></table></figure><p>toolchain参数就能指定使用哪个工具链,然后就能使用该工具链去编译该架构版本的程序了.</p><p>但是,我们看到这下面并没有armeabi-v7a的工具链,那armeabi-v7a的程序要如何编译呢?</p><p>其实armeabi-v7a的程序也是用arm-linux-androideabi-4.9去编译的,只不过在编译的时候可以带上-march=armv7-a:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-linux-androideabi-gcc -march=armv7-<span class="selector-tag">a</span> -shared -fPIC test<span class="selector-class">.c</span> -o test.so</span><br></pre></td></tr></table></figure><h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><p>我们前面的例子都是直接用gcc或着各个交叉编译的版本的gcc去编译C/C++代码的.在代码量不多的时候这么做还是可行的,但是如果软件一旦复杂一些,代码量一多,那么编译的命令就会十分的复杂,而且还需要考虑到多个模块之间的依赖关系.</p><p>Makefile就是一个帮助我们解决这些问题的工具.它的基本原理十分简单,先让我们看看它最最基本的用法:</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">target <span class="string">...</span> : prerequisites <span class="string">...</span></span><br><span class="line"><span class="keyword">command</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure><p>target可以是一个object file(目标文件)，也可以是一个执行文件，还可以是一个标签（label）。</p><p>prerequisites就是，要生成那个target所需要的文件或是目标。</p><p>command也就是make需要执行的命令。（任意的shell命令）</p><p>这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在 command中。说白一点就是说，prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。这就是makefile的规则。也就是makefile中最核心的内容。</p><p>还是举我们的例子代码,首先创建一个文件,名字叫Makefile,然后写上:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test<span class="selector-class">.so</span> : test<span class="selector-class">.c</span> test<span class="selector-class">.h</span>                                                          </span><br><span class="line">    arm-linux-androideabi-gcc -march=armv7-<span class="selector-tag">a</span> -shared -fPIC test<span class="selector-class">.c</span> -o test.so</span><br><span class="line">clean :</span><br><span class="line">rm test.so</span><br></pre></td></tr></table></figure><p>然后就可以用make命令去编译了.make命令会找到当前目录下的Makefile,然后比较目标文件文件和依赖文件的修改时间,如果依赖文件的修改时间比较晚,或者干脆就还没有目标文件.就会执行命令.</p><p>clean不是一个文件，它只不过是一个动作名字，有点像c语言中的lable一样，其冒号后什么也没有，那么，make就不会自动去找它的依赖性，也就不会自动执行其后所定义的命令。要执行其后的命令（不仅用于clean，其他lable同样适用），就要在make命令后明显得指出这个lable的名字。这样的方法非常有用，我们可以在一个makefile中定义不用的编译或是和编译无关的命令，比如程序的打包，程序的备份，等等。</p><p>这只是比较简单的用法，具体的Makefile知识请查看<a href="http://wiki.ubuntu.org.cn/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile:MakeFile%E4%BB%8B%E7%BB%8D" target="_blank" rel="noopener">跟我一起写Makefile</a>.</p><h2 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h2><p>CMake是一种跨平台编译工具，比make更为高级，使用起来要方便得多。CMake主要是编写CMakeLists.txt文件，然后用cmake命令将CMakeLists.txt文件转化为make所需要的makefile文件，最后用make命令编译源码生成可执行程序或共享库（so(shared object)）。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">1</span><span class="selector-class">.cmake</span> verson，指定cmake版本 </span><br><span class="line"><span class="function"><span class="title">cmake_minimum_required</span><span class="params">(VERSION <span class="number">3.2</span>)</span></span></span><br><span class="line"></span><br><span class="line">#<span class="number">2</span><span class="selector-class">.project</span> name，指定项目的名称，一般和项目的文件夹名称对应</span><br><span class="line"><span class="function"><span class="title">project</span><span class="params">(myPro)</span></span></span><br><span class="line"></span><br><span class="line">#<span class="number">3</span><span class="selector-class">.head</span> file path，头文件目录</span><br><span class="line"><span class="function"><span class="title">include_directories</span><span class="params">(include)</span></span></span><br><span class="line"></span><br><span class="line">#<span class="number">4</span>.添加需要链接的库文件目录</span><br><span class="line"><span class="function"><span class="title">link_directories</span><span class="params">(include)</span></span></span><br><span class="line"></span><br><span class="line">#<span class="number">5</span><span class="selector-class">.source</span> directory，源文件目录</span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(src DIR_SRCS)</span></span></span><br><span class="line"></span><br><span class="line">#<span class="number">6</span><span class="selector-class">.set</span> environment variable，设置环境变量，编译用到的源文件全部都要放到这里，否则编译能够通过，但是执行的时候会出现各种问题，比如<span class="string">"symbol lookup error xxxxx , undefined symbol"</span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(TEST_MATH $&#123;DIR_SRCS&#125;)</span></span></span><br><span class="line"></span><br><span class="line">#<span class="number">7</span><span class="selector-class">.add</span> executable file，添加要编译的可执行文件</span><br><span class="line"><span class="function"><span class="title">add_executable</span><span class="params">($&#123;PROJECT_NAME&#125; $&#123;TEST_MATH&#125;)</span></span></span><br><span class="line"></span><br><span class="line">#<span class="number">8</span><span class="selector-class">.add</span> link library，添加可执行文件所需要的库，比如我们用到了libm.so（命名规则：lib+name+.so），就添加该库的名称</span><br><span class="line"><span class="function"><span class="title">target_link_libraries</span><span class="params">($&#123;PROJECT_NAME&#125; m)</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近一直在和Linux C开发打交道，开发过程中会用到交叉编译和Makefile相关知识，但是对这块真的是没有了解，所以在网上搜索，找到一篇不错的博客。本文转载自该博客&lt;a href=&quot;https://www.jianshu.com/p/3ba79f1ade39&quot; targ
      
    
    </summary>
    
      <category term="C/C++" scheme="http://yoursite.com/categories/C-C/"/>
    
    
      <category term="交叉编译" scheme="http://yoursite.com/tags/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/"/>
    
      <category term="Makefile" scheme="http://yoursite.com/tags/Makefile/"/>
    
  </entry>
  
  <entry>
    <title>Android音视频(一) Camera2 API采集数据</title>
    <link href="http://yoursite.com/2019/01/04/Android%E9%9F%B3%E8%A7%86%E9%A2%91-%E4%B8%80-Camera2-API%E9%87%87%E9%9B%86%E6%95%B0%E6%8D%AE/"/>
    <id>http://yoursite.com/2019/01/04/Android音视频-一-Camera2-API采集数据/</id>
    <published>2019-01-04T02:22:47.000Z</published>
    <updated>2019-01-07T06:22:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是Android音视频的第一篇文章，终于回到了我的老本行上，后面音视频开发会基于Android平台（关键我也不太会其他平台，后面会慢慢学习。。。）</p><p>之前好像从来没有做过Camera相关的开发，这块对我来说还是有点陌生，所以从头开始学起。</p><h2 id="Camera2"><a href="#Camera2" class="headerlink" title="Camera2"></a>Camera2</h2><p>在Android API21中Google发布了Camera2来取代原本的Camera，两者的变动也是比较大的。</p><p><img src="/2019/01/04/Android音视频-一-Camera2-API采集数据/camera2-1.png" alt=""></p><p>Camera2中Google采用了pipeline（管道）的概念，将Camera Device相机设备和Android Device安卓设备连接起来， Android Device通过管道发送CaptureRequest请求给Camera Device，Camera Device通过管道返回CameraMetadata数据给Android Device，这一切建立在一个叫作CameraCaptureSession的会话中。</p><h2 id="Camera2主要类说明"><a href="#Camera2主要类说明" class="headerlink" title="Camera2主要类说明"></a>Camera2主要类说明</h2><p>在Camera2 架构在核心参与类角色有：CameraManager、CameraDevice、CameraCharacteristics、CameraRequest与CameraRequest.Builder、CameraCaptureSession以及CaptureResult。</p><h3 id="CameraManager"><a href="#CameraManager" class="headerlink" title="CameraManager"></a>CameraManager</h3><p>位于android.hardware.camera2.CameraManager下，也是Android 21(5.0)添加的，和其他系统服务一样通过 <code>Context.getSystemService(Context.CAMERA_SERVICE)</code> 来完成初始化，主要用于管理系统摄像头。</p><ul><li><code>manager.getCameraIdList()</code> 获取Android设备的摄像头列表</li><li><code>manager.getCameraCharacteristics(cameraId)</code> 获取指定摄像头的相关特性</li><li><code>manager.openCamera(String cameraId, CameraDevice.StateCallback callback, Handler handler)</code> 打开指定Id的摄像头，StateCallback 是打开状态的一个监听回调，Handler 表示使用哪个线程处理回调，如果为null则表示当前线程。</li></ul><h3 id="CameraDevice"><a href="#CameraDevice" class="headerlink" title="CameraDevice"></a>CameraDevice</h3><p>CameraDevice是Camera2抽象出来的一个对象，直接与系统硬件摄像头相联系。</p><ul><li><p>通过CameraDevice.StateCallback监听摄像头的状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> CameraDevice.StateCallback mStateCallback = <span class="keyword">new</span> CameraDevice.StateCallback()&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOpened</span><span class="params">(@NonNull CameraDevice camera)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//摄像头打开，可以创建会话，开始预览</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDisconnected</span><span class="params">(@NonNull CameraDevice camera)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(@NonNull CameraDevice camera, <span class="keyword">int</span> error)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>管理CameraCaptureSession会话，相当于Android Device和Camera Device之间的管道，后面的数据交流都在这个会话中完成。</p></li><li><p>管理CaptureRequest，主要包括通过createCaptureRequest（int templateType）创建捕获请求，在需要预览、拍照、再次预览的时候都需要通过创建请求来完成。</p></li></ul><h3 id="CameraCaptureSession"><a href="#CameraCaptureSession" class="headerlink" title="CameraCaptureSession"></a>CameraCaptureSession</h3><p>正如前面所说，系统向摄像头发送 Capture 请求，而摄像头会返回 CameraMetadata，这一切都是在由对应的CameraDevice创建的CameraCaptureSession 会话完成，当程序需要预览、拍照、再次预览时，都需要先通过会话。CameraCaptureSession一旦被创建，直到对应的CameraDevice关闭才会死掉。虽然CameraCaptureSession会话用于从摄像头中捕获图像，但是只有同一个会话才能再次从同一摄像头中捕获图像。</p><ul><li>管理CameraCaptureSession.StateCallback状态回调，用于接收有关CameraCaptureSession状态的更新的回调对象，主要回调方法有两个当CameraDevice 完成配置，对应的会话开始处理捕获请求时触发onConfigured(CameraCaptureSession session)方法，反之配置失败时候触发onConfigureFailed(CameraCaptureSession session)方法。</li><li>管理CameraCaptureSession.CaptureCallback捕获回调，用于接收捕获请求状态的回调，当请求触发捕获已启动时、捕获完成时、在捕获图像时发生错误的情况下都会触发该回调对应的方法。</li><li>通过调用方法capture(CaptureRequest request, CameraCaptureSession.CaptureCallback listener, Handler handler)提交捕获图像请求，即拍照。</li><li>通过调用方法setRepeatingRequest(CaptureRequest request, CameraCaptureSession.CaptureCallback listener, Handler handler)请求不断重复捕获图像，即实现预览。</li><li>通过方法调用stopRepeating()实现停止捕获图像，即停止预览。</li></ul><h3 id="CameraCharacteristics"><a href="#CameraCharacteristics" class="headerlink" title="CameraCharacteristics"></a>CameraCharacteristics</h3><p>描述Cameradevice属性的对象，可以使用CameraManager通过getCameraCharacteristics（String cameraId）进行查询。</p><h3 id="CameraRequest与CameraRequest-Builder"><a href="#CameraRequest与CameraRequest-Builder" class="headerlink" title="CameraRequest与CameraRequest.Builder"></a>CameraRequest与CameraRequest.Builder</h3><p>CameraRequest代表了一次捕获请求</p><p>CameraRequest.Builder用于描述捕获图片的各种参数设置，包含捕获硬件（传感器，镜头，闪存），对焦模式、曝光模式，处理流水线，控制算法和输出缓冲区的配置，然后传递到对应的会话中进行设置。CameraRequest.Builder负责生成CameraRequest对象。</p><h3 id="CaptureResult"><a href="#CaptureResult" class="headerlink" title="CaptureResult"></a>CaptureResult</h3><p>CaptureRequest描述是从图像传感器捕获单个图像的结果的子集的对象。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>谷歌有写两个示例程序，介绍如何使用Camera2</p><p><a href="https://github.com/googlesamples/android-Camera2Basic" target="_blank" rel="noopener">android-Camera2Basic</a></p><p><a href="https://github.com/googlesamples/android-Camera2Video" target="_blank" rel="noopener">android-Camera2Video</a></p><p>示例程序中有预览、拍照、录像等功能，非常好的入门学习代码。</p><p>在这里还是过一遍整个流程，加深理解。</p><h3 id="1、打开摄像头"><a href="#1、打开摄像头" class="headerlink" title="1、打开摄像头"></a>1、打开摄像头</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">openCamera</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断权限</span></span><br><span class="line">        <span class="keyword">if</span> (ContextCompat.checkSelfPermission(getActivity(), Manifest.permission.CAMERA)</span><br><span class="line">                != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">            requestCameraPermission();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置参数，获取摄像头ID、设置预览宽高等</span></span><br><span class="line">        setUpCameraOutputs(width, height);</span><br><span class="line">        <span class="comment">// 配置TextureView的纹理转换，解决Camera显示变形问题</span></span><br><span class="line">        configureTransform(width, height);</span><br><span class="line">        Activity activity = getActivity();</span><br><span class="line">        CameraManager manager = (CameraManager) activity.getSystemService(Context.CAMERA_SERVICE);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//Semaphore 信号量，保证只能有一条线程使用Camera设备</span></span><br><span class="line">            <span class="keyword">if</span> (!mCameraOpenCloseLock.tryAcquire(<span class="number">2500</span>, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Time out waiting to lock camera opening."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//真正去打开摄像头，在mStateCallback中获取成功或失败的回调</span></span><br><span class="line">            manager.openCamera(mCameraId, mStateCallback, mBackgroundHandler); </span><br><span class="line">        &#125; <span class="keyword">catch</span> (CameraAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Interrupted while trying to lock camera opening."</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> CameraDevice.StateCallback mStateCallback = <span class="keyword">new</span> CameraDevice.StateCallback() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOpened</span><span class="params">(@NonNull CameraDevice cameraDevice)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// This method is called when the camera is opened.  We start camera preview here.</span></span><br><span class="line">            mCameraOpenCloseLock.release();</span><br><span class="line">            mCameraDevice = cameraDevice;</span><br><span class="line">            <span class="comment">//创建会话，开始预览</span></span><br><span class="line">            createCameraPreviewSession();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDisconnected</span><span class="params">(@NonNull CameraDevice cameraDevice)</span> </span>&#123;</span><br><span class="line">            mCameraOpenCloseLock.release();</span><br><span class="line">            cameraDevice.close();</span><br><span class="line">            mCameraDevice = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(@NonNull CameraDevice cameraDevice, <span class="keyword">int</span> error)</span> </span>&#123;</span><br><span class="line">            mCameraOpenCloseLock.release();</span><br><span class="line">            cameraDevice.close();</span><br><span class="line">            mCameraDevice = <span class="keyword">null</span>;</span><br><span class="line">            Activity activity = getActivity();</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != activity) &#123;</span><br><span class="line">                activity.finish();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><h3 id="2、创建会话，开始预览"><a href="#2、创建会话，开始预览" class="headerlink" title="2、创建会话，开始预览"></a>2、创建会话，开始预览</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createCameraPreviewSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        SurfaceTexture texture = mTextureView.getSurfaceTexture();</span><br><span class="line">        <span class="keyword">assert</span> texture != <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We configure the size of default buffer to be the size of camera preview we want.</span></span><br><span class="line">        texture.setDefaultBufferSize(mPreviewSize.getWidth(), mPreviewSize.getHeight());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This is the output Surface we need to start preview.</span></span><br><span class="line">        Surface surface = <span class="keyword">new</span> Surface(texture);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We set up a CaptureRequest.Builder with the output Surface.</span></span><br><span class="line">        mPreviewRequestBuilder</span><br><span class="line">                = mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);</span><br><span class="line">        <span class="comment">//这里是指实时图像数据的输出目标，以后录制视频、直播等都需要在这里添加对应的Target</span></span><br><span class="line">        mPreviewRequestBuilder.addTarget(surface);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Here, we create a CameraCaptureSession for camera preview.</span></span><br><span class="line">        mCameraDevice.createCaptureSession(Arrays.asList(surface, mImageReader.getSurface()),</span><br><span class="line">                <span class="keyword">new</span> CameraCaptureSession.StateCallback() &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConfigured</span><span class="params">(@NonNull CameraCaptureSession cameraCaptureSession)</span> </span>&#123;</span><br><span class="line">                        <span class="comment">// The camera is already closed</span></span><br><span class="line">                        <span class="keyword">if</span> (<span class="keyword">null</span> == mCameraDevice) &#123;</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// When the session is ready, we start displaying the preview.</span></span><br><span class="line">                        mCaptureSession = cameraCaptureSession;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">// 设置自动对焦</span></span><br><span class="line">                            mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AF_MODE,</span><br><span class="line">                                    CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE);</span><br><span class="line">                            <span class="comment">// Flash is automatically enabled when necessary.</span></span><br><span class="line">                            setAutoFlash(mPreviewRequestBuilder);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// Finally, we start displaying the camera preview.</span></span><br><span class="line">                            mPreviewRequest = mPreviewRequestBuilder.build();</span><br><span class="line">                            <span class="comment">//不断捕获图像，显示预览图像</span></span><br><span class="line">                            mCaptureSession.setRepeatingRequest(mPreviewRequest,</span><br><span class="line">                                    mCaptureCallback, mBackgroundHandler);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (CameraAccessException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConfigureFailed</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                            @NonNull CameraCaptureSession cameraCaptureSession)</span> </span>&#123;</span><br><span class="line">                        showToast(<span class="string">"Failed"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="keyword">null</span></span><br><span class="line">        );</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CameraAccessException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、拍照"><a href="#3、拍照" class="headerlink" title="3、拍照"></a>3、拍照</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initiate a still image capture.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">takePicture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lockFocus();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Lock the focus as the first step for a still image capture.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">lockFocus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 告诉摄像机开始对焦</span></span><br><span class="line">        mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AF_TRIGGER,</span><br><span class="line">                CameraMetadata.CONTROL_AF_TRIGGER_START);</span><br><span class="line">        <span class="comment">// Tell #mCaptureCallback to wait for the lock.</span></span><br><span class="line">        mState = STATE_WAITING_LOCK;</span><br><span class="line">        <span class="comment">// 发送CaptureRequest要求摄像机捕捉图像</span></span><br><span class="line">        mCaptureSession.capture(mPreviewRequestBuilder.build(), mCaptureCallback,</span><br><span class="line">                mBackgroundHandler);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CameraAccessException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> CameraCaptureSession.CaptureCallback mCaptureCallback</span><br><span class="line">            = <span class="keyword">new</span> CameraCaptureSession.CaptureCallback() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(CaptureResult result)</span> </span>&#123;</span><br><span class="line">              <span class="comment">//处理对焦、闪光灯等</span></span><br><span class="line">              .......</span><br><span class="line">             </span><br><span class="line">              <span class="keyword">case</span> STATE_WAITING_LOCK: &#123;</span><br><span class="line">                    .......</span><br><span class="line">                    <span class="comment">//对焦完成，保存一张图片</span></span><br><span class="line">                    captureStillPicture()；</span><br><span class="line">                    .......</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">              </span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">captureStillPicture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Activity activity = getActivity();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == activity || <span class="keyword">null</span> == mCameraDevice) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// This is the CaptureRequest.Builder that we use to take a picture.</span></span><br><span class="line">        <span class="comment">// 将mImageReader作为目标，获得的图片数据会交给mImageReader处理</span></span><br><span class="line">        <span class="comment">// 初始化时 mImageReader.setOnImageAvailableListener(mOnImageAvailableListener, mBackgroundHandler);</span></span><br><span class="line">        <span class="comment">// 所以数据最终会在mOnImageAvailableListener中处理</span></span><br><span class="line">        <span class="keyword">final</span> CaptureRequest.Builder captureBuilder =</span><br><span class="line">                mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_STILL_CAPTURE);</span><br><span class="line">        captureBuilder.addTarget(mImageReader.getSurface());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Use the same AE and AF modes as the preview.</span></span><br><span class="line">        captureBuilder.set(CaptureRequest.CONTROL_AF_MODE,</span><br><span class="line">                CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE);</span><br><span class="line">        setAutoFlash(captureBuilder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Orientation</span></span><br><span class="line">        <span class="keyword">int</span> rotation = activity.getWindowManager().getDefaultDisplay().getRotation();</span><br><span class="line">        captureBuilder.set(CaptureRequest.JPEG_ORIENTATION, getOrientation(rotation));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拍照事件的最终回调，图片处理完后调用onCaptureCompleted</span></span><br><span class="line">        CameraCaptureSession.CaptureCallback CaptureCallback</span><br><span class="line">                = <span class="keyword">new</span> CameraCaptureSession.CaptureCallback() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCaptureCompleted</span><span class="params">(@NonNull CameraCaptureSession session,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           @NonNull CaptureRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           @NonNull TotalCaptureResult result)</span> </span>&#123;</span><br><span class="line">                showToast(<span class="string">"Saved: "</span> + mFile);</span><br><span class="line">                Log.d(TAG, mFile.toString());</span><br><span class="line">                unlockFocus();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        mCaptureSession.stopRepeating();</span><br><span class="line">        mCaptureSession.abortCaptures();</span><br><span class="line">        mCaptureSession.capture(captureBuilder.build(), CaptureCallback, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CameraAccessException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据处理、保存</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ImageReader.OnImageAvailableListener mOnImageAvailableListener</span><br><span class="line">        = <span class="keyword">new</span> ImageReader.OnImageAvailableListener() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onImageAvailable</span><span class="params">(ImageReader reader)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//mBackgroundHandler.post(new ImageSaver(reader.acquireNextImage(), mFile));</span></span><br><span class="line">        Image mImage = reader.acquireNextImage();</span><br><span class="line">        ByteBuffer buffer = mImage.getPlanes()[<span class="number">0</span>].getBuffer();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[buffer.remaining()];</span><br><span class="line">        buffer.get(bytes);</span><br><span class="line">        <span class="comment">// 文件操作</span></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        <span class="comment">// 这里获取到的是视频的原始数据，要对数据做进一步的算法处理、或者采用第三方的编码库进行压缩、以及网络传输等，都可以从这里拿到数据。</span></span><br><span class="line">        mImage.close()；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4、录像"><a href="#4、录像" class="headerlink" title="4、录像"></a>4、录像</h3><p>主要看一下MediaRecorder录制视频相关代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startRecordingVideo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == mCameraDevice || !mTextureView.isAvailable() || <span class="keyword">null</span> == mPreviewSize) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 关闭之前的会话，新的会话会添加录像的Target</span></span><br><span class="line">        closePreviewSession();</span><br><span class="line">        <span class="comment">// 配置MediaRecorder，音频、视频来源，编码格式等</span></span><br><span class="line">        setUpMediaRecorder();</span><br><span class="line">        SurfaceTexture texture = mTextureView.getSurfaceTexture();</span><br><span class="line">        <span class="keyword">assert</span> texture != <span class="keyword">null</span>;</span><br><span class="line">        texture.setDefaultBufferSize(mPreviewSize.getWidth(), mPreviewSize.getHeight());</span><br><span class="line">        <span class="comment">// 创建一个适合视频录制的请求</span></span><br><span class="line">        mPreviewBuilder = mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_RECORD);</span><br><span class="line">        List&lt;Surface&gt; surfaces = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set up Surface for the camera preview</span></span><br><span class="line">        Surface previewSurface = <span class="keyword">new</span> Surface(texture);</span><br><span class="line">        surfaces.add(previewSurface);</span><br><span class="line">        mPreviewBuilder.addTarget(previewSurface);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set up Surface for the MediaRecorder 重要的一步，视频信息会交给mMediaRecorder处理</span></span><br><span class="line">        Surface recorderSurface = mMediaRecorder.getSurface();</span><br><span class="line">        surfaces.add(recorderSurface);</span><br><span class="line">        mPreviewBuilder.addTarget(recorderSurface);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Start a capture session</span></span><br><span class="line">        <span class="comment">// Once the session starts, we can update the UI and start recording</span></span><br><span class="line">        mCameraDevice.createCaptureSession(surfaces, <span class="keyword">new</span> CameraCaptureSession.StateCallback() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConfigured</span><span class="params">(@NonNull CameraCaptureSession cameraCaptureSession)</span> </span>&#123;</span><br><span class="line">                mPreviewSession = cameraCaptureSession;</span><br><span class="line">                updatePreview();</span><br><span class="line">                getActivity().runOnUiThread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="comment">// UI</span></span><br><span class="line">                        mButtonVideo.setText(R.string.stop);</span><br><span class="line">                        mIsRecordingVideo = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 开始录制</span></span><br><span class="line">                        mMediaRecorder.start();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConfigureFailed</span><span class="params">(@NonNull CameraCaptureSession cameraCaptureSession)</span> </span>&#123;</span><br><span class="line">                Activity activity = getActivity();</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != activity) &#123;</span><br><span class="line">                    Toast.makeText(activity, <span class="string">"Failed"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, mBackgroundHandler);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CameraAccessException | IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置MediaRecorder</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setUpMediaRecorder</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Activity activity = getActivity();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == activity) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置要用于录制的音频源。</span></span><br><span class="line">    mMediaRecorder.setAudioSource(MediaRecorder.AudioSource.MIC);</span><br><span class="line">    <span class="comment">// 设置要用于录制的视频源。</span></span><br><span class="line">    mMediaRecorder.setVideoSource(MediaRecorder.VideoSource.SURFACE);</span><br><span class="line">    <span class="comment">// 设置录制期间生成的输出文件的格式。</span></span><br><span class="line">    mMediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.MPEG_4);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生成MP4文件路径</span></span><br><span class="line">    <span class="keyword">if</span> (mNextVideoAbsolutePath == <span class="keyword">null</span> || mNextVideoAbsolutePath.isEmpty()) &#123;</span><br><span class="line">        mNextVideoAbsolutePath = getVideoFilePath(getActivity());</span><br><span class="line">    &#125;</span><br><span class="line">    mMediaRecorder.setOutputFile(mNextVideoAbsolutePath);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置用于录制的视频编码比特率。</span></span><br><span class="line">    mMediaRecorder.setVideoEncodingBitRate(<span class="number">10000000</span>);</span><br><span class="line">    <span class="comment">// 设置要捕获的视频的帧速率。</span></span><br><span class="line">    mMediaRecorder.setVideoFrameRate(<span class="number">30</span>);</span><br><span class="line">    mMediaRecorder.setVideoSize(mVideoSize.getWidth(), mVideoSize.getHeight());</span><br><span class="line">    <span class="comment">// 设置要用于录制的视频编码器。</span></span><br><span class="line">    mMediaRecorder.setVideoEncoder(MediaRecorder.VideoEncoder.H264);</span><br><span class="line">    <span class="comment">// 设置要用于录制的音频编码器。</span></span><br><span class="line">    mMediaRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.AAC);</span><br><span class="line">    <span class="keyword">int</span> rotation = activity.getWindowManager().getDefaultDisplay().getRotation();</span><br><span class="line">    <span class="keyword">switch</span> (mSensorOrientation) &#123;</span><br><span class="line">        <span class="keyword">case</span> SENSOR_ORIENTATION_DEFAULT_DEGREES:</span><br><span class="line">            mMediaRecorder.setOrientationHint(DEFAULT_ORIENTATIONS.get(rotation));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SENSOR_ORIENTATION_INVERSE_DEGREES:</span><br><span class="line">            mMediaRecorder.setOrientationHint(INVERSE_ORIENTATIONS.get(rotation));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在调用start前必须的一步</span></span><br><span class="line">    mMediaRecorder.prepare();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 常规使用MediaRecorder去录制视频的例子如下：</span><br><span class="line"> * MediaRecorder recorder = new MediaRecorder()<span class="comment">;</span></span><br><span class="line"> * recorder.setAudioSource(MediaRecorder.AudioSource.MIC)<span class="comment">;</span></span><br><span class="line"> * recorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP)<span class="comment">;</span></span><br><span class="line"> * recorder.setAudioEncoder(MediaRecorder.AudioEncoder.AMR_NB)<span class="comment">;</span></span><br><span class="line"> * recorder.setOutputFile(PATH_NAME)<span class="comment">;</span></span><br><span class="line"> * recorder.prepare()<span class="comment">;</span></span><br><span class="line"> * recorder.start()<span class="comment">;   // Recording is now started</span></span><br><span class="line"> * ...</span><br><span class="line"> * recorder.stop()<span class="comment">;</span></span><br><span class="line"> * recorder.reset()<span class="comment">;   // You can reuse the object by going back to setAudioSource() step</span></span><br><span class="line"> * recorder.release()<span class="comment">; // Now the object cannot be reused</span></span><br><span class="line"> **/</span><br></pre></td></tr></table></figure><p>Camera2预览、拍照和录像的大概流程就是这样，相对来说挺复杂的，但也非常重要，后面会继续深入分析原理和源码。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是Android音视频的第一篇文章，终于回到了我的老本行上，后面音视频开发会基于Android平台（关键我也不太会其他平台，后面会慢慢学习。。。）&lt;/p&gt;
&lt;p&gt;之前好像从来没有做过Camera相关的开发，这块对我来说还是有点陌生，所以从头开始学起。&lt;/p&gt;
&lt;h2 id
      
    
    </summary>
    
      <category term="Android音视频" scheme="http://yoursite.com/categories/Android%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="Camera2" scheme="http://yoursite.com/tags/Camera2/"/>
    
  </entry>
  
  <entry>
    <title>C语言回调函数</title>
    <link href="http://yoursite.com/2018/12/23/C%E8%AF%AD%E8%A8%80%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2018/12/23/C语言回调函数/</id>
    <published>2018-12-23T06:48:51.000Z</published>
    <updated>2019-01-03T02:27:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>想要理解C语言的回调函数，需要先理解什么是函数指针。</p><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>函数指针是指向函数的指针变量。</p><p>通常我们说的指针变量是指向一个整型、字符型或数组等变量，而函数指针是指向函数。</p><p>函数指针可以像一般函数一样，用于调用函数、传递参数。</p><p>函数指针变量的声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*fun_ptr)</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>; <span class="comment">// 声明一个指向同样参数、返回值的函数指针类型</span></span><br></pre></td></tr></table></figure><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>以下实例声明了函数指针变量 p，指向函数 max：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* p 是函数指针 */</span></span><br><span class="line">    <span class="keyword">int</span> (* p)(<span class="keyword">int</span>, <span class="keyword">int</span>) = &amp; max; <span class="comment">// &amp;可以省略</span></span><br><span class="line">    <span class="keyword">int</span> a, b, c, d;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入三个数字:"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp; a, &amp; b, &amp; c);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 与直接调用函数等价，d = max(max(a, b), c) */</span></span><br><span class="line">    d = p(p(a, b), c); </span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"最大的数字是: %d\n"</span>, d);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译执行，输出结果如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">请输入三个数字:1 2 3</span></span><br><span class="line"><span class="section">最大的数字是: 3</span></span><br></pre></td></tr></table></figure><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>函数指针理解后就轮到我们的正主了。那么我们从三个问题开始：</p><ol><li><p>回调函数是什么</p></li><li><p>回调函数该如何使用</p></li><li><p>回调函数在什么时候用</p></li></ol><h4 id="1、回调函数是什么"><a href="#1、回调函数是什么" class="headerlink" title="1、回调函数是什么"></a>1、回调函数是什么</h4><p>函数指针变量可以作为某个函数的参数来使用的，回调函数就是一个通过函数指针调用的函数。</p><p>简单讲：回调函数是由别人的函数执行时调用你实现的函数。</p><h4 id="2、回调函数该如何使用"><a href="#2、回调函数该如何使用" class="headerlink" title="2、回调函数该如何使用"></a>2、回调函数该如何使用</h4><p>示例1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun1</span><span class="params">(<span class="keyword">void</span>)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello world.\n"</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">(<span class="keyword">int</span> (*Pfun)())</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    Pfun();  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    callback(fun1);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>callback回调定义的函数fun1，传递给callback的是函数fun1的地址。fun1是一个不含参数返回值为整型的函数，如果fun含有参数，还想使用回调函数则可用下面的示例2。</p><p>示例2：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun2</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s.\n"</span>, s);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">(<span class="keyword">int</span> (*Pfun)(<span class="keyword">char</span> *), <span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Pfun(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">callback(fun2, <span class="string">"hello world"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、回调函数在什么时候用"><a href="#3、回调函数在什么时候用" class="headerlink" title="3、回调函数在什么时候用"></a>3、回调函数在什么时候用</h4><p>通常，当我们想通过一个统一接口实现不同内容的时候，用回调函数来实现就非常合适。任何时候，如果你所编写的函数必须能够在不同的时刻执行不同的类型的工作或者执行只能由函数调用者定义的工作，你都可以用回调函数来实现。许多窗口系统就是使用回调函数连接多个动作，如拖拽鼠标和点击按钮来指定调用用户程序中的某个特定函数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;想要理解C语言的回调函数，需要先理解什么是函数指针。&lt;/p&gt;
&lt;h2 id=&quot;函数指针&quot;&gt;&lt;a href=&quot;#函数指针&quot; class=&quot;headerlink&quot; title=&quot;函数指针&quot;&gt;&lt;/a&gt;函数指针&lt;/h2&gt;&lt;p&gt;函数指针是指向函数的指针变量。&lt;/p&gt;
&lt;p&gt;通常我们说
      
    
    </summary>
    
      <category term="C/C++" scheme="http://yoursite.com/categories/C-C/"/>
    
    
      <category term="C语言" scheme="http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>YUV数据格式与YUV_420_888</title>
    <link href="http://yoursite.com/2018/12/20/YUV%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E4%B8%8EYUV_420_888/"/>
    <id>http://yoursite.com/2018/12/20/YUV数据格式与YUV_420_888/</id>
    <published>2018-12-20T06:45:00.000Z</published>
    <updated>2019-01-03T06:45:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在准备做Android Camera2相关应用，刚好也碰上了YUV格式相关的问题，所以还是写一篇博客理解YUV格式数据。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><em>YUV</em>是一种颜色空间，基于<em>YUV</em>的颜色编码是流媒体的常用编码方式。</p><p><em>YUV</em>是编译true-color颜色空间（color space）的种类，Y’UV, YUV, YCbCr，YPbPr等专有名词都可以称为<em>YUV</em>，彼此有重叠。<strong>“Y”表示明亮度（Luminance、Luma），“U”和“V”则是色度、浓度（Chrominance、Chroma）</strong>，Y′UV, YUV, YCbCr, YPbPr所指涉的范围，常有混淆或重叠的情况。</p><p>YUV格式有两大类：planar和packed。</p><ul><li>平面格式（planar formats） ：对于planar的YUV格式，先连续存储所有像素点的Y，紧接着存储所有像素点的U，随后是所有像素点的V，如 YYYY YYYY UU VV。</li><li>紧缩格式（packed formats）：对于packed的YUV格式，每个像素点的Y,U,V是连续交替存储的，如YUV YUV YUV YUV，这种排列方式跟 RGB 很类似。</li></ul><h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>Y’UV的发明是由于彩色电视与黑白电视的过渡时期。黑白视频只有Y（Luma，Luminance）视频，也就是灰阶值。到了彩色电视规格的制定，是以YUV/<a href="https://zh.wikipedia.org/wiki/YIQ" target="_blank" rel="noopener">YIQ</a>的格式来处理彩色电视图像，把UV视作表示彩度的C（Chrominance或Chroma），如果忽略C信号，那么剩下的Y（Luma）信号就跟之前的黑白电视频号相同，这样一来便解决彩色电视机与黑白电视机的兼容问题。Y’UV最大的优点在于只需占用极少的带宽。</p><p>因为UV分别代表不同颜色信号，所以直接使用R与B信号表示色度的UV。 也就是说UV信号告诉了电视要偏移某象素的的颜色，而不改变其亮度。 或者UV信号告诉了显示器使得某个颜色亮度依某个基准偏移。 UV的值越高，代表该像素会有更饱和的颜色。</p><p>彩色图像记录的格式，常见的有RGB、YUV、CMYK等。彩色电视最早的构想是使用RGB三原色来同时传输。这种设计方式是原来黑白带宽的3倍，在当时并不是很好的设计。RGB诉求于人眼对色彩的感应，YUV则着重于视觉对于亮度的敏感程度，Y代表的是亮度，UV代表的是彩度（因此黑白电影可省略UV，相近于RGB），分别用Cr和Cb来表示，因此YUV的记录通常以Y:UV的格式呈现。</p><p>将一张图片的Y、U、V数据单独显示就会如下图所示：</p><p><img src="/2018/12/20/YUV数据格式与YUV_420_888/yuv.png" alt="YUV数据显示"></p><h2 id="常见YUV格式"><a href="#常见YUV格式" class="headerlink" title="常见YUV格式"></a>常见YUV格式</h2><p>YUV的存储格式其实与其采样的方式密切相关，主流的采样方式有三种，YUV4:4:4，YUV4:2:2，YUV4:2:0。<br>$$<br>以黑点表示采样该像素点的Y分量，以空心圆圈表示采用该像素点的UV分量<br>$$</p><h3 id="YUV444"><a href="#YUV444" class="headerlink" title="YUV444"></a>YUV444</h3><p><img src="/2018/12/20/YUV数据格式与YUV_420_888/yuv444.png" alt=""></p><p>4:4:4表示完全取样，每个像素点都采样单独的 YUV 分量信息，包含了最全面的 YUV 信息。</p><h3 id="YUV422"><a href="#YUV422" class="headerlink" title="YUV422"></a>YUV422</h3><p><img src="/2018/12/20/YUV数据格式与YUV_420_888/yuv422.png" alt=""></p><p>在 YUV444 编码的基础上采用 2 * 1 的矩阵进行二次取样，也就是在水平方向上隔一列采样一次 UV 信息，在垂直方向上进行完全取样，每两个Y共用一组UV分量。</p><ul><li><p>YUYV格式</p><p>字节排列 : YUYV YUYV YUYV YUYV</p></li><li><p>UYVY 格式 </p><p>字节排列 : UYVY UYVY UYVY UYVY</p></li><li><p>YUV422P格式 </p><p>字节排列 :YYYY YYYY UUUU VVVV</p></li></ul><h3 id="YUV420"><a href="#YUV420" class="headerlink" title="YUV420"></a>YUV420</h3><p><img src="/2018/12/20/YUV数据格式与YUV_420_888/yuv420.png" alt=""></p><p>解决 YUV444 占用空间过大问题，也是最常用的采样格式。在 YUV444 格式的基础上使用 2 <em> 2 矩阵对像素点进行二次取样，4 个像素点具有单独 Y 分量且共享同一个 UV 信息，总 6 字节。一帧图像占用总空间 (W </em> H + W * H / 2) bytes，比 YUV444 少一半空间。</p><ul><li>I420格式<br>字节排列 YYYY YYYY UU VV，全部都是平面型排列</li><li>NV21格式<br>字节排列 YYYY YYYY UV UV，Y 平面和 UV 平面， UV 内部是紧凑型</li><li>YV12格式<br>字节排列 YYYY YYYY VV UU，平面型，V 在 U 前面</li></ul><p>更多YUV格式参看：<a href="https://blog.csdn.net/airk000/article/details/25032901" target="_blank" rel="noopener">V4L2文档翻译（十）</a></p><h3 id="4-：2：-2-和4：2：0-转换"><a href="#4-：2：-2-和4：2：0-转换" class="headerlink" title="4 ：2： 2 和4：2：0 转换"></a>4 ：2： 2 和4：2：0 转换</h3><p>最简单的方式：</p><p>YUV4:2:2 —&gt; YUV4:2:0  Y不变，将U和V信号值在行(垂直方向)在进行一次隔行抽样</p><p> YUV4:2:0 —&gt; YUV4:2:2  Y不变，将U和V信号值的每一行分别拷贝一份形成连续两行数据</p><h2 id="YUV-420-888"><a href="#YUV-420-888" class="headerlink" title="YUV_420_888"></a>YUV_420_888</h2><p>YUV_420_888是在Android Camera2直播开发中遇到的一个Android内部的YUV格式，当时也是在这个格式上面纠结好久，直播的视频流想用YUV420P格式的数据，但却不清楚这个YUV_420_888到底对应的是NV21或者YUV420P还是其他，网上对这个格式的讲解也比较少。在搜索一番之后终于搞定，在这里记录一下。</p><p>下面这两篇博客介绍了YUV_420_888以及如何解析，讲的很清晰，这里还是不自己去写了。</p><p><a href="https://link.juejin.im/?target=https%3A%2F%2Fblog.csdn.net%2Fj12345678901%2Farticle%2Fdetails%2F78110640" target="_blank" rel="noopener">android camera2 拿到的yuv420数据到底是什么样的？</a></p><p><a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.polarxiong.com%2Farchives%2FAndroid-Image%25E7%25B1%25BB%25E6%25B5%2585%25E6%259E%2590-%25E7%25BB%2593%25E5%2590%2588YUV_420_888.html" target="_blank" rel="noopener">Android: Image类浅析(结合YUV_420_888)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在准备做Android Camera2相关应用，刚好也碰上了YUV格式相关的问题，所以还是写一篇博客理解YUV格式数据。&lt;/p&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;
      
    
    </summary>
    
      <category term="FFmpeg" scheme="http://yoursite.com/categories/FFmpeg/"/>
    
    
      <category term="音视频" scheme="http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>Linux中断和中断处理</title>
    <link href="http://yoursite.com/2018/12/18/Linux%E4%B8%AD%E6%96%AD%E5%92%8C%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2018/12/18/Linux中断和中断处理/</id>
    <published>2018-12-18T12:33:10.000Z</published>
    <updated>2018-12-28T06:58:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文为《Linux内核设计与实现》第七章 “中断和中断处理” 阅读笔记。</p><h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>中断本质上是一种特殊的电信号，有硬件设备发送给处理器。处理器接收到中断后，会马上向操作系统反映此信号的到来，然后就由操作系统处理这些新到来的数据。不同设备对应的中断不同，而每个中断都通过一个唯一的数字标志（中断请求线，IRQ线），操作系统可以根据这些标志提供对应的中断处理程序。</p><h2 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h2><p>在响应一个特定中断的时候，内核会执行一个函数，该函数就被称为中断处理程序或中断服务例程。产生中断的每个设备都有一个相应的中断处理程序。</p><p>在Linux中，中断处理程序就是普通的C函数，不过必须按照特定的类型声明，以便内核能够以标准的方式传递处理程序的信息。被内核调用来响应中断，运行于我们称之为中断上下文中的特殊上下文中。</p><p>因为中断随时可能发生，所以中断处理程序也就随时可能发生。所以必须保证中断处理程序能够快速执行，这样才能保证尽可能快地恢复中断代码的执行。</p><h2 id="上半部与下半部的对比"><a href="#上半部与下半部的对比" class="headerlink" title="上半部与下半部的对比"></a>上半部与下半部的对比</h2><p>又想中断处理程序执行得快，又想中断处理程序完成的工作量多，这两个目的显然有所抵触，所以我们一般把中断处理切为两个部分。</p><p>中断处理程序是上半部（top half）——接收到一个中断，它就立即开始执行，但只做有严格时限的工作。能够被允许稍后完成的工作会推迟到下半部（bottom half）去。</p><h2 id="注册、释放中断处理程序"><a href="#注册、释放中断处理程序" class="headerlink" title="注册、释放中断处理程序"></a>注册、释放中断处理程序</h2><p>中断处理程序是管理硬件的驱动程序的组成部分。驱动程序可以通过 <code>request-irq()</code>函数注册一个中断处理程序，并且激活给定的中断线，以处理中断。</p><p>卸载驱动时，需要注销相对应的中断处理程序，并释放中断线。<code>free_irq()</code>                                                                    </p><h2 id="编写中断处理程序"><a href="#编写中断处理程序" class="headerlink" title="编写中断处理程序"></a>编写中断处理程序</h2><p><code>static irqreturn_t intr_handler(int irq,void *dev)</code>                                                                                                                                              </p><p>第一个参数irq是这个处理程序要响应的中断的中断号，目前已经没有太大用了。</p><p>第二个参数dev是一个通用指针。可以用来区分共享同一中断处理程序的多个设备。</p><h2 id="中断上下文"><a href="#中断上下文" class="headerlink" title="中断上下文"></a>中断上下文</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文为《Linux内核设计与实现》第七章 “中断和中断处理” 阅读笔记。&lt;/p&gt;
&lt;h2 id=&quot;中断&quot;&gt;&lt;a href=&quot;#中断&quot; class=&quot;headerlink&quot; title=&quot;中断&quot;&gt;&lt;/a&gt;中断&lt;/h2&gt;&lt;p&gt;中断本质上是一种特殊的电信号，有硬件设备发送给处理器
      
    
    </summary>
    
      <category term="Linux系统" scheme="http://yoursite.com/categories/Linux%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="中断" scheme="http://yoursite.com/tags/%E4%B8%AD%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>FFmpeg代码实现视频转图片</title>
    <link href="http://yoursite.com/2018/12/10/FFmpeg%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E8%A7%86%E9%A2%91%E8%BD%AC%E5%9B%BE%E7%89%87/"/>
    <id>http://yoursite.com/2018/12/10/FFmpeg代码实现视频转图片/</id>
    <published>2018-12-10T10:59:09.000Z</published>
    <updated>2018-12-28T06:58:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>代码实现视频转图片主要是使用了FFmpeg视频编解码相关的知识，所以首先了解下FFmpeg中的编解码相关函数以及流程，后面再看代码就会比较轻松了。</p><h2 id="视频解码"><a href="#视频解码" class="headerlink" title="视频解码"></a>视频解码</h2><ol><li>打开输入文件 <code>avformat_open_input</code></li><li>找到视频流   <code>av_find_best_stream</code></li><li>找到对应的解码器 <code>avcodec_find_decoder</code></li><li>初始化一个编解码上下文 <code>avcodec_alloc_context3</code></li><li>拷贝流参数到编解码上下文中 <code>avcodec_parameters_to_context</code></li><li>打开解码器 <code>avcodec_open2</code></li><li>读取视频帧 <code>av_read_frame</code></li><li>发送等待解码帧 <code>avcodec_send_packet</code></li><li>接收解码后frame数据 <code>avcodec_receive_frame</code></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *in_filename, *out_filename;</span><br><span class="line">    AVFormatContext *fmt_ctx = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> AVCodec *codec;</span><br><span class="line">    AVCodecContext *codeCtx = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    AVStream *stream = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> stream_index;</span><br><span class="line"></span><br><span class="line">    AVPacket avpkt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> frame_count;</span><br><span class="line">    AVFrame *frame;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage: %s &lt;input file&gt; &lt;output file&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    in_filename = argv[<span class="number">1</span>];</span><br><span class="line">    out_filename = argv[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">if</span> (avformat_open_input(&amp;fmt_ctx, in_filename, <span class="literal">NULL</span>, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Could not open source file %s\n"</span>, in_filename);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (avformat_find_stream_info(fmt_ctx, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Could not find stream information\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    av_dump_format(fmt_ctx, <span class="number">0</span>, in_filename, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    av_init_packet(&amp;avpkt);</span><br><span class="line">    avpkt.data = <span class="literal">NULL</span>;</span><br><span class="line">    avpkt.size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 2</span></span><br><span class="line">    stream_index = av_find_best_stream(fmt_ctx, AVMEDIA_TYPE_VIDEO, <span class="number">-1</span>, <span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Could not find %s stream in input file '%s'\n"</span>,</span><br><span class="line">                av_get_media_type_string(AVMEDIA_TYPE_VIDEO), in_filename);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stream = fmt_ctx-&gt;streams[stream_index];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    codec = avcodec_find_decoder(stream-&gt;codecpar-&gt;codec_id);</span><br><span class="line">    <span class="keyword">if</span> (codec == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4</span></span><br><span class="line">    codeCtx = avcodec_alloc_context3(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!codeCtx) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Could not allocate video codec context\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5</span></span><br><span class="line">    <span class="keyword">if</span> ((ret = avcodec_parameters_to_context(codeCtx, stream-&gt;codecpar)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Failed to copy %s codec parameters to decoder context\n"</span>,</span><br><span class="line">                av_get_media_type_string(AVMEDIA_TYPE_VIDEO));</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6</span></span><br><span class="line">    avcodec_open2(codeCtx, codec, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化frame，解码后数据</span></span><br><span class="line">    frame = av_frame_alloc();</span><br><span class="line">    <span class="keyword">if</span> (!frame) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Could not allocate video frame\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    frame_count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">// 7</span></span><br><span class="line">    <span class="keyword">while</span> (av_read_frame(fmt_ctx, &amp;avpkt) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (avpkt.stream_index == stream_index) &#123;</span><br><span class="line">            <span class="comment">// 8</span></span><br><span class="line">            <span class="keyword">int</span> re = avcodec_send_packet(codeCtx, &amp;avpkt);</span><br><span class="line">            <span class="keyword">if</span> (re &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 9 这里必须用while()，因为一次avcodec_receive_frame可能无法接收到所有数据</span></span><br><span class="line">            <span class="keyword">while</span> (avcodec_receive_frame(codeCtx, frame) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 拼接图片路径、名称</span></span><br><span class="line">                <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), <span class="string">"%s/Demo-%d.jpg"</span>, out_filename, frame_count);</span><br><span class="line">                saveJpg(frame, buf); <span class="comment">//保存为jpg图片</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            frame_count++;</span><br><span class="line">        &#125;</span><br><span class="line">        av_packet_unref(&amp;avpkt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="视频编码（保存为图片）"><a href="#视频编码（保存为图片）" class="headerlink" title="视频编码（保存为图片）"></a>视频编码（保存为图片）</h2><p>编码整体在流程上和解码一致</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">saveJpg</span><span class="params">(AVFrame *pFrame, <span class="keyword">char</span> *out_name)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> width = pFrame-&gt;width;</span><br><span class="line">    <span class="keyword">int</span> height = pFrame-&gt;height;</span><br><span class="line">    AVCodecContext *pCodeCtx = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    AVFormatContext *pFormatCtx = avformat_alloc_context();</span><br><span class="line">    <span class="comment">// 设置输出文件格式</span></span><br><span class="line">    pFormatCtx-&gt;oformat = av_guess_format(<span class="string">"mjpeg"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建并初始化输出AVIOContext</span></span><br><span class="line">    <span class="keyword">if</span> (avio_open(&amp;pFormatCtx-&gt;pb, out_name, AVIO_FLAG_READ_WRITE) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Couldn't open output file."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建一个新stream</span></span><br><span class="line">    AVStream *pAVStream = avformat_new_stream(pFormatCtx, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pAVStream == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AVCodecParameters *parameters = pAVStream-&gt;codecpar;</span><br><span class="line">    parameters-&gt;codec_id = pFormatCtx-&gt;oformat-&gt;video_codec;</span><br><span class="line">    parameters-&gt;codec_type = AVMEDIA_TYPE_VIDEO;</span><br><span class="line">    parameters-&gt;format = AV_PIX_FMT_YUVJ420P;</span><br><span class="line">    parameters-&gt;width = pFrame-&gt;width;</span><br><span class="line">    parameters-&gt;height = pFrame-&gt;height;</span><br><span class="line"></span><br><span class="line">    AVCodec *pCodec = avcodec_find_encoder(pAVStream-&gt;codecpar-&gt;codec_id);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!pCodec) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Could not find encoder\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pCodeCtx = avcodec_alloc_context3(pCodec);</span><br><span class="line">    <span class="keyword">if</span> (!pCodeCtx) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Could not allocate video codec context\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((avcodec_parameters_to_context(pCodeCtx, pAVStream-&gt;codecpar)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Failed to copy %s codec parameters to decoder context\n"</span>,</span><br><span class="line">                av_get_media_type_string(AVMEDIA_TYPE_VIDEO));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pCodeCtx-&gt;time_base = (AVRational) &#123;<span class="number">1</span>, <span class="number">25</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (avcodec_open2(pCodeCtx, pCodec, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Could not open codec."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = avformat_write_header(pFormatCtx, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"write_header fail\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> y_size = width * height;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Encode</span></span><br><span class="line">    <span class="comment">// 给AVPacket分配足够大的空间</span></span><br><span class="line">    AVPacket pkt;</span><br><span class="line">    av_new_packet(&amp;pkt, y_size * <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码数据</span></span><br><span class="line">    ret = avcodec_send_frame(pCodeCtx, pFrame);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Could not avcodec_send_frame."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到编码后数据</span></span><br><span class="line">    ret = avcodec_receive_packet(pCodeCtx, &amp;pkt);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Could not avcodec_receive_packet"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = av_write_frame(pFormatCtx, &amp;pkt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Could not av_write_frame"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    av_packet_unref(&amp;pkt);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Write Trailer</span></span><br><span class="line">    av_write_trailer(pFormatCtx);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    avcodec_close(pCodeCtx);</span><br><span class="line">    avio_close(pFormatCtx-&gt;pb);</span><br><span class="line">    avformat_free_context(pFormatCtx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h2><p><img src="/2018/12/10/FFmpeg代码实现视频转图片/decoder.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;代码实现视频转图片主要是使用了FFmpeg视频编解码相关的知识，所以首先了解下FFmpeg中的编解码相关函数以及流程，后面再看代码就会比较轻松了。&lt;/p&gt;
&lt;h2 id=&quot;视频解码&quot;&gt;&lt;a href=&quot;#视频解码&quot; class=&quot;headerlink&quot; title=&quot;视频解
      
    
    </summary>
    
      <category term="FFmpeg" scheme="http://yoursite.com/categories/FFmpeg/"/>
    
    
      <category term="FFmpeg" scheme="http://yoursite.com/tags/FFmpeg/"/>
    
      <category term="音视频" scheme="http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>FFmpeg代码实现最简版本小咖秀</title>
    <link href="http://yoursite.com/2018/12/07/FFmpeg%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E6%9C%80%E7%AE%80%E7%89%88%E6%9C%AC%E5%B0%8F%E5%92%96%E7%A7%80/"/>
    <id>http://yoursite.com/2018/12/07/FFmpeg代码实现最简版本小咖秀/</id>
    <published>2018-12-07T08:27:40.000Z</published>
    <updated>2018-12-28T06:58:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天代码实现了从两个音视频文件中分别抽取音频、视频数据，并将这两种数据存储在一个新的MP4文件中，文件可以正常播放画面和声音，也就是实现一个最简版本的小咖秀。</p><p>前面几篇博客已经把需要的知识都讲了一遍，代码流程也基本一致，下面的代码看起来也会非常轻松。</p><p>源码实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> err_code;</span><br><span class="line"><span class="keyword">char</span> errors[ERROR_STR_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *src_file1, *src_file2, *out_file;</span><br><span class="line"></span><br><span class="line">AVFormatContext *ifmt_ctx1 = <span class="literal">NULL</span>;</span><br><span class="line">AVFormatContext *ifmt_ctx2 = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">AVFormatContext *ofmt_ctx = <span class="literal">NULL</span>;</span><br><span class="line">AVOutputFormat *ofmt = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">AVStream *in_stream1 = <span class="literal">NULL</span>;</span><br><span class="line">AVStream *in_stream2 = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">AVStream *out_stream1 = <span class="literal">NULL</span>;</span><br><span class="line">AVStream *out_stream2 = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> audio_stream_index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> vedio_stream_indes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件最大时长，保证音频和视频数据长度一致</span></span><br><span class="line"><span class="keyword">double</span> max_duration = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">AVPacket pkt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> stream1 = <span class="number">0</span>, stream2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">av_log_set_level(AV_LOG_DEBUG);</span><br><span class="line"></span><br><span class="line">src_file1 = argv[<span class="number">1</span>];</span><br><span class="line">src_file2 = argv[<span class="number">2</span>];</span><br><span class="line">out_file = argv[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//打开两个输入文件</span></span><br><span class="line"><span class="keyword">if</span> ((err_code = avformat_open_input(&amp;ifmt_ctx1, src_file1, <span class="number">0</span>, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    av_strerror(err_code, errors, ERROR_STR_SIZE);</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_ERROR,<span class="string">"Could not open src file, %s, %d(%s)\n"</span>,</span><br><span class="line">           src_file1, err_code, errors);</span><br><span class="line">    <span class="keyword">goto</span> END;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((err_code = avformat_open_input(&amp;ifmt_ctx2, src_file2, <span class="number">0</span>, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    av_strerror(err_code, errors, ERROR_STR_SIZE);</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_ERROR,</span><br><span class="line">           <span class="string">"Could not open the second src file, %s, %d(%s)\n"</span>,</span><br><span class="line">           src_file2, err_code, errors);</span><br><span class="line">    <span class="keyword">goto</span> END;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建输出上下文</span></span><br><span class="line"><span class="keyword">if</span> ((err_code = avformat_alloc_output_context2(&amp;ofmt_ctx, <span class="literal">NULL</span>, <span class="literal">NULL</span>, out_file)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    av_strerror(err_code, errors, ERROR_STR_SIZE);</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">"Failed to create an context of outfile , %d(%s) \n"</span>,</span><br><span class="line">           err_code, errors);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ofmt = ofmt_ctx-&gt;oformat;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到第一个参数里最好的音频流和第二个文件中的视频流下标</span></span><br><span class="line">audio_stream_index = av_find_best_stream(ifmt_ctx1, AVMEDIA_TYPE_AUDIO, <span class="number">-1</span>, <span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">vedio_stream_indes = av_find_best_stream(ifmt_ctx2, AVMEDIA_TYPE_VIDEO, <span class="number">-1</span>, <span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取第一个文件中的音频流</span></span><br><span class="line">in_stream1 = ifmt_ctx1-&gt;streams[audio_stream_index];</span><br><span class="line">stream1 = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 创建音频输出流</span></span><br><span class="line">out_stream1 = avformat_new_stream(ofmt_ctx, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (!out_stream1) &#123;</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">"Failed to alloc out stream!\n"</span>);</span><br><span class="line">    <span class="keyword">goto</span> END;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 拷贝流参数</span></span><br><span class="line"><span class="keyword">if</span> ((err_code = avcodec_parameters_copy(out_stream1-&gt;codecpar, in_stream1-&gt;codecpar)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    av_strerror(err_code, errors, ERROR_STR_SIZE);</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_ERROR,</span><br><span class="line">           <span class="string">"Failed to copy codec parameter, %d(%s)\n"</span>,</span><br><span class="line">           err_code, errors);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out_stream1-&gt;codecpar-&gt;codec_tag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取第二个文件中的视频流</span></span><br><span class="line">in_stream2 = ifmt_ctx2-&gt;streams[vedio_stream_indes];</span><br><span class="line">stream2 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建视频输出流</span></span><br><span class="line">out_stream2 = avformat_new_stream(ofmt_ctx, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (!out_stream2) &#123;</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">"Failed to alloc out stream!\n"</span>);</span><br><span class="line">    <span class="keyword">goto</span> END;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝流参数</span></span><br><span class="line"><span class="keyword">if</span> ((err_code = avcodec_parameters_copy(out_stream2-&gt;codecpar, in_stream2-&gt;codecpar)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    av_strerror(err_code, errors, ERROR_STR_SIZE);</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_ERROR,</span><br><span class="line">           <span class="string">"Failed to copy codec parameter, %d(%s)\n"</span>,</span><br><span class="line">           err_code, errors);</span><br><span class="line">    <span class="keyword">goto</span> END;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out_stream2-&gt;codecpar-&gt;codec_tag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">av_dump_format(ofmt_ctx, <span class="number">0</span>, out_file, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断两个流的长度，确定最终文件的长度</span></span><br><span class="line"><span class="keyword">if</span> (in_stream1-&gt;duration * av_q2d(in_stream1-&gt;time_base) &gt; in_stream2-&gt;duration * av_q2d(in_stream2-&gt;time_base)) &#123;</span><br><span class="line">    max_duration = in_stream2-&gt;duration * av_q2d(in_stream2-&gt;time_base);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    max_duration = in_stream1-&gt;duration * av_q2d(in_stream1-&gt;time_base);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打开输出文件</span></span><br><span class="line"><span class="keyword">if</span> (!(ofmt-&gt;flags &amp; AVFMT_NOFILE)) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((err_code = avio_open(&amp;ofmt_ctx-&gt;pb, out_file, AVIO_FLAG_WRITE)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        av_strerror(err_code, errors, ERROR_STR_SIZE);</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_ERROR,</span><br><span class="line">               <span class="string">"Could not open output file, %s, %d(%s)\n"</span>,</span><br><span class="line">               out_file, err_code, errors);</span><br><span class="line">        <span class="keyword">goto</span> END;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写头信息</span></span><br><span class="line">avformat_write_header(ofmt_ctx, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">av_init_packet(&amp;pkt);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取音频数据并写入输出文件中</span></span><br><span class="line"><span class="keyword">while</span> (av_read_frame(ifmt_ctx1, &amp;pkt) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果读取的时间超过了最长时间表示不需要该帧，跳过</span></span><br><span class="line">    <span class="keyword">if</span> (pkt.pts * av_q2d(in_stream1-&gt;time_base) &gt; max_duration) &#123;</span><br><span class="line">        av_packet_unref(&amp;pkt);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 如果是我们需要的音频流，转换时间基后写入文件</span></span><br><span class="line">    <span class="keyword">if</span> (pkt.stream_index == audio_stream_index) &#123;</span><br><span class="line">        pkt.pts = av_rescale_q_rnd(pkt.pts, in_stream1-&gt;time_base, out_stream1-&gt;time_base,</span><br><span class="line">                                   (AV_ROUND_NEAR_INF | AV_ROUND_PASS_MINMAX));</span><br><span class="line">        pkt.dts = av_rescale_q_rnd(pkt.dts, in_stream1-&gt;time_base, out_stream1-&gt;time_base,</span><br><span class="line">                                   (AV_ROUND_NEAR_INF | AV_ROUND_PASS_MINMAX));</span><br><span class="line">        pkt.duration = av_rescale_q(max_duration, in_stream1-&gt;time_base, out_stream1-&gt;time_base);</span><br><span class="line">        pkt.pos = <span class="number">-1</span>;</span><br><span class="line">        pkt.stream_index = stream1;</span><br><span class="line">        av_interleaved_write_frame(ofmt_ctx, &amp;pkt);</span><br><span class="line">        av_packet_unref(&amp;pkt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取视频数据并写入输出文件中</span></span><br><span class="line"><span class="keyword">while</span> (av_read_frame(ifmt_ctx2, &amp;pkt) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 如果读取的时间超过了最长时间表示不需要该帧，跳过</span></span><br><span class="line">    <span class="keyword">if</span> (pkt.pts * av_q2d(in_stream2-&gt;time_base) &gt; max_duration) &#123;</span><br><span class="line">        av_packet_unref(&amp;pkt);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 如果是我们需要的视频流，转换时间基后写入文件</span></span><br><span class="line">    <span class="keyword">if</span> (pkt.stream_index == vedio_stream_indes) &#123;</span><br><span class="line">        pkt.pts = av_rescale_q_rnd(pkt.pts, in_stream2-&gt;time_base, out_stream2-&gt;time_base,</span><br><span class="line">                                   (AV_ROUND_NEAR_INF | AV_ROUND_PASS_MINMAX));</span><br><span class="line">        pkt.dts = av_rescale_q_rnd(pkt.dts, in_stream2-&gt;time_base, out_stream2-&gt;time_base,</span><br><span class="line">                                   (AV_ROUND_NEAR_INF | AV_ROUND_PASS_MINMAX));</span><br><span class="line">        pkt.duration = av_rescale_q(max_duration, in_stream2-&gt;time_base, out_stream2-&gt;time_base);</span><br><span class="line">        pkt.pos = <span class="number">-1</span>;</span><br><span class="line">        pkt.stream_index = stream2;</span><br><span class="line">        av_interleaved_write_frame(ofmt_ctx, &amp;pkt);</span><br><span class="line">        av_packet_unref(&amp;pkt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写尾信息</span></span><br><span class="line">av_write_trailer(ofmt_ctx)；</span><br><span class="line"></span><br><span class="line">ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">END:</span><br><span class="line"><span class="comment">// 释放内存</span></span><br><span class="line"><span class="keyword">if</span> (ifmt_ctx1) &#123;</span><br><span class="line">    avformat_close_input(&amp;ifmt_ctx1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ifmt_ctx2) &#123;</span><br><span class="line">    avformat_close_input(&amp;ifmt_ctx2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ofmt_ctx) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(ofmt-&gt;flags &amp; AVFMT_NOFILE)) &#123;</span><br><span class="line">        avio_closep(&amp;ofmt_ctx-&gt;pb);</span><br><span class="line">    &#125;</span><br><span class="line">    avformat_free_context(ofmt_ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终效果如下，从左到右：输入1、输入2、输出文件。输出文件拿到了输入1的音频、输入2的视频信息，并且时长为输入2的时长。</p><p><img src="/2018/12/07/FFmpeg代码实现最简版本小咖秀/merge1.png" alt=""></p><p>目前只是在做C语言开发，后面会慢慢把重心移到Android平台上，在FFmpeg和Android平台的基础上玩更多有意思的东西。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天代码实现了从两个音视频文件中分别抽取音频、视频数据，并将这两种数据存储在一个新的MP4文件中，文件可以正常播放画面和声音，也就是实现一个最简版本的小咖秀。&lt;/p&gt;
&lt;p&gt;前面几篇博客已经把需要的知识都讲了一遍，代码流程也基本一致，下面的代码看起来也会非常轻松。&lt;/p&gt;

      
    
    </summary>
    
      <category term="FFmpeg" scheme="http://yoursite.com/categories/FFmpeg/"/>
    
    
      <category term="FFmpeg" scheme="http://yoursite.com/tags/FFmpeg/"/>
    
      <category term="音视频" scheme="http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>FFmpeg代码实现视频剪切</title>
    <link href="http://yoursite.com/2018/12/06/FFmpeg%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91/"/>
    <id>http://yoursite.com/2018/12/06/FFmpeg代码实现视频剪辑/</id>
    <published>2018-12-06T04:07:22.000Z</published>
    <updated>2018-12-28T06:58:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>有几天没写FFmpeg代码了，今天趁着有空闲来撸下FFmpeg剪切视频代码，我也是边学习边写，如果有错误，请在评论中指出，互相学习。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>说起来这个功能的实现也很简单，给定一个起始时间、一个结束时间，把视频文件打开，然后把容器中的每条流从起始时间开始，到结束时间为止的数据拷贝到输出流，然后输出流保存为容器，这样就能看到一个剪切后的视频文件了。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h4 id="第一步-定义参数"><a href="#第一步-定义参数" class="headerlink" title="第一步 定义参数"></a>第一步 定义参数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AVFormatContext *ifmt_ctx = <span class="literal">NULL</span>;</span><br><span class="line">AVFormatContext *ofmt_ctx = <span class="literal">NULL</span>;</span><br><span class="line">AVOutputFormat *ofmt = <span class="literal">NULL</span>;</span><br><span class="line">AVPacket pkt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> start_seconds； <span class="comment">//开始时间</span></span><br><span class="line"><span class="keyword">double</span> end_seconds；   <span class="comment">//结束时间</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *in_filename； <span class="comment">//输入文件</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *out_filename；<span class="comment">//输出文件</span></span><br></pre></td></tr></table></figure><h4 id="第二步-初始化上下文"><a href="#第二步-初始化上下文" class="headerlink" title="第二步 初始化上下文"></a>第二步 初始化上下文</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">avformat_open_input(&amp;ifmt_ctx, in_filename, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//本质上调用了avformat_alloc_context、av_guess_format这两个函数，即创建了输出上下文，又根据输出文件后缀生成了最适合的输出容器</span></span><br><span class="line">avformat_alloc_output_context2(&amp;ofmt_ctx, <span class="literal">NULL</span>, <span class="literal">NULL</span>, out_filename); </span><br><span class="line">ofmt = ofmt_ctx-&gt;oformat;</span><br></pre></td></tr></table></figure><h4 id="第三步-创建流及参数拷贝"><a href="#第三步-创建流及参数拷贝" class="headerlink" title="第三步 创建流及参数拷贝"></a>第三步 创建流及参数拷贝</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ifmt_ctx-&gt;nb_streams; i++) &#123;</span><br><span class="line">        AVStream *in_stream = ifmt_ctx-&gt;streams[i];</span><br><span class="line">        AVStream *out_stream = avformat_new_stream(ofmt_ctx, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (!out_stream) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Failed allocating output stream\n"</span>);</span><br><span class="line">            ret = AVERROR_UNKNOWN;</span><br><span class="line">            <span class="keyword">goto</span> end;</span><br><span class="line">        &#125;</span><br><span class="line">        avcodec_parameters_copy(out_stream-&gt;codecpar, in_stream-&gt;codecpar);</span><br><span class="line">        out_stream-&gt;codecpar-&gt;codec_tag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="第四步-打开输出文件"><a href="#第四步-打开输出文件" class="headerlink" title="第四步 打开输出文件"></a>第四步 打开输出文件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">avio_open(&amp;ofmt_ctx-&gt;pb, out_filename, AVIO_FLAG_WRITE);</span><br></pre></td></tr></table></figure><h4 id="第五步-处理、写入数据"><a href="#第五步-处理、写入数据" class="headerlink" title="第五步  处理、写入数据"></a>第五步  处理、写入数据</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写头信息</span></span><br><span class="line">ret = avformat_write_header(ofmt_ctx, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error occurred when opening output file\n"</span>);</span><br><span class="line">    <span class="keyword">goto</span> end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//跳转到指定帧</span></span><br><span class="line">ret = av_seek_frame(ifmt_ctx, <span class="number">-1</span>, start_seconds * AV_TIME_BASE, AVSEEK_FLAG_ANY);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error seek\n"</span>);</span><br><span class="line">        <span class="keyword">goto</span> end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据流数量申请空间，并全部初始化为0</span></span><br><span class="line"><span class="keyword">int64_t</span> *dts_start_from = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int64_t</span>) * ifmt_ctx-&gt;nb_streams);</span><br><span class="line"><span class="built_in">memset</span>(dts_start_from, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int64_t</span>) * ifmt_ctx-&gt;nb_streams);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int64_t</span> *pts_start_from = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int64_t</span>) * ifmt_ctx-&gt;nb_streams);</span><br><span class="line"><span class="built_in">memset</span>(pts_start_from, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int64_t</span>) * ifmt_ctx-&gt;nb_streams);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        AVStream *in_stream, *out_stream;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取数据</span></span><br><span class="line">        ret = av_read_frame(ifmt_ctx, &amp;pkt);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        in_stream = ifmt_ctx-&gt;streams[pkt.stream_index];</span><br><span class="line">        out_stream = ofmt_ctx-&gt;streams[pkt.stream_index];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 时间超过要截取的时间，就退出循环</span></span><br><span class="line">        <span class="keyword">if</span> (av_q2d(in_stream-&gt;time_base) * pkt.pts &gt; end_seconds) &#123;</span><br><span class="line">            av_packet_unref(&amp;pkt);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将截取后的每个流的起始dts 、pts保存下来，作为开始时间，用来做后面的时间基转换</span></span><br><span class="line">        <span class="keyword">if</span> (dts_start_from[pkt.stream_index] == <span class="number">0</span>) &#123;</span><br><span class="line">            dts_start_from[pkt.stream_index] = pkt.dts;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pts_start_from[pkt.stream_index] == <span class="number">0</span>) &#123;</span><br><span class="line">            pts_start_from[pkt.stream_index] = pkt.pts;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 时间基转换</span></span><br><span class="line">        pkt.pts = av_rescale_q_rnd(pkt.pts - pts_start_from[pkt.stream_index], in_stream-&gt;time_base, out_stream-&gt;time_base, AV_ROUND_NEAR_INF | AV_ROUND_PASS_MINMAX);</span><br><span class="line">        pkt.dts = av_rescale_q_rnd(pkt.dts - dts_start_from[pkt.stream_index], in_stream-&gt;time_base,out_stream-&gt;time_base, AV_ROUND_NEAR_INF | AV_ROUND_PASS_MINMAX);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (pkt.pts &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            pkt.pts = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pkt.dts &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            pkt.dts = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pkt.duration = (<span class="keyword">int</span>) av_rescale_q((<span class="keyword">int64_t</span>) pkt.duration, in_stream-&gt;time_base, out_stream-&gt;time_base);</span><br><span class="line">        pkt.pos = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一帧视频播放时间必须在解码时间点之后，当出现pkt.pts &lt; pkt.dts时会导致程序异常，所以我们丢掉有问题的帧，不会有太大影响。</span></span><br><span class="line">        <span class="keyword">if</span> (pkt.pts &lt; pkt.dts) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        ret = av_interleaved_write_frame(ofmt_ctx, &amp;pkt);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error write packet\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        av_packet_unref(&amp;pkt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line"><span class="built_in">free</span>(dts_start_from);</span><br><span class="line"><span class="built_in">free</span>(pts_start_from);</span><br><span class="line"></span><br><span class="line"><span class="comment">//写文件尾信息</span></span><br><span class="line">av_write_trailer(ofmt_ctx);</span><br></pre></td></tr></table></figure><p>整个处理流程就这样了，还是比较简单的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有几天没写FFmpeg代码了，今天趁着有空闲来撸下FFmpeg剪切视频代码，我也是边学习边写，如果有错误，请在评论中指出，互相学习。&lt;/p&gt;
&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h2
      
    
    </summary>
    
      <category term="FFmpeg" scheme="http://yoursite.com/categories/FFmpeg/"/>
    
    
      <category term="FFmpeg" scheme="http://yoursite.com/tags/FFmpeg/"/>
    
      <category term="音视频" scheme="http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
</feed>
