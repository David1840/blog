<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Programmer Liu</title>
  
  <subtitle>一只有崇高理想的的程序猿</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-11-27T06:59:47.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>刘伟</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>FFmpeg常用结构体、方法简介</title>
    <link href="http://yoursite.com/2018/11/23/FFmpeg%E5%B8%B8%E7%94%A8%E7%BB%93%E6%9E%84%E4%BD%93%E3%80%81%E6%96%B9%E6%B3%95%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2018/11/23/FFmpeg常用结构体、方法简介/</id>
    <published>2018-11-23T11:58:59.000Z</published>
    <updated>2018-11-27T06:59:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天先来了解下FFmpeg中我们常用的结构体和方法，防止我们在后面看代码、写代码的时候一脸懵逼。</p><h2 id="常用结构体"><a href="#常用结构体" class="headerlink" title="常用结构体"></a>常用结构体</h2><h3 id="AVFormatContext"><a href="#AVFormatContext" class="headerlink" title="AVFormatContext"></a>AVFormatContext</h3><p>AVFormatContext是音视频数据,也就是音视频文件的一种抽象和封装，该结构体中包含了多路流，包括音频流、视频流、字幕流等，是FFmpeg中一个贯穿全局的数据结构，很多函数都要以它为参数。 </p><p>结构体定义如下（主要参数）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVFormatContext</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AVInputFormat</span> *<span class="title">iformat</span>;</span> <span class="comment">//输入容器格式,用于分流,通过avformat_open_input()设置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AVOutputFormat</span> *<span class="title">oformat</span>;</span> <span class="comment">//输出容器格式,用于混流,必须在avformat_write_header()调用前设置</span></span><br><span class="line">    AVIOContext *pb;  <span class="comment">// I/O 上下文</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> nb_streams; <span class="comment">// 流的总数</span></span><br><span class="line">    AVStream **streams; <span class="comment">//所有流的列表,由avformat_new_stream()创建新的流</span></span><br><span class="line">    <span class="keyword">int64_t</span> duration; <span class="comment">//流的时长</span></span><br><span class="line">    <span class="keyword">int64_t</span> bit_rate; <span class="comment">//流的比特率</span></span><br><span class="line">    <span class="keyword">int64_t</span> probesize; <span class="comment">//从指定容器格式的输入中读取最大数据的大小,要足够起播首帧画面</span></span><br><span class="line">    <span class="keyword">int64_t</span> max_analyze_duration; <span class="comment">//从指定容器格式的输入中读取的最大数据时长</span></span><br><span class="line">    <span class="keyword">enum</span> AVCodecID video_codec_id; <span class="comment">// 视频的codec_id</span></span><br><span class="line">    <span class="keyword">enum</span> AVCodecID audio_codec_id; <span class="comment">// 音频的codec_id</span></span><br><span class="line">    <span class="keyword">enum</span> AVCodecID subtitle_codec_id; <span class="comment">// 字幕的codec_id</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> max_index_size; <span class="comment">// 每条流的最大内存字节数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> max_picture_buffer; <span class="comment">//从设备获取的实时帧缓冲的最大内存大小</span></span><br><span class="line">    AVDictionary *metadata; <span class="comment">// 整个文件的元数据</span></span><br><span class="line">    。。。 实在太多了，以后再慢慢了解吧</span><br><span class="line">&#125;AVFormatContext;</span><br></pre></td></tr></table></figure><h3 id="AVInputFormat"><a href="#AVInputFormat" class="headerlink" title="AVInputFormat"></a>AVInputFormat</h3><p>FFmpeg的解复用器对象，是类似COM接口的数据结构，表示输入文件容器格式，一个文件容器格式对应一个AVInputFormat结构，在程序运行时有多个实例。</p><h3 id="AVStream"><a href="#AVStream" class="headerlink" title="AVStream"></a>AVStream</h3><p>是存储每一个视频/音频流信息的结构体，位于avoformat.h文件中。使用解复用器从容器中解析出不同的流，在FFmpeg中流的对象就是AVStream，保存在AVFormatContext的streams数组中。</p><h3 id="AVCodecContext"><a href="#AVCodecContext" class="headerlink" title="AVCodecContext"></a>AVCodecContext</h3><p>描述编解码器上下文的数据结构，包含众多编解码器需要的参数信息。</p><h3 id="AVPacket"><a href="#AVPacket" class="headerlink" title="AVPacket"></a>AVPacket</h3><p>FFmpeg使用AVPacket来存放编码后的视频帧数据，AVPacket保存了解复用之后、解码之前的数据（仍然是压缩后的数据）和关于这些数据的一些附加信息。AVPacket实际上可用做一个容器，它本身不包含压缩的媒体数据，而是通过data指针引用数据的缓存空间。</p><h3 id="AVCodec"><a href="#AVCodec" class="headerlink" title="AVCodec"></a>AVCodec</h3><p>存储编解码器信息的结构体。</p><h3 id="AVFrame"><a href="#AVFrame" class="headerlink" title="AVFrame"></a>AVFrame</h3><p>用来描述解码出的音视频数据，必须使用av_frame_alloc分配，av_frame_free释放。</p><h3 id="AVIOContext"><a href="#AVIOContext" class="headerlink" title="AVIOContext"></a>AVIOContext</h3><p>文件操作的顶层结构，实现了带缓冲的读写操作。</p><h3 id="URLProtocol"><a href="#URLProtocol" class="headerlink" title="URLProtocol"></a>URLProtocol</h3><p>是FFmpeg操作文件的结构，包括open、close、read、write、seek等操作。</p><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><h3 id="av-register-all"><a href="#av-register-all" class="headerlink" title="av_register_all"></a>av_register_all</h3><p>初始化所有组件，只有调用了该函数，才能使用复用器和编解码器(FFmpeg4.0以上被废弃，不推荐使用，可以不调用)。</p><h3 id="avformat-alloc-context"><a href="#avformat-alloc-context" class="headerlink" title="avformat_alloc_context"></a>avformat_alloc_context</h3><p>AVFormatContext要用avformat_alloc_context()进行初始化，分配内存空间。</p><h3 id="avformat-open-input"><a href="#avformat-open-input" class="headerlink" title="avformat_open_input"></a>avformat_open_input</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avformat_open_input</span><span class="params">(AVFormatContext **ps, <span class="keyword">const</span> <span class="keyword">char</span> *url, AVInputFormat *fmt, AVDictionary **options)</span></span>;</span><br></pre></td></tr></table></figure><p>主要功能是打开一个文件，读取header，不会涉及打开解码器，与之对应的是avformat_close_input函数关闭文件。如果打开文件成功，AVFormatContext  ps就会在函数中初始化完成。</p><h3 id="av-guess-format"><a href="#av-guess-format" class="headerlink" title="av_guess_format"></a>av_guess_format</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AVOutputFormat *<span class="title">av_guess_format</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *short_name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">const</span> <span class="keyword">char</span> *filename,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">const</span> <span class="keyword">char</span> *mime_type)</span></span>;</span><br></pre></td></tr></table></figure><p>从所编译的ffmpeg库支持的muxer中查找与文件名有关联的容器类型。</p><h3 id="avformat-new-stream"><a href="#avformat-new-stream" class="headerlink" title="avformat_new_stream"></a>avformat_new_stream</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AVStream *<span class="title">avformat_new_stream</span><span class="params">(AVFormatContext *s, <span class="keyword">const</span> AVCodec *c)</span></span>;</span><br></pre></td></tr></table></figure><p>在 AVFormatContext 中创建新的 Stream 流通道。</p><h3 id="avio-open"><a href="#avio-open" class="headerlink" title="avio_open"></a>avio_open</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avio_open</span><span class="params">(AVIOContext **s, <span class="keyword">const</span> <span class="keyword">char</span> *url, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><p>用于打开FFmpeg的输入/输出文件。</p><h3 id="av-find-best-stream"><a href="#av-find-best-stream" class="headerlink" title="av_find_best_stream"></a>av_find_best_stream</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">av_find_best_stream</span><span class="params">(AVFormatContext *ic,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">enum</span> AVMediaType type,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">int</span> wanted_stream_nb,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">int</span> related_stream,</span></span></span><br><span class="line"><span class="function"><span class="params">                        AVCodec **decoder_ret,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><p>在文件中找到“最好”的用户所期望的流</p><h3 id="av-read-frame"><a href="#av-read-frame" class="headerlink" title="av_read_frame"></a>av_read_frame</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">av_read_frame</span><span class="params">(AVFormatContext *s, AVPacket *pkt)</span></span>;</span><br></pre></td></tr></table></figure><p>读取码流中的若干音频帧或者1帧视频。</p><h3 id="av-write-frame"><a href="#av-write-frame" class="headerlink" title="av_write_frame"></a>av_write_frame</h3><p>FFmpeg调用<code>avformat_write_header</code>函数写头部信息，<code>av_write_frame</code>函数写1帧数据，调用<code>av_write_trailer</code>写尾部信息。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天先来了解下FFmpeg中我们常用的结构体和方法，防止我们在后面看代码、写代码的时候一脸懵逼。&lt;/p&gt;
&lt;h2 id=&quot;常用结构体&quot;&gt;&lt;a href=&quot;#常用结构体&quot; class=&quot;headerlink&quot; title=&quot;常用结构体&quot;&gt;&lt;/a&gt;常用结构体&lt;/h2&gt;&lt;h3 i
      
    
    </summary>
    
      <category term="音视频" scheme="http://yoursite.com/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="音视频" scheme="http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="FFmpeg" scheme="http://yoursite.com/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>FFmpeg实现简单直播系统</title>
    <link href="http://yoursite.com/2018/11/23/FFmpeg%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2018/11/23/FFmpeg实现简单直播系统/</id>
    <published>2018-11-23T01:48:29.000Z</published>
    <updated>2018-11-23T02:43:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>现在市面上的各种直播应用越来越多，直播相关技术也成为最火热的技术方向之一，所以今天就用FFpmeg来实现一个简单的直播系统。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>FFmpeg之前也看到它有直播推流和直播拉流的命令，那这个流推到哪里?又要从哪里拉?这个时候就需要我们的关键角色–<strong>流媒体服务器</strong>。</p><p>我使用Nginx服务，并配置好RTMP服务。</p><p><code>brew install nginx-full --with-rtmp-module</code></p><p>等安装完成后修改配置文件</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">vi <span class="meta-keyword">/usr/</span>local<span class="meta-keyword">/etc/</span>nginx/nginx.conf</span><br><span class="line"></span><br><span class="line">添加如下:</span><br><span class="line"></span><br><span class="line"><span class="class">rtmp </span>&#123;</span><br><span class="line">      server&#123;</span><br><span class="line"></span><br><span class="line">            listen <span class="number">1935</span>; <span class="comment">//端口号</span></span><br><span class="line">            chunk_size <span class="number">4000</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//指定流应用</span></span><br><span class="line">            application live</span><br><span class="line">           &#123;</span><br><span class="line">                 live on;</span><br><span class="line">                 record off;</span><br><span class="line">                 allow play all;</span><br><span class="line">           &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后重启服务</p><p><code>nginx -s reload</code></p><h2 id="直播"><a href="#直播" class="headerlink" title="直播"></a>直播</h2><p>环境Ok了，接下来就可以试一下推流拉流直播了。</p><p>首先可以推一个视频</p><p><code>ffmpeg -re -i out.mp4 -c copy -f flv rtmp://127.0.0.1:1935/live/room</code></p><p>使用FFplay播放</p><p><code>ffplay rtmp://localhost:1935/live/room</code></p><p><img src="/2018/11/23/FFmpeg实现简单直播系统/ffmpeglive.png" alt=""></p><p>图片左侧是推流，右侧ffplay拉流，中间为ffplay播放的视频。</p><p>然后可以试着直播下我的桌面:</p><p><code>ffmpeg -f avfoundation -i &quot;1&quot; -vcodec libx264 -preset ultrafast -acodec libfaac -f flv rtmp://127.0.0.1:1935/live/room</code></p><p>都是同样的原理，很简单，赶紧去试一下吧!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现在市面上的各种直播应用越来越多，直播相关技术也成为最火热的技术方向之一，所以今天就用FFpmeg来实现一个简单的直播系统。&lt;/p&gt;
&lt;h2 id=&quot;环境搭建&quot;&gt;&lt;a href=&quot;#环境搭建&quot; class=&quot;headerlink&quot; title=&quot;环境搭建&quot;&gt;&lt;/a&gt;环境搭建
      
    
    </summary>
    
      <category term="音视频" scheme="http://yoursite.com/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="音视频" scheme="http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="FFmpeg" scheme="http://yoursite.com/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>FFmpeg常用命令</title>
    <link href="http://yoursite.com/2018/11/22/FFmpeg%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/11/22/FFmpeg常用命令/</id>
    <published>2018-11-22T05:43:30.000Z</published>
    <updated>2018-11-22T11:53:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>FFmpeg 是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序。本文将简单介绍FFmpeg库的基本目录结构及其功能，然后会介绍一些常用的FFmpeg命令，了解FFmpeg到底能做些什么。</p><h3 id="音视频基本处理流程"><a href="#音视频基本处理流程" class="headerlink" title="音视频基本处理流程"></a>音视频基本处理流程</h3><p>对于音视频的处理基本遵循下面的流程：</p><p><img src="/2018/11/22/FFmpeg常用命令/ffmpeg23.png" alt=""></p><h3 id="FFmpeg目录及功能"><a href="#FFmpeg目录及功能" class="headerlink" title="FFmpeg目录及功能"></a>FFmpeg目录及功能</h3><table><thead><tr><th>libavcodec</th><th>提供了一系列编解码器的实现</th></tr></thead><tbody><tr><td>libavcodec</td><td>用于各种音视频封装格式的生成和解析，包括获取解码所需信息以生成解码上下文结构和读取音视频帧等功能</td></tr><tr><td>libavutil</td><td>包含一些公共的工具函数</td></tr><tr><td>libavutil</td><td>提供了各种音视频过滤器</td></tr><tr><td>libavdevice</td><td>提供了各种音视频过滤器</td></tr><tr><td>libswscale</td><td>提供了视频场景比例缩放、色彩映射转换功能</td></tr><tr><td>libswresample</td><td>实现了混音和重采样</td></tr></tbody></table><h3 id="信息查询命令"><a href="#信息查询命令" class="headerlink" title="信息查询命令"></a>信息查询命令</h3><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>FFmpeg -version</td><td>显示版本</td></tr><tr><td>-formats</td><td>显示可用的格式（包括设备）</td></tr><tr><td>-demuxers</td><td>显示可用的demuxers</td></tr><tr><td>-muxers</td><td>显示可用的muxers</td></tr><tr><td>-devices</td><td>显示可用的设备</td></tr><tr><td>-codecs</td><td>显示已知的所有编解码器</td></tr><tr><td>-decoders</td><td>显示可用的解码器</td></tr><tr><td>-encoders</td><td>显示所有可用的编码器</td></tr><tr><td>-bsfs</td><td>显示可用的比特流filter</td></tr><tr><td>-protocols</td><td>显示可用的协议</td></tr><tr><td>-filters</td><td>显示可用的过滤器</td></tr><tr><td>-pix_fmts</td><td>显示可用的像素格式</td></tr><tr><td>-sample_fmts</td><td>显示可用的采样格式</td></tr><tr><td>-layouts</td><td>显示channel名称和标准channel布局</td></tr><tr><td>-colors</td><td>显示识别的颜色名称</td></tr></tbody></table><h2 id="设备列表"><a href="#设备列表" class="headerlink" title="设备列表"></a>设备列表</h2><p><code>ffmpeg -f avfoundation -list_devices true -i “”</code></p><p>查看Mac上支持的设备列表</p><h2 id="录屏"><a href="#录屏" class="headerlink" title="录屏"></a>录屏</h2><p><code>ffmpeg -f avfoundation -i 1 -r 30 out.yuv</code></p><p>-f 指定使用 avfoundation 采集数据。<br>-i 指定从哪儿采集数据，它是一个文件索引号。<br>-r 指定帧率。`</p><h2 id="录屏-声音"><a href="#录屏-声音" class="headerlink" title="录屏+声音"></a>录屏+声音</h2><p><code>ffmpeg -f avfoundation -i 1:0 -r 29.97 -c:v libx264 -crf 0 -c:a libfdk_aac -profile:a aac_he_v2 -b:a 32k out.flv</code></p><p>-i 1:0 冒号前面的 “1” 代表的屏幕索引号。冒号后面的”0”代表的声音索相号。<br>-c:v 与参数 -vcodec 一样，表示视频编码器。c 是 codec 的缩写，v 是video的缩写。<br>-crf 是 x264 的参数。 0 表式无损压缩。<br>-c:a 与参数 -acodec 一样，表示音频编码器。<br>-profile 是 fdk_aac 的参数。 aac_he_v2 表式使用 AAC_HE v2 压缩数据。<br>-b:a 指定音频码率。 b 是 bitrate的缩写, a是 audio的缩与。</p><h2 id="抽取音频和视频"><a href="#抽取音频和视频" class="headerlink" title="抽取音频和视频"></a>抽取音频和视频</h2><p><code>ffmpeg -i input_file -vcodec copy -an output_file_video　　//分离视频流</code><br><code>ffmpeg -i input_file -acodec copy -vn output_file_audio　　//分离音频流</code></p><p>vcodec: 指定视频编码器，copy 指明只拷贝，不做编解码。</p><p>an: a 代表视频，n 代表 no 也就是无音频的意思。</p><p>acodec: 指定音频编码器，copy 指明只拷贝，不做编解码。</p><p>vn: v 代表视频，n 代表 no 也就是无视频的意思。</p><h2 id="转格式"><a href="#转格式" class="headerlink" title="转格式"></a>转格式</h2><p><code>ffmpeg -i test.mp4 -vcodec copy -acodec copy test.flv</code></p><p>音频、视频都直接 copy，只是将 mp4 的封装格式转成了flv</p><h2 id="音视频合并"><a href="#音视频合并" class="headerlink" title="音视频合并"></a>音视频合并</h2><p><code>ffmpeg -i out.h264 -i out.aac -vcodec copy -acodec copy out.mp4</code></p><p>视频和音频直接拷贝，合成一个mp4格式文件</p><h2 id="YUV转H264"><a href="#YUV转H264" class="headerlink" title="YUV转H264"></a>YUV转H264</h2><p><code>ffmpeg -f rawvideo -pix_fmt yuv420p -s 320x240 -r 30 -i out.yuv -c:v libx264 -f rawvideo out.h264</code></p><h2 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h2><p>首先创建一个 inputs.txt 文件，文件内容如下：<br>file ‘1.flv’<br>file ‘2.flv’<br>file ‘3.flv’<br>然后执行下面的命令：<br><code>ffmpeg -f concat -i inputs.txt -c copy output.flv</code></p><h2 id="视频剪切"><a href="#视频剪切" class="headerlink" title="视频剪切"></a>视频剪切</h2><p><code>ffmpeg -ss 0:1:30 -t 0:0:20 -i input.avi -vcodec copy -acodec copy output.avi //剪切视频</code><br>-ss 开始时间<br>-t 持续时间</p><h2 id="视频缩小一倍"><a href="#视频缩小一倍" class="headerlink" title="视频缩小一倍"></a>视频缩小一倍</h2><p><code>ffmpeg -i out.mp4 -vf scale=iw/2:-1 scale.mp4</code><br>-vf scale 指定使用简单过滤器 scale，iw/2:-1 中的 iw 指定按整型取视频的宽度。 -1 表示高度随宽度一起变化。</p><h2 id="视频图片互转"><a href="#视频图片互转" class="headerlink" title="视频图片互转"></a>视频图片互转</h2><p><code>ffmpeg -i test.flv -r 1 -f image2 image-%3d.jpeg  //视频转JPEG</code><br><code>ffmpeg -i out.mp4 -ss 00:00:00 -t 10 out.gif  //视频转gif</code><br><code>ffmpeg -f image2 -i image-%3d.jpeg images.mp4 //图片转视频</code></p><h2 id="添加水印"><a href="#添加水印" class="headerlink" title="添加水印"></a>添加水印</h2><p><code>ffmpeg -i out.mp4 -vf “movie=logo.png,scale=64:48[watermask];[in][watermask] overlay=30:10 [out]” water.mp4</code></p><p>-vf中的 movie 指定logo位置。scale 指定 logo 大小。overlay 指定 logo 摆放的位置</p><h2 id="直播推流"><a href="#直播推流" class="headerlink" title="直播推流"></a>直播推流</h2><p><code>ffmpeg -re -i out.mp4 -c copy -f flv rtmp://server/live/streamName</code></p><h2 id="直播拉流保存"><a href="#直播拉流保存" class="headerlink" title="直播拉流保存"></a>直播拉流保存</h2><p><code>ffmpeg -i rtmp://server/live/streamName -c copy dump.flv</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;FFmpeg 是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序。本文将简单介绍FFmpeg库的基本目录结构及其功能，然后会介绍一些常用的FFmpeg命令，了解FFmpeg到底能做些什么。&lt;/p&gt;
&lt;h3 id=&quot;音视频基本处理流程&quot;&gt;&lt;a href=
      
    
    </summary>
    
      <category term="音视频" scheme="http://yoursite.com/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="音视频" scheme="http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="FFmpeg" scheme="http://yoursite.com/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>FFmpeg的下载,编译和安装</title>
    <link href="http://yoursite.com/2018/11/21/Mac%E4%B8%8BFFmpeg%E7%9A%84%E4%B8%8B%E8%BD%BD-%E7%BC%96%E8%AF%91%E5%92%8C%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2018/11/21/Mac下FFmpeg的下载-编译和安装/</id>
    <published>2018-11-21T03:52:21.000Z</published>
    <updated>2018-11-21T04:12:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>FFmpeg的下载,编译和安装，本文所有操作均在Mac系统下完成。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git clone https:<span class="string">//git.ffmpeg.org/ffmpeg.git</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">cd</span> ffmpeg</span><br><span class="line"></span><br><span class="line">make &amp;&amp; make install </span><br><span class="line"></span><br><span class="line"><span class="string">./configure</span> <span class="params">--cc=/usr/bin/clang</span> <span class="params">--prefix=/usr/local/ffmpeg</span> <span class="params">--enable-gpl</span> <span class="params">--enable-nonfree</span> <span class="params">--enable-libfdk-aac</span> <span class="params">--enable-libx264</span> <span class="params">--enable-libmp3lame</span> <span class="params">--enable-libx265</span>  <span class="params">--enable-filter=delogo</span> <span class="params">--enable-debug</span> <span class="params">--disable-optimizations</span> <span class="params">--enable-libspeex</span> <span class="params">--enable-videotoolbox</span> <span class="params">--enable-shared</span> <span class="params">--enable-pthreads</span> <span class="params">--enable-version3</span> <span class="params">--enable-hardcoded-tables</span> <span class="params">--host-cflags=</span> <span class="params">--host-ldflags=</span></span><br></pre></td></tr></table></figure><p>上面的指令执行结束后在<code>/usr/local/ffmpeg</code>目录下就会生成编译好的FFmpeg库。</p><p><img src="/2018/11/21/Mac下FFmpeg的下载-编译和安装/ffmpegInstall.png" alt=""></p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">补充缺少的库</span><br><span class="line">brew <span class="keyword">install</span> speex</span><br><span class="line">brew <span class="keyword">install</span> x264</span><br><span class="line">brew <span class="keyword">install</span> x265</span><br><span class="line">sudo make &amp;&amp; make <span class="keyword">install</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">可能会出现/usr/<span class="keyword">local</span>/ffmpeg没有权限，可以自己新建一个并修改所有者</span><br><span class="line"></span><br><span class="line">sudo mkdir /usr/<span class="keyword">local</span>/ffmpeg</span><br><span class="line">sudo chown -R ***: ./ffmpeg</span><br></pre></td></tr></table></figure><p>OK！Mac下就是这么简单，然后就可以去玩一下FFmpeg的指令了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;FFmpeg的下载,编译和安装，本文所有操作均在Mac系统下完成。&lt;/p&gt;
&lt;figure class=&quot;highlight jboss-cli&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;
      
    
    </summary>
    
      <category term="音视频" scheme="http://yoursite.com/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="FFmpeg" scheme="http://yoursite.com/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>音视频基础概念</title>
    <link href="http://yoursite.com/2018/11/19/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <id>http://yoursite.com/2018/11/19/音视频基础概念/</id>
    <published>2018-11-19T11:55:56.000Z</published>
    <updated>2018-11-21T03:36:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>Android开发工作两年，真的是感觉Android应用层开发没什么前景了，于是打算在网络安全，智能硬件，音视频这几个方向发展，考虑了一段时间，最终决定选择音视频。理由就不说了，既然选择了就要好好学习了，今天就开始音视频的第一篇博客，从一些音视频的基础知识开始。</p><h4 id="硬解和软解"><a href="#硬解和软解" class="headerlink" title="硬解和软解"></a>硬解和软解</h4><p>视频解码分为硬解和软解，所谓“软解”就是通过软件让 CPU 进行视频解码处理；而“硬解”是指不依赖于 CPU，通过专用的设备（子卡）单独完成视频解码，比如曾经的 VCD/DVD 解压卡、视频压缩卡都被冠以“硬解”的称号。现在实现高清硬解不需要额外的子卡，也不需要额外的投入，因为硬解码模块被整合在了 GPU 内部，而目前主流的显卡（包括整合显卡）都能支持硬解码。</p><p> “硬解”其实更需要软件的支持，只是基本不需要 CPU 参与运算，从而为系统节约了很多资源开销。</p><h4 id="RGB-和-YUV"><a href="#RGB-和-YUV" class="headerlink" title="RGB 和 YUV"></a>RGB 和 YUV</h4><p>RGB 指的是红绿蓝，应用还是很广泛的，比如显示器显示， bmp 文件格式中的像素值等；而 yuv 主要指亮度和两个色差信号，被称为 luminance 和 chrominance 他们的转化关系可以自己去查一下，我们视频里面基本上都是用yuv格式。</p><p>YUV文件格式又分很多种，如果算上存储格式，就更多了，比如 yuv444、 yuv422、 yuv411、 yuv420 等等，视频压缩用到的是 420 格式，这是 因为人眼对亮度更敏感些，对色度相对要差些。</p><h4 id="帧-Frame"><a href="#帧-Frame" class="headerlink" title="帧 Frame"></a>帧 Frame</h4><p>简单的理解帧就是为视频或者动画中的每一张画面，而视频和动画特效就是由无数张画面组合而成，每一张画面都是一帧。</p><h4 id="帧数-Frames"><a href="#帧数-Frames" class="headerlink" title="帧数 Frames"></a>帧数 Frames</h4><p>帧数其实就是为帧生成数量的简称，可以解释为静止画面的数量</p><h4 id="帧率-Frame-Rate"><a href="#帧率-Frame-Rate" class="headerlink" title="帧率 Frame Rate"></a>帧率 Frame Rate</h4><p>帧率(Frame rate) = 帧数(Frames)/时间(Time)，单位为帧每秒(f/s, frames per second, fps)</p><p>帧率是用于测量显示帧数的量度，测量单位为“每秒显示帧数”（ Frame per Second， FPS）或“赫兹”（ Hz），一般来说 FPS 用于描述视频、电子绘图或游戏每秒播放多少幀。</p><h4 id="FPS（-Frame-per-Second）每秒显示帧数"><a href="#FPS（-Frame-per-Second）每秒显示帧数" class="headerlink" title="FPS（ Frame per Second）每秒显示帧数"></a>FPS（ Frame per Second）每秒显示帧数</h4><p>FPS 是图像领域中的定义，是指画面每秒传输帧数，通俗来讲就是指动画或视频的画面数。 FPS 是测量用于保存、显示动态视频的信息数量。每秒钟帧数愈多，所显示的动作就会愈流畅。</p><p><img src="/2018/11/19/音视频基础概念/FPS-Demo.gif" alt=""></p><h4 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h4><p>指视频成像产品所形成的图像大小或尺寸</p><h4 id="刷新率"><a href="#刷新率" class="headerlink" title="刷新率"></a>刷新率</h4><p>屏幕每秒画面被刷新的次数，分为垂直刷新率和水平刷新率，一般我们提到的都是指垂直刷新率，以赫兹(Hz)为单位，刷新率越高，图像就越稳定，图像显示就越自然清晰。</p><h4 id="编码格式"><a href="#编码格式" class="headerlink" title="编码格式"></a>编码格式</h4><p>编码的目的是压缩数据量，采用编码算法压缩冗余数据。常用的编码格式有:</p><ul><li>MPEG(MPEG-2  MPEG-4)</li><li>H.26X(H.263  H.264/AVC H.265/HEVC)<h4 id="码率"><a href="#码率" class="headerlink" title="码率"></a>码率</h4></li></ul><p>也就是比特率，比特率是单位时间播放连续的媒体(如压缩的音频和视频)的比特数量。比特率越高，带宽消耗得越多。</p><h4 id="视频帧"><a href="#视频帧" class="headerlink" title="视频帧"></a>视频帧</h4><p>常见的视频帧有I、P、B帧。</p><ul><li>I帧关键帧，采用帧内压缩技术</li><li>P帧向前参考帧，表示这一帧与上一帧的差别，属于帧间压缩技术</li><li>B帧表示双向参考帧，压缩时既参考前一帧也参考后一帧，帧间压缩技术</li></ul><p>一个 I 帧可以不依赖其他帧就解码出一幅完整的图像，而 P 帧、B 帧不行。P 帧需要依赖视频流中排在它前面的帧才能解码出图像。B 帧则需要依赖视频流中排在它前面或后面的帧才能解码出图像。</p><h4 id="GOP"><a href="#GOP" class="headerlink" title="GOP"></a>GOP</h4><p>GOP即Group of picture（图像组），指两个I帧之间的距离，Reference（参考周期）指两个P帧之间的距离。一个I帧所占用的字节数大于一个P帧，一个P帧所占用的字节数大于一个B帧。所以在码率不变的前提下，GOP值越大，P、B帧的数量会越多，平均每个I、P、B帧所占用的字节数就越多，也就更容易获取较好的图像质量；Reference越大，B帧的数量越多，同理也更容易获得较好的图像质量。</p><p><img src="/2018/11/19/音视频基础概念/gop.png" alt=""></p><h4 id="DTS和PTS"><a href="#DTS和PTS" class="headerlink" title="DTS和PTS"></a>DTS和PTS</h4><ul><li>DTS: Decode Time Stamp,主要用于标示读入内存的比特流在什么时候开始送入解码器中进行解码。</li><li>PTS: Presentation Time Stamp,主要用于度量解码后的视频帧什么时候被显示出来。</li></ul><p>由于B帧需要前后的帧才能解出图像，所以可能一个视频中帧的显示顺序是I B B P，但我们在解码B帧时需要P帧的信息，所以在传输的视频流中的顺序是I P B B。这时候就体现出每帧都有 DTS 和 PTS 的作用了。DTS 告诉我们该按什么顺序解码这几帧图像，PTS 告诉我们该按什么顺序显示这几帧图像。</p><p>PTS:    1 4 2 3</p><p>DTS:    1 2 3 4</p><p>Stream: I P B B</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Android开发工作两年，真的是感觉Android应用层开发没什么前景了，于是打算在网络安全，智能硬件，音视频这几个方向发展，考虑了一段时间，最终决定选择音视频。理由就不说了，既然选择了就要好好学习了，今天就开始音视频的第一篇博客，从一些音视频的基础知识开始。&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="音视频" scheme="http://yoursite.com/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="音视频" scheme="http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>Netty学习(一)</title>
    <link href="http://yoursite.com/2018/08/28/Netty%E5%AD%A6%E4%B9%A0-%E4%B8%80/"/>
    <id>http://yoursite.com/2018/08/28/Netty学习-一/</id>
    <published>2018-08-28T11:25:06.000Z</published>
    <updated>2018-11-19T05:12:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前有做过消息推送相关的应用，使用的Netty框架，一直对这个框架非常感兴趣，也学习了一些它的原理，但感觉还是不够，所以想从今天开始对Netty框架写一个系列的使用及原理学习的博客，提升自己，也希望对看到这篇博客的朋友有所帮助，欢迎大家一起讨论。</p><blockquote><p>我一直从事Android开发岗位，后台知识是自学，没有真正参加一个后台项目，所以在文中后台开发比较简单，如有问题欢迎指出，共同学习。</p></blockquote><p>今天写第一篇博客，还是先从Netty框架的使用开始，我自己做了一个easyIM的简单Demo，可以实现简单的聊天功能，使用Protocol Buffer传输数据，以后会继续完善它的功能。</p><p>服务端代码地址 <a href="https://github.com/David1840/easyimServer" target="_blank" rel="noopener">Github/easyImServer</a></p><p>客户端代码地址 <a href="https://github.com/David1840/easyim" target="_blank" rel="noopener">Github/easyIm</a></p><h2 id="一、服务端"><a href="#一、服务端" class="headerlink" title="一、服务端"></a>一、服务端</h2><p>使用SpringBoot搭建的后台服务，比较简单。</p><h4 id="创建服务端主逻辑"><a href="#创建服务端主逻辑" class="headerlink" title="创建服务端主逻辑"></a>创建服务端主逻辑</h4><figure class="highlight pony"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">start</span>() &#123;</span></span><br><span class="line"><span class="function">        <span class="title">val</span> <span class="title">boss</span> = <span class="title">NioEventLoopGroup</span>() <span class="comment">//用于处理服务器端接收客户端连接</span></span></span><br><span class="line"><span class="function">        <span class="title">val</span> <span class="title">worker</span> = <span class="title">NioEventLoopGroup</span>() <span class="comment">//进行网络通信（读写）</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">try</span> &#123;</span></span><br><span class="line"><span class="function">            <span class="title">val</span> <span class="title">port</span> = <span class="title">nettyConfig</span>.<span class="title">port</span>  <span class="comment">//配置文件中配置端口</span></span></span><br><span class="line"><span class="function">            <span class="title">val</span> <span class="title">bootStrap</span> = <span class="title">ServerBootstrap</span>()   <span class="comment">//辅助工具类，用于服务器通道配置</span></span></span><br><span class="line"><span class="function">            <span class="title">bootStrap</span>.<span class="title">group</span>(boss, worker)      <span class="comment">//绑定两个线程组</span></span></span><br><span class="line"><span class="function">                    .<span class="title">channel</span>(<span class="type">NioServerSocketChannel</span>::class.java) <span class="comment">//指定NIO的模式</span></span></span><br><span class="line"><span class="function">                    .<span class="title">childHandler</span>(<span class="type">ProtocolPipeline</span>())            <span class="comment">//配置具体的数据处理方式</span></span></span><br><span class="line"><span class="function">                    .<span class="title">option</span>(<span class="type">ChannelOption</span>.<span class="type">SO_BACKLOG</span>, <span class="number">1024</span>)          <span class="comment">//设置TCP缓冲区</span></span></span><br><span class="line"><span class="function">                    .<span class="title">option</span>(<span class="type">ChannelOption</span>.<span class="type">SO_SNDBUF</span>, <span class="number">32</span> * <span class="number">1024</span>) <span class="comment">//设置发送数据缓冲大小</span></span></span><br><span class="line"><span class="function">                    .<span class="title">option</span>(<span class="type">ChannelOption</span>.<span class="type">SO_RCVBUF</span>, <span class="number">32</span> * <span class="number">1024</span>) <span class="comment">//设置接受数据缓冲大小</span></span></span><br><span class="line"><span class="function">                    .<span class="title">childOption</span>(<span class="type">ChannelOption</span>.<span class="type">SO_KEEPALIVE</span>, true)  <span class="comment">//保持连接</span></span></span><br><span class="line"><span class="function">                    .<span class="title">childOption</span>(<span class="type">ChannelOption</span>.<span class="type">TCP_NODELAY</span>, true)   <span class="comment">//禁用Nagle算法，降低延迟</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">            <span class="title">val</span> <span class="title">future</span> = <span class="title">bootStrap</span>.<span class="title">bind</span>(port).<span class="title">sync</span>() </span></span><br><span class="line"><span class="function">            <span class="title">logger</span>.<span class="title">info</span>("server start finish,the port is $port")</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">            <span class="title">future</span>.<span class="title">channel</span>().<span class="title">closeFuture</span>().<span class="title">sync</span>()</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        &#125; <span class="title">catch</span> (e: <span class="type">InterruptedException</span>) &#123;</span></span><br><span class="line"><span class="function">            <span class="title">logger</span>.<span class="title">error</span>("server start error $&#123;e.message.toString()&#125;")</span></span><br><span class="line"><span class="function">        &#125; <span class="title">finally</span> &#123;</span></span><br><span class="line"><span class="function">            <span class="title">boss</span>.<span class="title">shutdownGracefully</span>()</span></span><br><span class="line"><span class="function">            <span class="title">worker</span>.<span class="title">shutdownGracefully</span>()</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br></pre></td></tr></table></figure><h4 id="ProtocolPipeline数据处理"><a href="#ProtocolPipeline数据处理" class="headerlink" title="ProtocolPipeline数据处理"></a>ProtocolPipeline数据处理</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProtocolPipeline</span> : <span class="type">ChannelInitializer</span>&lt;<span class="type">SocketChannel</span>&gt;</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">initChannel</span><span class="params">(ch: <span class="type">SocketChannel</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> pipeline = ch.pipeline()</span><br><span class="line"></span><br><span class="line">        pipeline.addLast(<span class="string">"send heartbeat"</span>, IdleStateHandler(<span class="number">60</span>, <span class="number">0</span>, <span class="number">0</span>, TimeUnit.SECONDS)) <span class="comment">//心跳机制，读空闲，60S</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用Protobuf，客户端和服务端必须保持一致</span></span><br><span class="line">        pipeline.addLast(ProtobufVarint32FrameDecoder())</span><br><span class="line">        pipeline.addLast(<span class="string">"proto decoder"</span>, ProtobufDecoder(IMessage.Protocol.getDefaultInstance()))</span><br><span class="line">        pipeline.addLast(ProtobufVarint32LengthFieldPrepender())</span><br><span class="line">        pipeline.addLast(<span class="string">"proto encoder"</span>, ProtobufEncoder())</span><br><span class="line">        pipeline.addLast(ServerHandler()) <span class="comment">//接收到数据后的处理逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="传输数据"><a href="#传输数据" class="headerlink" title="传输数据"></a>传输数据</h4><p>数据使用protobuf，</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto2"</span>;</span><br><span class="line"></span><br><span class="line">message Protocol &#123;</span><br><span class="line">    optional ContentType contentType = <span class="number">1</span>;  <span class="comment">//类型</span></span><br><span class="line">    optional bytes content = <span class="number">2</span>;  <span class="comment">//内容</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据类型</span></span><br><span class="line">enum ContentType &#123;</span><br><span class="line">    Register_INFO = <span class="number">0</span>;</span><br><span class="line">    Register_UUID = <span class="number">1</span>;</span><br><span class="line">    Message_INFO = <span class="number">2</span>;</span><br><span class="line">    HEART_BEAT = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送给所有人还是发给一个人</span></span><br><span class="line">enum MessageType &#123;</span><br><span class="line">    ALL = <span class="number">0</span>;</span><br><span class="line">    ONE = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册，客户端发给服务端</span></span><br><span class="line">message Register &#123;</span><br><span class="line">    optional <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册返回，服务端发给客户端</span></span><br><span class="line">message RegisterUUID &#123;</span><br><span class="line">    optional <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">    optional <span class="type">string</span> UUID = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息类</span></span><br><span class="line">message Message &#123;</span><br><span class="line">    optional MessageType type = <span class="number">1</span>; <span class="comment">//个人还是全部</span></span><br><span class="line">    required <span class="type">string</span> uuid = <span class="number">2</span>;    <span class="comment">//如果发送给个人，此项必填</span></span><br><span class="line">    optional <span class="type">string</span> message = <span class="number">3</span>; <span class="comment">//消息具体内容</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端发送给服务端心跳包</span></span><br><span class="line">message HeartBeat_Ping&#123;</span><br><span class="line">    required <span class="type">string</span> time = <span class="number">1</span>;</span><br><span class="line">    required <span class="type">string</span> uuid = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务端返回客户端心跳包</span></span><br><span class="line">message HeartBeat_Pong&#123;</span><br><span class="line">    required <span class="type">string</span> time = <span class="number">1</span>;</span><br><span class="line">    required <span class="type">string</span> uuid = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ServerHandler处理逻辑"><a href="#ServerHandler处理逻辑" class="headerlink" title="ServerHandler处理逻辑"></a>ServerHandler处理逻辑</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServerHandler</span> : <span class="type">ChannelInboundHandlerAdapter</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> logger = LoggerFactory.getLogger(ServerHandler::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 心跳丢失计数器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> counter: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Throws(Exception::class)</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">channelActive</span><span class="params">(ctx: <span class="type">ChannelHandlerContext</span>)</span></span> &#123;</span><br><span class="line">        logger.info(<span class="string">"有人加入了！"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">channelInactive</span><span class="params">(ctx: <span class="type">ChannelHandlerContext</span>)</span></span> &#123;</span><br><span class="line">        logger.info(<span class="string">"有人退出"</span>)</span><br><span class="line">        <span class="keyword">super</span>.channelInactive(ctx)</span><br><span class="line">        ChannelMapController.removeByChannle(ctx.channel())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">userEventTriggered</span><span class="params">(ctx: <span class="type">ChannelHandlerContext</span>, evt: <span class="type">Any</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (evt <span class="keyword">is</span> IdleStateEvent) &#123;</span><br><span class="line">            <span class="keyword">if</span> (counter &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="comment">// 连续丢失3个心跳包 (断开连接)</span></span><br><span class="line">                ctx.channel()?.close()?.sync()</span><br><span class="line">                ChannelMapController.removeByChannle(ctx.channel())</span><br><span class="line">                logger.info(<span class="string">"已与Client断开连接"</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                counter++</span><br><span class="line">                logger.info(<span class="string">"丢失了第 <span class="variable">$counter</span> 个心跳包"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">channelRead</span><span class="params">(ctx: <span class="type">ChannelHandlerContext</span>, msg: <span class="type">Any</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> protoMsg = msg <span class="keyword">as</span> IMessage.Protocol  <span class="comment">//解析Protocol</span></span><br><span class="line">        <span class="keyword">val</span> contentType = protoMsg.contentType</span><br><span class="line">        <span class="keyword">if</span> (contentType == IMessage.ContentType.HEART_BEAT) &#123;</span><br><span class="line">            counter = <span class="number">0</span></span><br><span class="line">            logger.info(<span class="string">"收到心跳包"</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            handlerMessage(ctx, msg)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">handlerMessage</span><span class="params">(ctx: <span class="type">ChannelHandlerContext</span>, msg: <span class="type">IMessage</span>.<span class="type">Protocol</span>)</span></span> &#123;</span><br><span class="line">        counter = <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> contentType = msg.contentType</span><br><span class="line">        <span class="keyword">when</span> (contentType) &#123;</span><br><span class="line">            IMessage.ContentType.Message_INFO -&gt; &#123;</span><br><span class="line">                <span class="keyword">val</span> message: IMessage.Message = IMessage.Message.parseFrom(msg.content)</span><br><span class="line">                <span class="keyword">if</span> (message.type == IMessage.MessageType.ALL) &#123;</span><br><span class="line">                    logger.info(<span class="string">"收到全员广播消息: <span class="subst">$&#123;message.message&#125;</span>"</span>)</span><br><span class="line">                    ChannelMapController.sendMsgToAll(ProtocolFactory.getMessage(message.message, IMessage.MessageType.ONE, <span class="string">""</span>), ctx.channel())</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (message.type == IMessage.MessageType.ONE) &#123;</span><br><span class="line">                    logger.info(<span class="string">"收到个人消息: <span class="subst">$&#123;message.message&#125;</span>"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            IMessage.ContentType.Register_INFO -&gt; &#123;</span><br><span class="line">                logger.info(<span class="string">"收到注册消息"</span>)</span><br><span class="line">                <span class="keyword">val</span> register: IMessage.Register = IMessage.Register.parseFrom(msg.content)</span><br><span class="line">                <span class="keyword">val</span> uuid = UUIDGenerator.getUUID()</span><br><span class="line">                ChannelMapController.put(uuid, ctx.channel())</span><br><span class="line">                ctx.writeAndFlush(ProtocolFactory.getUUIDProto(register.name, uuid))</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、客户端"><a href="#二、客户端" class="headerlink" title="二、客户端"></a>二、客户端</h2><h4 id="创建连接"><a href="#创建连接" class="headerlink" title="创建连接"></a>创建连接</h4><figure class="highlight pony"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">start</span>() &#123;</span></span><br><span class="line"><span class="function">        <span class="title">mGroup</span> = <span class="title">NioEventLoopGroup</span>()</span></span><br><span class="line"><span class="function">        <span class="title">try</span> &#123;</span></span><br><span class="line"><span class="function">            <span class="title">val</span> <span class="title">b</span> = <span class="title">Bootstrap</span>()</span></span><br><span class="line"><span class="function">            <span class="title">b</span>.<span class="title">group</span>(mGroup)</span></span><br><span class="line"><span class="function">                    .<span class="title">channel</span>(<span class="type">NioSocketChannel</span>::class.java)</span></span><br><span class="line"><span class="function">                    .<span class="title">remoteAddress</span>(<span class="type">InetSocketAddress</span>("<span class="number">172.18</span><span class="number">.157</span><span class="number">.43</span>", <span class="number">1088</span>))</span></span><br><span class="line"><span class="function">                    .<span class="title">option</span>(<span class="type">ChannelOption</span>.<span class="type">CONNECT_TIMEOUT_MILLIS</span>, <span class="number">3000</span>)</span></span><br><span class="line"><span class="function">                    .<span class="title">handler</span>(<span class="type">ProtocolPipeline</span>())</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">            <span class="title">mChannelFuture</span> = <span class="title">b</span>.<span class="title">connect</span>().<span class="title">awaitUninterruptibly</span>()</span></span><br><span class="line"><span class="function">            <span class="title">mChannelFuture</span>!!.<span class="title">channel</span>().<span class="title">closeFuture</span>().<span class="title">sync</span>()</span></span><br><span class="line"><span class="function">        &#125; <span class="title">finally</span> &#123;</span></span><br><span class="line"><span class="function">            <span class="title">mGroup</span>!!.<span class="title">shutdownGracefully</span>().<span class="title">sync</span>()</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br></pre></td></tr></table></figure><h4 id="ProtocolPipeline数据处理-1"><a href="#ProtocolPipeline数据处理-1" class="headerlink" title="ProtocolPipeline数据处理"></a>ProtocolPipeline数据处理</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProtocolPipeline</span> : <span class="type">ChannelInitializer</span>&lt;<span class="type">SocketChannel</span>&gt;</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">initChannel</span><span class="params">(ch: <span class="type">SocketChannel</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> pipeline = ch.pipeline()</span><br><span class="line"></span><br><span class="line">        pipeline.addLast(<span class="string">"send heartbeat"</span>, IdleStateHandler(<span class="number">0</span>, <span class="number">30</span>, <span class="number">0</span>, TimeUnit.SECONDS)) <span class="comment">//写延时30秒，表示30秒没有写操作就会触发心跳机制</span></span><br><span class="line">        <span class="comment">// 和服务端保持一致</span></span><br><span class="line">        pipeline.addLast(ProtobufVarint32FrameDecoder())</span><br><span class="line">        pipeline.addLast(<span class="string">"proto decoder"</span>, ProtobufDecoder(IMessage.Protocol.getDefaultInstance()))</span><br><span class="line">        pipeline.addLast(ProtobufVarint32LengthFieldPrepender())</span><br><span class="line">        pipeline.addLast(<span class="string">"proto encoder"</span>, ProtobufEncoder())</span><br><span class="line">        pipeline.addLast(ClientHandler())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ClientHandler处理逻辑"><a href="#ClientHandler处理逻辑" class="headerlink" title="ClientHandler处理逻辑"></a>ClientHandler处理逻辑</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClientHandler</span> : <span class="type">SimpleChannelInboundHandler</span>&lt;<span class="type">IMessage.Protocol</span>&gt;</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> TAG = <span class="string">"ClientHandler"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">channelActive</span><span class="params">(ctx: <span class="type">ChannelHandlerContext</span>)</span></span> &#123;</span><br><span class="line">        SendMsgController.setChannelHandler(ctx) <span class="comment">// 将channel保存在一个单例中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">channelRead0</span><span class="params">(p0: <span class="type">ChannelHandlerContext</span>?, message: <span class="type">IMessage</span>.<span class="type">Protocol</span>)</span></span> &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"get form server <span class="variable">$message</span>"</span>)</span><br><span class="line">        <span class="keyword">val</span> contentType = message.contentType</span><br><span class="line">        <span class="keyword">when</span> (contentType) &#123;</span><br><span class="line">            IMessage.ContentType.HEART_BEAT -&gt; &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            IMessage.ContentType.Message_INFO -&gt; &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            IMessage.ContentType.Register_UUID -&gt; &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">userEventTriggered</span><span class="params">(ctx: <span class="type">ChannelHandlerContext</span>?, evt: <span class="type">Any</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (evt <span class="keyword">is</span> IdleStateEvent) &#123;</span><br><span class="line">            <span class="keyword">if</span> (evt.state() == IdleState.WRITER_IDLE) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"send heartbeat!"</span>)</span><br><span class="line">                ctx?.writeAndFlush(ProtocolFactory.getHeartBeat())</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"其他超时：<span class="subst">$&#123;evt.state()&#125;</span>"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>.userEventTriggered(ctx, evt)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单例SendMsgController"><a href="#单例SendMsgController" class="headerlink" title="单例SendMsgController"></a>单例SendMsgController</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> SendMsgController &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> TAG = SendMsgController::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>.<span class="title">simpleName</span></span></span><br><span class="line">    <span class="keyword">var</span> channelHandlerContext: ChannelHandlerContext? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setChannelHandler</span><span class="params">(channelHandlerContext: <span class="type">ChannelHandlerContext</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.channelHandlerContext = channelHandlerContext</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sendMsg</span><span class="params">(msg: <span class="type">IMessage</span>.<span class="type">Protocol</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (channelHandlerContext != <span class="literal">null</span>) &#123;</span><br><span class="line">            channelHandlerContext!!.writeAndFlush(msg)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"channelHandlerContext is null"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sendMsg</span><span class="params">(msg: <span class="type">IMessage</span>.<span class="type">Protocol</span>, future: <span class="type">ChannelFutureListener</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (channelHandlerContext != <span class="literal">null</span>) &#123;</span><br><span class="line">            channelHandlerContext!!.writeAndFlush(msg).addListener(future)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"channelHandlerContext is null"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">close</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在连接建立后就将channel保存在一个单例中，之后所有channel相关的操作都可以使用这个单例。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前有做过消息推送相关的应用，使用的Netty框架，一直对这个框架非常感兴趣，也学习了一些它的原理，但感觉还是不够，所以想从今天开始对Netty框架写一个系列的使用及原理学习的博客，提升自己，也希望对看到这篇博客的朋友有所帮助，欢迎大家一起讨论。&lt;/p&gt;
&lt;blockquo
      
    
    </summary>
    
      <category term="Netty" scheme="http://yoursite.com/categories/Netty/"/>
    
    
      <category term="Netty" scheme="http://yoursite.com/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Java内存分配及GC回收</title>
    <link href="http://yoursite.com/2018/08/24/Java%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%8F%8AGC%E5%9B%9E%E6%94%B6/"/>
    <id>http://yoursite.com/2018/08/24/Java内存分配及GC回收/</id>
    <published>2018-08-24T05:46:57.000Z</published>
    <updated>2018-08-24T07:47:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近要准备面试了，今天特意复习一下内存分配和GC相关知识。</p><h2 id="Java内存管理"><a href="#Java内存管理" class="headerlink" title="Java内存管理"></a>Java内存管理</h2><p><img src="/2018/08/24/Java内存分配及GC回收/gc1.jpeg" alt=""></p><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>程序计数器是用于存储每个线程下一步将执行的JVM指令，如该方法为native的，则程序计数器中不存储任何信息。</p><h4 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h4><p>一个线程的每个方法在执行的同时，都会创建一个栈帧（Statck Frame），栈帧中存储的有局部变量表、操作站、动态链接、方法出口等，当方法被调用时，栈帧在JVM栈中入栈，当方法执行完成时，栈帧出栈。</p><p>每个线程对应着一个虚拟机栈，因此虚拟机栈也是线程私有的。</p><h4 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h4><p>堆区是理解Java GC机制最重要的区域，没有之一。在JVM所管理的内存中，堆区是最大的一块，堆区也是Java GC机制所管理的主要内存区域，堆区由所有线程共享，在虚拟机启动时创建。堆区的存在是为了存储对象实例，原则上讲，所有的对象都在堆区上分配内存（不过现代技术里，也不是这么绝对的，也有栈上直接分配的）。</p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>在Sun JDK中这块区域对应的为PermanetGeneration，又称为永久代。方法区域存放了所加载的类的信息（名称、修饰符等）、类中的静态变量、类中定义为final类型的常量、类中的Field信息、类中的方法信息，当开发人员在程序中通过Class对象中的getName、isInterface等方法来获取信息时，这些数据都来源于方法区域，同时方法区域也是全局共享的，在一定的条件下它也会被GC，当方法区域需要使用的内存超过其允许的大小时，会抛出OutOfMemory的错误信息。</p><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>　　JVM采用本地方法栈来支持native方法的执行，此区域用于存储每个native方法调用的状态。</p><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>　　存放的为类中的固定的常量信息、方法和Field的引用信息等，其空间从方法区域中分配。JVM在加载类时会为每个class分配一个独立的常量池，但是运行时常量池中的字符串常量池是全局共享的。　　</p><h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><p>直接内存并不是JVM管理的内存，可以这样理解，直接内存，就是JVM以外的机器内存，比如，你有4G的内存，JVM占用了1G，则其余的3G就是直接内存，JDK中有一种基于通道（Channel）和缓冲区（Buffer）的内存分配方式，将由C语言实现的native函数库分配在直接内存中，用存储在JVM堆中的DirectByteBuffer来引用。由于直接内存收到本机器内存的限制，所以也可能出现OutOfMemoryError的异常。</p><h2 id="Java内存回收机制"><a href="#Java内存回收机制" class="headerlink" title="Java内存回收机制"></a>Java内存回收机制</h2><p>Java内存分配和回收的机制概括的说，就是：分代分配，分代回收。对象将根据存活的时间被分为：年轻代（Young Generation）、年老代（Old Generation）、永久代（Permanent Generation，也就是方法区）。</p><h3 id="年轻代（Young-Generation）"><a href="#年轻代（Young-Generation）" class="headerlink" title="年轻代（Young Generation）"></a>年轻代（Young Generation）</h3><p>对象被创建时，内存的分配首先发生在年轻代（大对象可以直接被创建在年老代），大部分的对象在创建后很快就不再使用，因此很快变得不可达，于是被年轻代的GC机制清理掉（IBM的研究表明，98%的对象都是很快消亡的），这个GC机制被称为Minor GC或叫Young GC。注意，Minor GC并不代表年轻代内存不足，它事实上只表示在Eden区上的GC。</p><p>新生代又被进一步划分为Eden(伊甸，初次创建)和Survivor(存活)区，Survivor区又分为Survivor1和Survivor2。这里为什么要将Young划分为Eden、Survivor1、Survivor2这三块，给出的解释是：</p><blockquote><p>“Young中的98%的对象都是死朝生夕死，所以将内存分为一块较大的Eden和两块较小的Survivor1、Survivor2，JVM默认分配是8:1:1，每次调用Eden和其中的Survivor1，当发生回收的时候，将Eden和Survivor1存活的对象复制到Survivor2，然后直接清理掉Eden和Survivor1的空间。”</p></blockquote><p>内存分配过程如下图：</p><p><img src="/2018/08/24/Java内存分配及GC回收/gc2.jpeg" alt=""></p><h3 id="年老代（Old-Generation）"><a href="#年老代（Old-Generation）" class="headerlink" title="年老代（Old Generation）"></a>年老代（Old Generation）</h3><p>对象如果在年轻代存活了足够长的时间而没有被清理掉（即在几次Young GC后存活了下来），则会被复制到年老代，年老代的空间一般比年轻代大，能存放更多的对象，在年老代上发生的GC次数也比年轻代少。当年老代内存不足时，将执行Major GC，也叫 Full GC。</p><h3 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h3><h4 id="年轻代"><a href="#年轻代" class="headerlink" title="年轻代"></a>年轻代</h4><p>在年轻代中，使用“停止-复制”算法进行清理，将新生代内存分为2部分，1部分 Eden区较大，1部分Survivor比较小，并被划分为两个等量的部分。每次进行清理时，将Eden区和一个Survivor中仍然存活的对象拷贝到 另一个Survivor中，然后清理掉Eden和刚才的Survivor。</p><h4 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h4><p>老年代存储的对象比年轻代多得多，而且不乏大对象，对老年代进行内存清理时，如果使用停止-复制算法，则相当低效。一般，老年代用的算法是标记-整理算法，即：标记出仍然存活的对象（存在引用的），将所有存活的对象向一端移动，以保证内存的连续。</p><h4 id="方法区（永久代）"><a href="#方法区（永久代）" class="headerlink" title="方法区（永久代）"></a>方法区（永久代）</h4><p>永久代的回收有两种：常量池中的常量，无用的类信息，常量的回收很简单，没有引用了就可以被回收。对于无用的类进行回收，必须保证3点：</p><ol><li>类的所有实例都已经被回收</li><li>加载类的ClassLoader已经被回收</li><li>类对象的Class对象没有被引用（即没有通过反射引用该类的地方）</li></ol><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>以下是在看其他博客时看到的一个挺不错的问题。<a href="https://www.cnblogs.com/wjtaigwh/p/6635484.html" target="_blank" rel="noopener">原文链接</a></p><blockquote><p>思考“GC是在什么时候，对什么东西，做了什么事情？”</p></blockquote><h4 id="什么时候"><a href="#什么时候" class="headerlink" title="什么时候"></a>什么时候</h4><p>从字面上翻译过来就是什么时候触发我们的GC机制</p><p>① 在程序空闲的时候。这个回答无力吐槽</p><p>② 程序不可预知的时候/手动调用system.gc()。关于手动调用不推荐</p><p>③ Java堆内存不足时,GC会被调用。当应用线程在运行,并在运行过程中创建新对象,若这时内存空间不足,JVM就会强制地调用GC线程,以便回收内存用于新的分配。若GC一次之后仍不能满足内存分配的要求,JVM会再进行两次GC作进一步的尝试,若仍无法满足要求,则 JVM将报“out of memory”的错误,Java应用将停止。</p><h4 id="什么东西"><a href="#什么东西" class="headerlink" title="什么东西"></a>什么东西</h4><p>从字面的意思翻译过来就是能被GC回收的对象都有哪些特征</p><p>①超出作用域的对象/引用计数为空的对象。</p><blockquote><p>引用计数算法：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器就加1；当引用失效时，计数器值就减1；任何时刻计数器都为0的对象就是不可能再被使用的。</p></blockquote><p>②从GC Root开始搜索，且搜索不到的对象</p><blockquote><p>跟搜索算法：以一系列名为 GC Root的对象作为起点，从这些节点开始往下搜索，搜索走过的路径称为引用链，当一个对象到GC Roots没有任何引用链的时候，则就证明此对象是不可用的。</p><p>这里会提出一个思考，什么样的对象能成为GC Root ： 虚拟机中的引用的对象、方法区中的类静态属性引用的对象、方法区中常量引用的对象、本地方法栈中jni的引用对象。</p></blockquote><p>③从root搜索不到，而且经过第一次标记、清理后，仍然没有复活的对象。</p><h4 id="做什么"><a href="#做什么" class="headerlink" title="做什么"></a>做什么</h4><p>不同年代、不同种类的收集器很多，不过总体的作用是删除不使用的对象，腾出内存空间。补充一些诸如停止其他线程执行、运行finalize等的说明。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近要准备面试了，今天特意复习一下内存分配和GC相关知识。&lt;/p&gt;
&lt;h2 id=&quot;Java内存管理&quot;&gt;&lt;a href=&quot;#Java内存管理&quot; class=&quot;headerlink&quot; title=&quot;Java内存管理&quot;&gt;&lt;/a&gt;Java内存管理&lt;/h2&gt;&lt;p&gt;&lt;img src=
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="内存" scheme="http://yoursite.com/tags/%E5%86%85%E5%AD%98/"/>
    
      <category term="GC" scheme="http://yoursite.com/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>Android中的ClassLoader简析</title>
    <link href="http://yoursite.com/2018/08/22/Android%E4%B8%AD%E7%9A%84ClassLoader%E7%AE%80%E6%9E%90/"/>
    <id>http://yoursite.com/2018/08/22/Android中的ClassLoader简析/</id>
    <published>2018-08-22T04:21:56.000Z</published>
    <updated>2018-08-22T05:27:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道Java中的ClassLoader可以加载jar文件和Class文件（本质是加载Class文件），这一点在Android中并不适用，因为无论是DVM还是ART它们加载的不再是Class文件，而是dex文件，这就需要重新设计ClassLoader相关类，我们先来学习ClassLoader的类型。 </p><h2 id="ClassLoader类型"><a href="#ClassLoader类型" class="headerlink" title="ClassLoader类型"></a>ClassLoader类型</h2><p>Android中的ClassLoader类型和Java中的ClassLoader类型类似，也分为两种类型，分别是系统ClassLoader和自定义ClassLoader。其中系统ClassLoader包括三种分别是BootClassLoader、PathClassLoader和DexClassLoader。</p><h3 id="BootClassLoader"><a href="#BootClassLoader" class="headerlink" title="BootClassLoader"></a>BootClassLoader</h3><p>Android系统启动时会使用BootClassLoader来预加载常用类，与Java中的BootClassLoader不同，它并不是由C/C++代码实现，而是由Java实现的，BootClassLoade的代码如下所示。 </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class BootClassLoader extends ClassLoader &#123;</span><br><span class="line">    private static BootClassLoader instance;</span><br><span class="line">    @FindBugsSuppressWarnings(<span class="string">"DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED"</span>)</span><br><span class="line">    public static synchronized BootClassLoader getInstance() &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="built_in"> instance </span>= new BootClassLoader();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">..</span>.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BootClassLoader是ClassLoader的内部类，并继承自ClassLoader。BootClassLoader是一个单例类，需要注意的是BootClassLoader的访问修饰符是默认的，只有在同一个包中才可以访问，因此我们在应用程序中是无法直接调用的。</p><h3 id="PathClassLoader"><a href="#PathClassLoader" class="headerlink" title="PathClassLoader"></a>PathClassLoader</h3><p>Android系统使用PathClassLoader来加载系统类和应用程序的类，如果是加载非系统应用程序类，则会加载data/app/目录下的dex文件以及包含dex的apk文件或jar文件，不管是加载那种文件，最终都是要加载dex文件，在这里为了方便理解，我们将dex文件以及包含dex的apk文件或jar文件统称为dex相关文件。PathClassLoader不建议开发直接使用。来查看它的代码： </p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">PathClassLoader</span> <span class="keyword">extends</span> <span class="title">BaseDexClassLoader</span> </span>&#123;</span><br><span class="line">    public <span class="type">PathClassLoader</span>(<span class="type">String</span> dexPath, <span class="type">ClassLoader</span> parent) &#123;</span><br><span class="line">        <span class="keyword">super</span>(dexPath, <span class="literal">null</span>, <span class="literal">null</span>, parent);</span><br><span class="line">    &#125;</span><br><span class="line">    public <span class="type">PathClassLoader</span>(<span class="type">String</span> dexPath, <span class="type">String</span> librarySearchPath, <span class="type">ClassLoader</span> parent) &#123;</span><br><span class="line">        <span class="keyword">super</span>(dexPath, <span class="literal">null</span>, librarySearchPath, parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PathClassLoader继承自BaseDexClassLoader，很明显PathClassLoader的方法实现都在BaseDexClassLoader中。从PathClassLoader的构造方法也可以看出它遵循了双亲委托模式。</p><p>PathClassLoader的构造方法有三个参数：</p><ul><li>dexPath：dex文件以及包含dex的apk文件或jar文件的路径集合，多个路径用文件分隔符分隔，默认文件分隔符为‘：’。</li><li>librarySearchPath：包含 C/C++ 库的路径集合，多个路径用文件分隔符分隔分割，可以为null。</li><li>parent：ClassLoader的parent。</li></ul><h3 id="DexClassLoader"><a href="#DexClassLoader" class="headerlink" title="DexClassLoader"></a>DexClassLoader</h3><p>DexClassLoader可以加载dex文件以及包含dex的apk文件或jar文件，也支持从SD卡进行加载，这也就意味着DexClassLoader可以在应用未安装的情况下加载dex相关文件。因此，它是热修复和插件化技术的基础。来查看它的代码，如下所示。 </p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">DexClassLoader</span> <span class="keyword">extends</span> <span class="title">BaseDexClassLoader</span> </span>&#123;</span><br><span class="line">    public <span class="type">DexClassLoader</span>(<span class="type">String</span> dexPath, <span class="type">String</span> optimizedDirectory,</span><br><span class="line">            <span class="type">String</span> librarySearchPath, <span class="type">ClassLoader</span> parent) &#123;</span><br><span class="line">        <span class="keyword">super</span>(dexPath, <span class="keyword">new</span> <span class="type">File</span>(optimizedDirectory), librarySearchPath, parent);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DexClassLoader构造方法的参数要比PathClassLoader多一个optimizedDirectory参数，参数optimizedDirectory代表什么呢？我们知道应用程序第一次被加载的时候，为了提高以后的启动速度和执行效率，Android系统会对dex相关文件做一定程度的优化，并生成一个ODEX文件，此后再运行这个应用程序的时候，只要加载优化过的ODEX文件就行了，省去了每次都要优化的时间，而参数optimizedDirectory就是代表存储ODEX文件的路径，这个路径必须是一个内部存储路径。<br>PathClassLoader没有参数optimizedDirectory，这是因为PathClassLoader已经默认了参数optimizedDirectory的路径为：/data/dalvik-cache。DexClassLoader 也继承自BaseDexClassLoader ，方法实现也都在BaseDexClassLoader中。</p><h2 id="ClassLoader的继承关系"><a href="#ClassLoader的继承关系" class="headerlink" title="ClassLoader的继承关系"></a>ClassLoader的继承关系</h2><p><img src="/2018/08/22/Android中的ClassLoader简析/DexClassloader1.png" alt=""></p><p>可以看到上面一共有8个ClassLoader相关类，其中有一些和Java中的ClassLoader相关类十分类似，下面简单对它们进行介绍：</p><ul><li>ClassLoader是一个抽象类，其中定义了ClassLoader的主要功能。BootClassLoader是它的内部类。</li><li>SecureClassLoader类和JDK8中的SecureClassLoader类的代码是一样的，它继承了抽象类ClassLoader。SecureClassLoader并不是ClassLoader的实现类，而是拓展了ClassLoader类加入了权限方面的功能，加强了ClassLoader的安全性。</li><li>URLClassLoader类和JDK8中的URLClassLoader类的代码是一样的，它继承自SecureClassLoader，用来通过URl路径从jar文件和文件夹中加载类和资源。</li><li>InMemoryDexClassLoader是Android8.0新增的类加载器，继承自BaseDexClassLoader，用于加载内存中的dex文件。</li><li>BaseDexClassLoader继承自ClassLoader，是抽象类ClassLoader的具体实现类，PathClassLoader和DexClassLoader都继承它。</li></ul><h2 id="DexClassLoader-1"><a href="#DexClassLoader-1" class="headerlink" title="DexClassLoader"></a>DexClassLoader</h2><p>介绍 DexClassLoader 之前，先来看看其官方描述：</p><blockquote><p>A class loader that loads classes from .jar and .apk filescontaining a classes.dex entry. This can be used to execute code notinstalled as part of an application.</p></blockquote><p>DexClassLoader 的源码里面只有一个构造方法，这里也是遵从双亲委托模型：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> DexClassLoader(<span class="keyword">String</span> dexPath, <span class="keyword">String</span> optimizedDirectory,</span><br><span class="line">        <span class="keyword">String</span> libraryPath, ClassLoader parent) &#123;</span><br><span class="line">    <span class="keyword">super</span>(dexPath, <span class="keyword">new</span> <span class="type">File</span>(optimizedDirectory), libraryPath, parent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数说明：</p><ol><li><p>String dexPath: 包含 class.dex 的 apk、jar 文件路径 ，多个用文件分隔符(默认是 ：)分隔</p></li><li><p>String optimizedDirectory : 用来缓存优化的 dex 文件的路径，即从 apk 或 jar 文件中提取出来的 dex 文件。该路径不可以为空，且应该是应用私有的，有读写权限的路径</p></li><li><p>String libraryPath: 存储 C/C++ 库文件的路径集</p></li><li><p>ClassLoader parent : 父类加载器，遵从双亲委托模型</p></li></ol><p>PathClassLoader 和 DexClassLoader，但这两者都是对 BaseDexClassLoader 的一层简单封装，真正的实现都在 BaseClassLoader 内。因此简单分析一下BaseClassLoader。</p><h2 id="BaseClassLoader"><a href="#BaseClassLoader" class="headerlink" title="BaseClassLoader"></a>BaseClassLoader</h2><p>先来看一眼 BaseClassLoader 的结构：</p><p><img src="/2018/08/22/Android中的ClassLoader简析/2.jpg" alt=""></p><p>其中有个重要的字段 private final DexPathList pathList，其继承 ClassLoader 实现的 findClass()、findResource()<br>均是基于 pathList 来实现的（省略了部分源码）：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    List&lt;Throwable&gt; suppressedExceptions = <span class="keyword">new</span> ArrayList&lt;Throwable&gt;();</span><br><span class="line">    Class c = pathList.findClass(name, suppressedExceptions);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function">URL <span class="title">findResource</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> pathList.<span class="title">findResource</span><span class="params">(name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Enumeration&lt;URL&gt; findResources(String name) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> pathList.<span class="title">findResources</span><span class="params">(name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function">String <span class="title">findLibrary</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> pathList.<span class="title">findLibrary</span><span class="params">(name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么重要的部分则是在 DexPathList 类的内部了，DexPathList 的构造方法也较为简单，和之前介绍的类似：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> DexPathList(ClassLoader definingContext, <span class="keyword">String</span> dexPath,</span><br><span class="line">        <span class="keyword">String</span> libraryPath, <span class="built_in">File</span> optimizedDirectory) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接受之前传进来的包含 dex 的 apk/jar/dex 的路径集、native 库的路径集和缓存优化的 dex 文件的路径，然后调用 makePathElements()方法生成一个Element[] dexElements数组，Element 是 DexPathList 的一个嵌套类，其有以下字段：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> Element &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">File</span> dir;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isDirectory;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">File</span> zip;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DexFile dexFile;</span><br><span class="line">    <span class="keyword">private</span> ZipFile zipFile;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> initialized;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>makePathElements() 是如何生成 Element 数组的？继续看源码：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Element[] makePathElements(List&lt;<span class="keyword">File</span>&gt; files, <span class="keyword">File</span> optimizedDirectory,</span><br><span class="line">                                          List&lt;IOException&gt; suppressedExceptions) &#123;</span><br><span class="line">    List&lt;Element&gt; elements = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 遍历所有的包含 dex 的文件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">File</span> <span class="keyword">file</span> : files) &#123;</span><br><span class="line">        <span class="keyword">File</span> zip = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">File</span> dir = <span class="keyword">new</span> <span class="keyword">File</span>(<span class="string">""</span>);</span><br><span class="line">        DexFile dex = <span class="keyword">null</span>;</span><br><span class="line">        String path = <span class="keyword">file</span>.getPath();</span><br><span class="line">        String name = <span class="keyword">file</span>.getName();</span><br><span class="line">        <span class="comment">// 判断是不是 zip 类型</span></span><br><span class="line">        <span class="keyword">if</span> (path.contains(zipSeparator)) &#123;</span><br><span class="line">            String split[] = path.split(zipSeparator, <span class="number">2</span>);</span><br><span class="line">            zip = <span class="keyword">new</span> <span class="keyword">File</span>(split[<span class="number">0</span>]);</span><br><span class="line">            dir = <span class="keyword">new</span> <span class="keyword">File</span>(split[<span class="number">1</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">file</span>.isDirectory()) &#123;</span><br><span class="line">            <span class="comment">// 如果是文件夹,则直接添加 Element,这个一般是用来处理 native 库和资源文件</span></span><br><span class="line">            elements.add(<span class="keyword">new</span> Element(<span class="keyword">file</span>, <span class="keyword">true</span>, <span class="keyword">null</span>, <span class="keyword">null</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">file</span>.isFile()) &#123;</span><br><span class="line">            <span class="comment">// 直接是 .dex 文件,而不是 zip/jar 文件(apk 归为 zip),则直接加载 dex 文件</span></span><br><span class="line">            <span class="keyword">if</span> (name.endsWith(DEX_SUFFIX)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    dex = loadDexFile(<span class="keyword">file</span>, optimizedDirectory);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                    System.logE(<span class="string">"Unable to load dex file: "</span> + <span class="keyword">file</span>, ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果是 zip/jar 文件(apk 归为 zip),则将 file 值赋给 zip 字段,再加载 dex 文件</span></span><br><span class="line">                zip = <span class="keyword">file</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    dex = loadDexFile(<span class="keyword">file</span>, optimizedDirectory);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException suppressed) &#123;</span><br><span class="line">                    suppressedExceptions.add(suppressed);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.logW(<span class="string">"ClassLoader referenced unknown path: "</span> + <span class="keyword">file</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((zip != <span class="keyword">null</span>) || (dex != <span class="keyword">null</span>)) &#123;</span><br><span class="line">            elements.add(<span class="keyword">new</span> Element(dir, <span class="keyword">false</span>, zip, dex));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// list 转为数组</span></span><br><span class="line">    <span class="keyword">return</span> elements.toArray(<span class="keyword">new</span> Element[elements.<span class="keyword">size</span>()]);</span><br></pre></td></tr></table></figure><p>oadDexFile()方法最终会调用 JNI 层的方法来读取 dex 文件，这里不再深入探究。<br>接下来看以下 DexPathList 的 findClass()方法，其根据传入的完整的类名来加载对应的 class，源码如下：</p><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">Class</span> <span class="title">findClass</span>(<span class="title">String</span> <span class="title">name</span>, <span class="title">List</span>&lt;<span class="title">Throwable</span>&gt; <span class="title">suppressed</span>) &#123;</span></span><br><span class="line">    // 遍历 dexElements 数组，依次寻找对应的 <span class="class"><span class="keyword">class</span>，一旦找到就终止遍历</span></span><br><span class="line">    <span class="keyword">for</span> (Element element : dexElements) &#123;</span><br><span class="line">        DexFile dex = element.dexFile;</span><br><span class="line">        <span class="keyword">if</span> (dex != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">Class</span> <span class="title">clazz</span> = <span class="title">dex</span>.<span class="title">loadClassBinaryName</span>(<span class="title">name</span>, <span class="title">definingContext</span>, <span class="title">suppressed</span>);</span></span><br><span class="line">            <span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> clazz;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 抛出异常</span><br><span class="line">    <span class="keyword">if</span> (dexElementsSuppressedExceptions != <span class="literal">null</span>) &#123;</span><br><span class="line">        suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有关于热修复实现的一个点，就是将补丁 dex 文件放到 dexElements 数组前面，这样在加载 class 时，优先找到补丁包中的 dex 文件，加载到 class 之后就不再寻找，从而原来的 apk 文件中同名的类就不会再使用，从而达到修复的目的。</p><p>至此，BaseDexClassLader 寻找 class 的路线就清晰了：</p><ol><li>当传入一个完整的类名，调用 BaseDexClassLader 的 findClass(String name) 方法</li><li>BaseDexClassLader 的 findClass 方法会交给 DexPathList 的 findClass(String name, List<throwable> suppressed)方法处理</throwable></li><li>在 DexPathList 方法的内部，会遍历 dexFile ，通过 DexFile的dex.loadClassBinaryName(name,definingContext, suppressed)来完成类的加载</li></ol><p>需要注意到的是，在项目中使用 BaseDexClassLoader 或者 DexClassLoader 去加载某个 dex 或者 apk 中的 class 时，是无法调用 findClass()方法的，因为该方法是包访问权限，你需要调用 loadClass(String className)<br>，该方法其实是 BaseDexClassLoader 的父类 ClassLoader 内实现的：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">Class</span>&lt;?&gt; loadClass(String className) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">return</span> loadClass(className, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">Class</span>&lt;?&gt; loadClass(String className, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">Class</span>&lt;?&gt; clazz = findLoadedClass(className);</span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ClassNotFoundException suppressed = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clazz = parent.loadClass(className, <span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            suppressed = e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                clazz = findClass(className);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                e.addSuppressed(suppressed);</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clazz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码结合之前提到的双亲委托模型就很好理解了，先查找当前的 ClassLoader 是否已经加载过，如果没有就交给父 ClassLoader 去加载，如果父 ClassLoader 没有找到，才调用当前 ClassLoader 来加载，此时就是调用上面分析的 findClass() 方法了。</p><p>出自：</p><p><a href="https://www.jianshu.com/p/96a72d1a7974" target="_blank" rel="noopener">小小亭长博客</a> </p><p><a href="https://blog.csdn.net/itachi85" target="_blank" rel="noopener">刘望舒博客</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们知道Java中的ClassLoader可以加载jar文件和Class文件（本质是加载Class文件），这一点在Android中并不适用，因为无论是DVM还是ART它们加载的不再是Class文件，而是dex文件，这就需要重新设计ClassLoader相关类，我们先来学习C
      
    
    </summary>
    
      <category term="Android系统" scheme="http://yoursite.com/categories/Android%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="ClassLoader" scheme="http://yoursite.com/tags/ClassLoader/"/>
    
  </entry>
  
  <entry>
    <title>Java中的ClassLoader简析</title>
    <link href="http://yoursite.com/2018/08/22/Java%E4%B8%AD%E7%9A%84ClassLoader%E7%AE%80%E6%9E%90/"/>
    <id>http://yoursite.com/2018/08/22/Java中的ClassLoader简析/</id>
    <published>2018-08-22T04:21:15.000Z</published>
    <updated>2018-08-22T04:58:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>插件化和热修复都是目前比较火热的技术，而它们的实现是基于ClassLoader，因此今天先来分析一下Java中的ClassLoader。</p><h2 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h2><p>首先看一下Java虚拟机结构，如下图</p><p><img src="/2018/08/22/Java中的ClassLoader简析/classloader1.png" alt=""></p><p>从图中可以看到类加载子系统是在Class文件和JVM之间的桥梁，它的作用就是通过多种类加载器来查找和加载Class文件到Java虚拟机中。</p><p>Java中的类加载器主要有两种类型，系统类加载和自定义类加载器。其中系统类加载器包括3种，分别是Bootstrap ClassLoader、 Extensions ClassLoader和 Application ClassLoader。</p><h3 id="Bootstrap-ClassLoader"><a href="#Bootstrap-ClassLoader" class="headerlink" title="Bootstrap ClassLoader"></a>Bootstrap ClassLoader</h3><p>用C/C++代码实现的加载器，用于加载Java虚拟机运行时所需要的系统类，如<code>java.lang.*</code>、<code>java.uti.*</code>等这些系统类，它们默认在$JAVA_HOME/jre/lib目录中，也可以通过启动Java虚拟机时指定-Xbootclasspath选项，来改变Bootstrap ClassLoader的加载目录。 </p><p>Java虚拟机的启动就是通过 Bootstrap ClassLoader创建一个初始类来完成的。由于Bootstrap ClassLoader是使用C/C++语言实现的， 所以该加载器不能被Java代码访问到。需要注意的是Bootstrap ClassLoader并不继承java.lang.ClassLoader。 </p><h3 id="Extensions-ClassLoader"><a href="#Extensions-ClassLoader" class="headerlink" title="Extensions ClassLoader"></a>Extensions ClassLoader</h3><p>用于加载 Java 的拓展类 ，用来提供除了系统类之外的额外功能。也可以通过-Djava.ext.dirs选项添加和修改Extensions ClassLoader加载的路径。</p><h3 id="Application-ClassLoader"><a href="#Application-ClassLoader" class="headerlink" title="Application ClassLoader"></a>Application ClassLoader</h3><p>负责加载当前应用程序Classpath目录下的所有jar和Class文件。也可以加载通过-Djava.class.path选项所指定的目录下的jar和Class文件。</p><h3 id="Custom-ClassLoader"><a href="#Custom-ClassLoader" class="headerlink" title="Custom ClassLoader"></a>Custom ClassLoader</h3><p>除了系统提供的类加载器，还可以自定义类加载器，自定义类加载器通过继承java.lang.ClassLoader类的方式来实现自己的类加载器，Extensions ClassLoader和Application ClassLoader也继承了java.lang.ClassLoader类。</p><h2 id="ClassLoader的继承关系"><a href="#ClassLoader的继承关系" class="headerlink" title="ClassLoader的继承关系"></a>ClassLoader的继承关系</h2><p>运行一个Java程序需要用到几种类型的类加载器呢？如下所示。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ClassLoaderTest</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        ClassLoader loader = ClassLoaderTest.class.getClassLoader();</span><br><span class="line">        <span class="keyword">while</span> (loader != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(loader);</span><br><span class="line">            loader = loader.getParent();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果如下所示。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sun<span class="selector-class">.misc</span><span class="selector-class">.Launcher</span><span class="variable">$AppClassLoader</span>@<span class="number">75</span>b84c92</span><br><span class="line">sun<span class="selector-class">.misc</span><span class="selector-class">.Launcher</span><span class="variable">$ExtClassLoader</span>@<span class="number">1</span>b6d3586</span><br></pre></td></tr></table></figure><p>第1行说明加载ClassLoaderTest的类加载器是AppClassLoader，第2行说明AppClassLoader的父加载器为ExtClassLoader。至于为何没有打印出ExtClassLoader的父加载器Bootstrap ClassLoader，这是因为Bootstrap ClassLoader是由C/C++编写的，并不是一个Java类，因此我们无法在Java代码中获取它的引用。</p><p>我们知道系统所提供的类加载器有3种类型，但是系统提供的ClassLoader相关类却不只3个。另外，AppClassLoader的父类加载器为ExtClassLoader，并不代表AppClassLoader继承自ExtClassLoader，ClassLoader的继承关系如下所示。</p><p><img src="/2018/08/22/Java中的ClassLoader简析/classloader2.png" alt=""></p><p>可以看到上图中共有5个ClassLoader相关类，下面简单对它们进行介绍：</p><ul><li>ClassLoader是一个抽象类，其中定义了ClassLoader的主要功能。</li><li>SecureClassLoader继承了抽象类ClassLoader，但SecureClassLoader并不是ClassLoader的实现类，而是拓展了ClassLoader类加入了权限方面的功能，加强了ClassLoader的安全性。</li><li>URLClassLoader继承自SecureClassLoader，用来通过URl路径从jar文件和文件夹中加载类和资源。</li><li>ExtClassLoader和AppClassLoader都继承自URLClassLoader，它们都是Launcher 的内部类，Launcher 是Java虚拟机的入口应用，ExtClassLoader和AppClassLoader都是在Launcher中进行初始化的。</li></ul><h2 id="双亲委托模式"><a href="#双亲委托模式" class="headerlink" title="双亲委托模式"></a>双亲委托模式</h2><p>类加载器查找Class所采用的是双亲委托模式，所谓双亲委托模式就是首先判断该Class是否已经加载，如果没有则不是自身去查找而是委托给父加载器进行查找，这样依次的进行递归，直到委托到最顶层的Bootstrap ClassLoader，如果Bootstrap ClassLoader找到了该Class，就会直接返回，如果没找到，则继续依次向下查找，如果还没找到则最后会交由自身去查找。<br>这样讲可能会有些抽象，来看下面的图。</p><p><img src="/2018/08/22/Java中的ClassLoader简析/classloader3.png" alt=""></p><p>我们知道类加载子系统用来查找和加载Class文件到 Java 虚拟机中，假设我们要加载一个位于D盘的Class文件，这时系统所提供的类加载器不能满足条件，这时就需要我们自定义类加载器继承自java.lang.ClassLoader，并复写它的findClass方法。加载D盘的Class文件步骤如下：</p><ol><li>自定义类加载器首先从缓存中要查找Class文件是否已经加载，如果已经加载就返回该Class，如果没加载则委托给父加载器也就是App ClassLoader。</li><li>按照上图中红色虚线的方向递归步骤1。</li><li>一直委托到Bootstrap ClassLoader，如果Bootstrap ClassLoader在缓存中还没有查找到Class文件，则在自己的规定路径JAVA_HOME/jre/libr中或者-Xbootclasspath选项指定路径的jar包中进行查找，如果找到则返回该Class，如果没有则交给子加载器Extensions ClassLoader。</li><li>Extensions ClassLoader查找JAVA_HOME/jre/lib/ext目录下或者-Djava.ext.dirs选项指定目录下的jar包，如果找到就返回，找不到则交给App ClassLoader。</li><li>App ClassLoade查找Classpath目录下或者-Djava.ext.dirs选项所指定的目录下的jar包和Class文件，如果找到就返回，找不到交给我们自定义的类加载器，如果还找不到则抛出异常。</li></ol><p>总的来说就是Class文件加载到类加载子系统后，先沿着图中红色虚线的方向自下而上进行委托，再沿着黑色虚线的方向自上而下进行查找，整个过程就是先上后下。</p><p>类加载的步骤在JDK8的源码中也得到了体现，来查看抽象类的ClassLoader方法，如下所示。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">Class</span>&lt;?&gt; More ...loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="keyword">Class</span>&lt;?&gt; c = findLoadedClass(name);<span class="comment">//1</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);<span class="comment">//2</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        c = findBootstrapClassOrNull(name);<span class="comment">//3</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;            </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                    c = findClass(name);<span class="comment">//4</span></span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>注释1处用来检查类是否已经加载，如果已经加载则后面的代码不会执行，最后会返回该类。没有加载则会接着向下执行。 </p><p>注释2处，如果父类加载器不为null，则调用父类加载器的loadClass方法。如果父类加载器为null则调用注释3处的findBootstrapClassOrNull方法，这个方法内部调用了Native方法findLoadedClass0，findLoadedClass0方法中最终会用Bootstrap Classloader来查找类。如果Bootstrap Classloader仍没有找到该类，也就说明向上委托没有找到该类，则调用注释4处的findClass方法继续向下进行查找。</p><h4 id="双亲委托模式的好处"><a href="#双亲委托模式的好处" class="headerlink" title="双亲委托模式的好处"></a>双亲委托模式的好处</h4><p>采取双亲委托模式主要有两点好处： </p><ol><li>避免重复加载，如果已经加载过一次Class，就不需要再次加载，而是先从缓存中直接读取。 </li><li>更加安全，如果不使用双亲委托模式，就可以自定义一个String类来替代系统的String类，这显然会造成安全隐患，采用双亲委托模式会使得系统的String类在Java虚拟机启动时就被加载，也就无法自定义String类来替代系统的String类，除非我们修改类加载器搜索类的默认算法。还有一点，只有两个类名一致并且被同一个类加载器加载的类，Java虚拟机才会认为它们是同一个类，想要骗过Java虚拟机显然不会那么容易。</li></ol><h2 id="自定义ClassLoader"><a href="#自定义ClassLoader" class="headerlink" title="自定义ClassLoader"></a>自定义ClassLoader</h2><p>系统提供的类加载器只能够加载指定目录下的jar包和Class文件，如果想要加载网络上的或者是D盘某一文件中的jar包和Class文件则需要自定义ClassLoader。</p><p>实现自定义ClassLoader需要两个步骤： </p><ol><li>定义一个自定义ClassLoade并继承抽象类ClassLoader。 </li><li>复写findClass方法，并在findClass方法中调用defineClass方法。</li></ol><p>下面我们就自定义一个ClassLoader用来加载位于D:\lib的Class文件。</p><h4 id="编写测试Class文件"><a href="#编写测试Class文件" class="headerlink" title="编写测试Class文件"></a>编写测试Class文件</h4><p>首先编写测试类并生成Class文件，如下所示。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package com.example;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Jobs</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"One more thing"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将这个Jobs.java放入到D:\lib中，使用cmd命令进入D:\lib目录中，执行Javac Jobs.java对该java文件进行编译，这时会在D:\lib中生成Jobs.class。</p><h4 id="编写自定义ClassLoader"><a href="#编写自定义ClassLoader" class="headerlink" title="编写自定义ClassLoader"></a>编写自定义ClassLoader</h4><p>接下来编写自定义ClassLoader，如下所示。</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> DiskClassLoader extends ClassLoader &#123;</span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line">    <span class="keyword">public</span> DiskClassLoader(String path) &#123;</span><br><span class="line">        <span class="keyword">this</span>.path = path;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">        Class clazz = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] classData = loadClassData(name);<span class="comment">//1</span></span><br><span class="line">        <span class="keyword">if</span> (classData == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            clazz= defineClass(name, classData, <span class="number">0</span>, classData.length);<span class="comment">//2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> clazz;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] loadClassData(String name) &#123;</span><br><span class="line">        String fileName = getFileName(name);</span><br><span class="line">        File file = <span class="keyword">new</span> File(path,fileName);</span><br><span class="line">        InputStream <span class="keyword">in</span>=<span class="literal">null</span>;</span><br><span class="line">        ByteArrayOutputStream <span class="keyword">out</span>=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="keyword">in</span> = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">             <span class="keyword">out</span> = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> length=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((length = <span class="keyword">in</span>.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">out</span>.write(buffer, <span class="number">0</span>, length);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">out</span>.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">in</span>!=<span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">in</span>.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">out</span>!=<span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">out</span>.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> String getFileName(String name) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = name.lastIndexOf(<span class="string">'.'</span>);</span><br><span class="line">        <span class="keyword">if</span>(index == -<span class="number">1</span>)&#123;<span class="comment">//如果没有找到'.'则直接在末尾添加.class</span></span><br><span class="line">            <span class="keyword">return</span> name+<span class="string">".class"</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name.substring(index+<span class="number">1</span>)+<span class="string">".class"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码有几点需要注意的，注释1处的loadClassData方法会获得class文件的字节码数组，并在注释2处调用defineClass方法将class文件的字节码数组转为Class类的实例。loadClassData方法中需要对流进行操作，关闭流的操作要放在finally语句块中，并且要对in和out分别采用try语句，如果in和out共同在一个try语句中，那么如果in.close()发生异常，则无法执行 out.close()。</p><p>最后我们来验证DiskClassLoader是否可用，代码如下所示。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        DiskClassLoader diskClassLoader = <span class="keyword">new</span> <span class="type">DiskClassLoader</span>(<span class="string">"D:\\lib"</span>);<span class="comment">//1</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class c = diskClassLoader.loadClass(<span class="string">"com.example.Jobs"</span>);<span class="comment">//2</span></span><br><span class="line">            <span class="keyword">if</span> (c != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Object obj = c.<span class="keyword">new</span><span class="type">Instance</span>();</span><br><span class="line">                    System.out.println(obj.getClass().getClassLoader());</span><br><span class="line">                    Method method = c.getDeclaredMethod(<span class="string">"say"</span>, <span class="literal">null</span>);</span><br><span class="line">                    method.invoke(obj, <span class="literal">null</span>);<span class="comment">//3</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException</span><br><span class="line">                        | NoSuchMethodException</span><br><span class="line">                        | SecurityException |</span><br><span class="line">                        IllegalArgumentException |</span><br><span class="line">                        InvocationTargetException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1出创建DiskClassLoader并传入要加载类的路径，注释2处加载Class文件，需要注意的是，不要在项目工程中存在名为com.example.Jobs的Java文件，否则就不会使用DiskClassLoader来加载，而是AppClassLoader来负责加载，这样我们定义DiskClassLoader就变得毫无意义。接下来在注释3通过反射来调用Jobs的say方法，打印结果如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">com</span><span class="selector-class">.example</span><span class="selector-class">.DiskClassLoader</span>@<span class="keyword">4554617c</span></span><br><span class="line"><span class="keyword">One</span> more thing</span><br></pre></td></tr></table></figure><p>使用了DiskClassLoader来加载Class文件，say方法也正确执行，显然我们的目的达到了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;插件化和热修复都是目前比较火热的技术，而它们的实现是基于ClassLoader，因此今天先来分析一下Java中的ClassLoader。&lt;/p&gt;
&lt;h2 id=&quot;类加载子系统&quot;&gt;&lt;a href=&quot;#类加载子系统&quot; class=&quot;headerlink&quot; title=&quot;类加载子
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="ClassLoader" scheme="http://yoursite.com/tags/ClassLoader/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>LinkedHashMap和LRU</title>
    <link href="http://yoursite.com/2018/08/20/LinkedHashMap%E5%92%8CLRU/"/>
    <id>http://yoursite.com/2018/08/20/LinkedHashMap和LRU/</id>
    <published>2018-08-20T06:28:05.000Z</published>
    <updated>2018-08-20T07:53:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>刚好正在研究Android中LruCache缓存，它的实现其实也是使用了LinkedHashMap，所以今天就专门写博客记录一下相关知识。</p><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>LinkedHashMap实际上是使用HashMap+双向链表，有关HashMap的详细知识就请看之前相关博客<a href="https://david1840.github.io/2018/08/12/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">HashMap源码分析</a>。我们知道HashMap是以散列表的形式存储数据的，LinkedHashMap继承HashMap，所以它也是使用散列表存储数据，但是，会有额外的“Linked”双向链表把所有的数据连接起来。为什么要这样做？HashMap是无序的，而加上双向链表，就将所有数据有序管理起来。具体如下图：</p><p><img src="/2018/08/20/LinkedHashMap和LRU/linkedhashmap.png" alt=""></p><p>在HashMap的基础上多了befor和after字段，用来形成双向链表。</p><h2 id="两个例子"><a href="#两个例子" class="headerlink" title="两个例子"></a>两个例子</h2><p>LinkedHashMap的核心就是存在存储顺序和可以实现LRU算法，所以下面我用两个例子证明这两种情况：</p><h4 id="存储顺序"><a href="#存储顺序" class="headerlink" title="存储顺序"></a>存储顺序</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class LinkedHashMapTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        LinkedHashMap<span class="tag">&lt;<span class="name">Integer,</span> <span class="attr">Integer</span>&gt;</span> map = new LinkedHashMap<span class="tag">&lt;<span class="name">Integer,</span> <span class="attr">Integer</span>&gt;</span>();</span><br><span class="line">        for (int i = 0; i <span class="tag">&lt; <span class="attr">10</span>; <span class="attr">i</span>++) &#123;//按顺序放入<span class="attr">1</span>~<span class="attr">9</span></span></span><br><span class="line"><span class="tag">            <span class="attr">map.put</span>(<span class="attr">i</span>, <span class="attr">i</span>);</span></span><br><span class="line"><span class="tag">        &#125;</span></span><br><span class="line"><span class="tag">        <span class="attr">System.out.println</span>("原数据："+<span class="attr">map.toString</span>());</span></span><br><span class="line"><span class="tag">        <span class="attr">map.get</span>(<span class="attr">3</span>);</span></span><br><span class="line"><span class="tag">        <span class="attr">System.out.println</span>("查询存在的某一个："+<span class="attr">map.toString</span>());</span></span><br><span class="line"><span class="tag">        <span class="attr">map.put</span>(<span class="attr">4</span>, <span class="attr">4</span>);</span></span><br><span class="line"><span class="tag">        <span class="attr">System.out.println</span>("插入已存在的某一个："+<span class="attr">map.toString</span>()); //直接调用已存在的<span class="attr">toString</span>方法，不然自己需要用迭代器实现</span></span><br><span class="line"><span class="tag">        <span class="attr">map.put</span>(<span class="attr">10</span>, <span class="attr">10</span>);</span></span><br><span class="line"><span class="tag">        <span class="attr">System.out.println</span>("插入一个原本没存在的："+<span class="attr">map.toString</span>());</span></span><br><span class="line"><span class="tag">    &#125;</span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">    //输出结果</span></span><br><span class="line"><span class="tag">//  原数据：&#123;<span class="attr">0</span>=<span class="string">0,</span> <span class="attr">1</span>=<span class="string">1,</span> <span class="attr">2</span>=<span class="string">2,</span> <span class="attr">3</span>=<span class="string">3,</span> <span class="attr">4</span>=<span class="string">4,</span> <span class="attr">5</span>=<span class="string">5,</span> <span class="attr">6</span>=<span class="string">6,</span> <span class="attr">7</span>=<span class="string">7,</span> <span class="attr">8</span>=<span class="string">8,</span> <span class="attr">9</span>=<span class="string">9&#125;</span></span></span><br><span class="line"><span class="tag">//  查询存在的某一个：&#123;<span class="attr">0</span>=<span class="string">0,</span> <span class="attr">1</span>=<span class="string">1,</span> <span class="attr">2</span>=<span class="string">2,</span> <span class="attr">3</span>=<span class="string">3,</span> <span class="attr">4</span>=<span class="string">4,</span> <span class="attr">5</span>=<span class="string">5,</span> <span class="attr">6</span>=<span class="string">6,</span> <span class="attr">7</span>=<span class="string">7,</span> <span class="attr">8</span>=<span class="string">8,</span> <span class="attr">9</span>=<span class="string">9&#125;</span></span></span><br><span class="line"><span class="tag">//  插入已存在的某一个：&#123;<span class="attr">0</span>=<span class="string">0,</span> <span class="attr">1</span>=<span class="string">1,</span> <span class="attr">2</span>=<span class="string">2,</span> <span class="attr">3</span>=<span class="string">3,</span> <span class="attr">4</span>=<span class="string">4,</span> <span class="attr">5</span>=<span class="string">5,</span> <span class="attr">6</span>=<span class="string">6,</span> <span class="attr">7</span>=<span class="string">7,</span> <span class="attr">8</span>=<span class="string">8,</span> <span class="attr">9</span>=<span class="string">9&#125;</span></span></span><br><span class="line"><span class="tag">//  插入一个原本没存在的：&#123;<span class="attr">0</span>=<span class="string">0,</span> <span class="attr">1</span>=<span class="string">1,</span> <span class="attr">2</span>=<span class="string">2,</span> <span class="attr">3</span>=<span class="string">3,</span> <span class="attr">4</span>=<span class="string">4,</span> <span class="attr">5</span>=<span class="string">5,</span> <span class="attr">6</span>=<span class="string">6,</span> <span class="attr">7</span>=<span class="string">7,</span> <span class="attr">8</span>=<span class="string">8,</span> <span class="attr">9</span>=<span class="string">9,</span> <span class="attr">10</span>=<span class="string">10&#125;</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">&#125;</span></span><br></pre></td></tr></table></figure><p>观察以上代码，其实它是符合先进先出的规则的，不管你怎么查询插入已存在的数据，不会对排序造成影响，如果有新插入的数据将会放在最尾部。</p><h4 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h4><p>启用LinkedHashMap的LRU规则是要使用它的三个参数的构造方法。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty &lt;tt&gt;LinkedHashMap&lt;/tt&gt; instance with the</span></span><br><span class="line"><span class="comment">     * specified initial capacity, load factor and ordering mode.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  initialCapacity the initial capacity</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  loadFactor      the load factor</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  accessOrder     the ordering mode - &lt;tt&gt;true&lt;/tt&gt; for</span></span><br><span class="line"><span class="comment">     *         access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span></span><br><span class="line"><span class="comment">     *         or the load factor is nonpositive</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> LinkedHashMap(<span class="keyword">int</span> initialCapacity,</span><br><span class="line">                         <span class="keyword">float</span> loadFactor,</span><br><span class="line">                         <span class="keyword">boolean</span> accessOrder) &#123;</span><br><span class="line">        <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">        <span class="keyword">this</span>.accessOrder = accessOrder;<span class="comment">//是否开启LRU规则</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class LinkedHashMapTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        LinkedHashMap<span class="tag">&lt;<span class="name">Integer,</span> <span class="attr">Integer</span>&gt;</span> map = new LinkedHashMap<span class="tag">&lt;<span class="name">Integer,</span> <span class="attr">Integer</span>&gt;</span>(20, 0.75f, true);</span><br><span class="line">        for (int i = 0; i <span class="tag">&lt; <span class="attr">10</span>; <span class="attr">i</span>++) &#123;//按顺序放入<span class="attr">1</span>~<span class="attr">9</span></span></span><br><span class="line"><span class="tag">            <span class="attr">map.put</span>(<span class="attr">i</span>, <span class="attr">i</span>);</span></span><br><span class="line"><span class="tag">        &#125;</span></span><br><span class="line"><span class="tag">        <span class="attr">System.out.println</span>("原数据："+<span class="attr">map.toString</span>());</span></span><br><span class="line"><span class="tag">        <span class="attr">map.get</span>(<span class="attr">3</span>);</span></span><br><span class="line"><span class="tag">        <span class="attr">System.out.println</span>("查询存在的某一个："+<span class="attr">map.toString</span>());</span></span><br><span class="line"><span class="tag">        <span class="attr">map.put</span>(<span class="attr">4</span>, <span class="attr">4</span>);</span></span><br><span class="line"><span class="tag">        <span class="attr">System.out.println</span>("插入已存在的某一个："+<span class="attr">map.toString</span>()); //直接调用已存在的<span class="attr">toString</span>方法，不然自己需要用迭代器实现</span></span><br><span class="line"><span class="tag">        <span class="attr">map.put</span>(<span class="attr">10</span>, <span class="attr">10</span>);</span></span><br><span class="line"><span class="tag">        <span class="attr">System.out.println</span>("插入一个原本没存在的："+<span class="attr">map.toString</span>());</span></span><br><span class="line"><span class="tag">    &#125;</span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">    //输出结果</span></span><br><span class="line"><span class="tag">//  原数据：&#123;<span class="attr">0</span>=<span class="string">0,</span> <span class="attr">1</span>=<span class="string">1,</span> <span class="attr">2</span>=<span class="string">2,</span> <span class="attr">3</span>=<span class="string">3,</span> <span class="attr">4</span>=<span class="string">4,</span> <span class="attr">5</span>=<span class="string">5,</span> <span class="attr">6</span>=<span class="string">6,</span> <span class="attr">7</span>=<span class="string">7,</span> <span class="attr">8</span>=<span class="string">8,</span> <span class="attr">9</span>=<span class="string">9&#125;</span></span></span><br><span class="line"><span class="tag">//  查询存在的某一个：&#123;<span class="attr">0</span>=<span class="string">0,</span> <span class="attr">1</span>=<span class="string">1,</span> <span class="attr">2</span>=<span class="string">2,</span> <span class="attr">4</span>=<span class="string">4,</span> <span class="attr">5</span>=<span class="string">5,</span> <span class="attr">6</span>=<span class="string">6,</span> <span class="attr">7</span>=<span class="string">7,</span> <span class="attr">8</span>=<span class="string">8,</span> <span class="attr">9</span>=<span class="string">9,</span> <span class="attr">3</span>=<span class="string">3&#125;</span> //被访问（<span class="attr">get</span>）的<span class="attr">3</span>放到了最后面</span></span><br><span class="line"><span class="tag">//  插入已存在的某一个：&#123;<span class="attr">0</span>=<span class="string">0,</span> <span class="attr">1</span>=<span class="string">1,</span> <span class="attr">2</span>=<span class="string">2,</span> <span class="attr">5</span>=<span class="string">5,</span> <span class="attr">6</span>=<span class="string">6,</span> <span class="attr">7</span>=<span class="string">7,</span> <span class="attr">8</span>=<span class="string">8,</span> <span class="attr">9</span>=<span class="string">9,</span> <span class="attr">3</span>=<span class="string">3,</span> <span class="attr">4</span>=<span class="string">4&#125;//被访问（put）的4放到了最后面</span></span></span><br><span class="line"><span class="tag">//  插入一个原本没存在的：&#123;<span class="attr">0</span>=<span class="string">0,</span> <span class="attr">1</span>=<span class="string">1,</span> <span class="attr">2</span>=<span class="string">2,</span> <span class="attr">5</span>=<span class="string">5,</span> <span class="attr">6</span>=<span class="string">6,</span> <span class="attr">7</span>=<span class="string">7,</span> <span class="attr">8</span>=<span class="string">8,</span> <span class="attr">9</span>=<span class="string">9,</span> <span class="attr">3</span>=<span class="string">3,</span> <span class="attr">4</span>=<span class="string">4,</span> <span class="attr">10</span>=<span class="string">10&#125;//新增一个放到最后面</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">&#125;</span></span><br></pre></td></tr></table></figure><p>从上面可以看出，每当我get或者put一个已存在的数据，就会把这个数据放到双向链表的尾部，put一个新的数据也会放到双向链表的尾部。</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">       accessOrder = <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>(initialCapacity);</span><br><span class="line">       accessOrder = <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>();</span><br><span class="line">       accessOrder = <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(Map&lt;? <span class="keyword">extends</span> K, ? <span class="keyword">extends</span> V&gt; m)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>(m);</span><br><span class="line">       accessOrder = <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> LinkedHashMap(<span class="keyword">int</span> initialCapacity,</span><br><span class="line">                        <span class="keyword">float</span> loadFactor,</span><br><span class="line">                        <span class="keyword">boolean</span> accessOrder) &#123;</span><br><span class="line">       <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">       <span class="keyword">this</span>.accessOrder = accessOrder;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>5个构造函数，可以设置容量和加载因子，且默认情况下是不开启LRU规则。</p><h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * HashMap.Node subclass for normal LinkedHashMap entries.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   static <span class="class"><span class="keyword">class</span> <span class="title">Entry&lt;K</span>,<span class="title">V&gt;</span> <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node&lt;K</span>,<span class="title">V&gt;</span> </span>&#123;</span><br><span class="line">       <span class="type">Entry</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; before, after; <span class="comment">//指向前后节点</span></span><br><span class="line">       <span class="type">Entry</span>(int hash, <span class="type">K</span> key, <span class="type">V</span> value, <span class="type">Node</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; next) &#123;</span><br><span class="line">           <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The head (eldest) of the doubly linked list.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   transient <span class="type">LinkedHashMap</span>.<span class="type">Entry</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; head;<span class="comment">//双向链表头节点（最老）</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The tail (youngest) of the doubly linked list.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   transient <span class="type">LinkedHashMap</span>.<span class="type">Entry</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; tail;<span class="comment">//双向列表尾节点（最新</span></span><br></pre></td></tr></table></figure><h4 id="LRU实现"><a href="#LRU实现" class="headerlink" title="LRU实现"></a>LRU实现</h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// 把当前节点e放到双向链表尾部</span></span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">        <span class="comment">//accessOrder就是我们前面说的LRU控制，当它为true，同时e对象不是尾节点（如果访问尾节点就不需要设置，该方法就是把节点放置到尾节点）</span></span><br><span class="line">        <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">        <span class="comment">//用a和b分别记录该节点前面和后面的节点</span></span><br><span class="line">            LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">                (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">             <span class="comment">//释放当前节点与后节点的关系 </span></span><br><span class="line">            p.after = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//如果当前节点的前节点是空，</span></span><br><span class="line">            <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//那么头节点就设置为a</span></span><br><span class="line">                head = a;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//如果b不为null，那么b的后节点指向a</span></span><br><span class="line">                b.after = a;</span><br><span class="line">            <span class="comment">//如果a节点不为空</span></span><br><span class="line">            <span class="keyword">if</span> (a != <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">//a的后节点指向b</span></span><br><span class="line">                a.before = b;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//如果a为空，那么b就是尾节点</span></span><br><span class="line">                last = b;</span><br><span class="line">                <span class="comment">//如果尾节点为空</span></span><br><span class="line">            <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//那么p为头节点</span></span><br><span class="line">                head = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//否则就把p放到双向链表最尾处</span></span><br><span class="line">                p.before = last;</span><br><span class="line">                last.after = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//设置尾节点为P</span></span><br><span class="line">            tail = p;</span><br><span class="line">            <span class="comment">//LinkedHashMap对象操作次数+1</span></span><br><span class="line">            ++modCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>开启LRU后，put，get等方法都会调用这个函数来调整顺序。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="built_in">get</span>(<span class="keyword">Object</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">       Node&lt;K,V&gt; e;</span><br><span class="line">       <span class="keyword">if</span> ((e = getNode(hash(<span class="built_in">key</span>), <span class="built_in">key</span>)) == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">if</span> (accessOrder)<span class="comment">//如果启用了LRU规则</span></span><br><span class="line">           afterNodeAccess(e);<span class="comment">//那么把该节点移到双向链表最后面</span></span><br><span class="line">       <span class="keyword">return</span> e.value;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="移除Eldest"><a href="#移除Eldest" class="headerlink" title="移除Eldest"></a>移除Eldest</h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>LinkedHashMap有一个自带的移除最老数据的方法，默认返回false，我们可以在继承的时候重写这个方法，给定一个条件就可以控制存储在LinkedHashMap中的最老数据何时删除。触发这个删除机制，一般是在PUT一个数据进入的时候，但是LinkedHashMap并没有重写Put方法如何实现呢?在LinekdHashMap中，这个方法被包含在afterNodeInsertion()方法之中，而这个方法是重写了HashMap的，但是HashMap中并没有去实现它，所以在put的时候就会触发删除这个机制。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;刚好正在研究Android中LruCache缓存，它的实现其实也是使用了LinkedHashMap，所以今天就专门写博客记录一下相关知识。&lt;/p&gt;
&lt;h2 id=&quot;存储结构&quot;&gt;&lt;a href=&quot;#存储结构&quot; class=&quot;headerlink&quot; title=&quot;存储结构&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="LRU" scheme="http://yoursite.com/tags/LRU/"/>
    
  </entry>
  
  <entry>
    <title>Android JNI学习</title>
    <link href="http://yoursite.com/2018/08/17/Android-JNI%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2018/08/17/Android-JNI学习/</id>
    <published>2018-08-17T08:26:23.000Z</published>
    <updated>2018-08-29T12:53:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>JNI是Android中比较重要的一块知识，Java层与C/C++层进行调用的桥梁。所以今天就来学习一下JNI相关的知识。</p><h2 id="JNI（Java-Native-Interface）"><a href="#JNI（Java-Native-Interface）" class="headerlink" title="JNI（Java Native Interface）"></a>JNI（Java Native Interface）</h2><p>JNI(Java Native Interface):java本地开发接口,JNI是一个协议，这个协议用来沟通java代码和外部的本地代码(c/c++),外部的c/c++代码也可以调用java代码。</p><p>####为什么使用JNI？</p><ol><li>效率上 C/C++是本地语言，比java更高效</li><li>代码移植，如果之前用C语言开发过模块，可以复用已经存在的c代码</li><li>java反编译比C语言容易，一般加密算法都是用C语言编写，不容易被反编译</li></ol><h4 id="Java基本数据类型与C语言基本数据类型的对应"><a href="#Java基本数据类型与C语言基本数据类型的对应" class="headerlink" title="Java基本数据类型与C语言基本数据类型的对应"></a>Java基本数据类型与C语言基本数据类型的对应</h4><p><img src="/2018/08/17/Android-JNI学习/jni1.png" alt=""></p><h4 id="引用类型对应"><a href="#引用类型对应" class="headerlink" title="引用类型对应"></a>引用类型对应</h4><p><img src="/2018/08/17/Android-JNI学习/jni2.png" alt=""></p><h2 id="JNI例子"><a href="#JNI例子" class="headerlink" title="JNI例子"></a>JNI例子</h2><p>在AS3.0之后，AS对JNI的工程构建做了一些改动，可以非常方便地创建一个支持JNI的工程。</p><p><img src="/2018/08/17/Android-JNI学习/jni3.png" alt=""></p><p>只要在创建工程的时候选择包括C++，其他都是正常的创建流程。</p><p>最终创建出的工程结构如下图：</p><p><img src="/2018/08/17/Android-JNI学习/jni4.png" alt=""></p><p>默认生成一个<code>stringFromJNI</code>的方法，返回值为String类型。</p><p>生成的对应C代码为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> JNIEXPORT jstring</span><br><span class="line"></span><br><span class="line">JNICALL</span><br><span class="line">Java_com_liuwei_ndktest_MainActivity_stringFromJNI(</span><br><span class="line">        JNIEnv *env,</span><br><span class="line">        jobject <span class="comment">/* this */</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> hello = <span class="string">"Hello from C++"</span>;</span><br><span class="line">    <span class="keyword">return</span> env-&gt;NewStringUTF(hello.c_str());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AS帮我们创建一个CPP文件夹用来保存我们的C／C++文件，CMakeList文件也帮我们创建成功，可以直接运行，极大方便了我们Android开发程序员。</p><blockquote><p>C/C++中生成方法的名称规范为：Java _ 包名 _ 类名 _ 方法名</p></blockquote><h3 id="JNI传递一个数组"><a href="#JNI传递一个数组" class="headerlink" title="JNI传递一个数组"></a>JNI传递一个数组</h3><p>上面AS自动生成的示例代码展示了JNI对String的操作，然后我们看一下JNI传递一个数组。</p><h4 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="生成C-C-代码"><a href="#生成C-C-代码" class="headerlink" title="生成C/C++代码"></a>生成C/C++代码</h4><p>在AS3.0之后也不用我们去自己写对应的C/C++代码，AS可以帮我们自动生成。</p><p><img src="/2018/08/17/Android-JNI学习/jni5.png" alt=""></p><p>生成的模版代码：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">extern <span class="string">"C"</span> JNIEXPORT void </span><br><span class="line"></span><br><span class="line">JNICALL</span><br><span class="line">Java_com_liuwei_ndktest_MainActivity_change(<span class="name">JNIEnv</span> *env, jobject instance, jintArray arr_) &#123;</span><br><span class="line">    jint *arr = env-&gt;GetIntArrayElements(<span class="name">arr_</span>, NULL)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    // TODO</span><br><span class="line"></span><br><span class="line">    env-&gt;ReleaseIntArrayElements(<span class="name">arr_</span>, arr, <span class="number">0</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自动生成的代码连获取数组数据以及释放数组内存都帮我们写好了，简直了～</p><p>然后我们做一些操作：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">extern <span class="string">"C"</span> JNIEXPORT void</span><br><span class="line"></span><br><span class="line">JNICALL</span><br><span class="line">Java_com_liuwei_ndktest_MainActivity_change(JNIEnv *<span class="keyword">env</span>, jobject <span class="keyword">instance</span>, jintArray arr_) &#123;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="keyword">env</span>-&gt;GetArrayLength(arr_);</span><br><span class="line">    jint *arr = <span class="keyword">env</span>-&gt;GetIntArrayElements(arr_, NULL);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//每个数据加10</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">        *(arr + i) += <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">env</span>-&gt;ReleaseIntArrayElements(arr_, arr, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Java中调用该方法</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int[] a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line"> change(a);</span><br><span class="line"></span><br><span class="line"> for (int i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">      Log.e(<span class="string">"Test"</span>, <span class="string">"a"</span> + i + <span class="string">"= "</span> + a[i]);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">E/Test: <span class="attr">a0=</span> <span class="number">11</span></span><br><span class="line">E/Test: <span class="attr">a1=</span> <span class="number">12</span></span><br><span class="line">   <span class="attr">a2=</span> <span class="number">13</span></span><br><span class="line">   <span class="attr">a3=</span> <span class="number">14</span></span><br><span class="line">   <span class="attr">a4=</span> <span class="number">15</span></span><br><span class="line">   <span class="attr">a5=</span> <span class="number">16</span></span><br></pre></td></tr></table></figure><p>每个数据都加了10，OK。</p><p>可以看到我们在这个方法中没有返回值，直接打印相同的数组，但实际结果也发生了改变，这是因为：<strong>传递数组其实是传递一个堆内存的数组首地址的引用过去，所以实际操作的是同一块内存，当调用完方法，不需要返回值,实际上参数内容已经改变，Android中很多操作硬件的方法都是这种C语言的传引用的思路。</strong></p><h3 id="在C-中调用java方法"><a href="#在C-中调用java方法" class="headerlink" title="在C++中调用java方法"></a>在C++中调用java方法</h3><p>Java中：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">sayJavaHi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.e(<span class="string">"Test"</span>, <span class="string">"Hi Java"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>我们调用say方法，然后由C调用sayJavaHi方法。</p><p>C++方法：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#include &lt;android/log.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define LOG_TAG "System.out"</span></span><br><span class="line"><span class="comment">#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern </span><span class="string">"C"</span> <span class="keyword">JNIEXPORT </span>void </span><br><span class="line"><span class="keyword">JNICALL</span></span><br><span class="line"><span class="keyword">Java_com_liuwei_ndktest_MainActivity_say(JNIEnv </span>*env, <span class="keyword">jobject </span><span class="keyword">instance) </span>&#123;</span><br><span class="line">    LOGD(<span class="string">"debug日志"</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">jclass </span><span class="keyword">jclass1 </span>= env-&gt;FindClass(<span class="string">"com/liuwei/ndktest/MainActivity"</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">jmethodID </span>methodID = env-&gt;GetMethodID(<span class="keyword">jclass1, </span><span class="string">"sayJavaHi"</span>, <span class="string">"()V"</span>)<span class="comment">;</span></span><br><span class="line">    env-&gt;CallVoidMethod(<span class="keyword">instance, </span>methodID)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在C++方法中我们使用反射调用Java层的代码。</p><p>最终结果：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">08</span>-<span class="number">17</span> <span class="number">20</span>:<span class="number">30</span>:<span class="number">05.637</span> <span class="number">8791</span>-<span class="number">8791</span>/com<span class="selector-class">.liuwei</span><span class="selector-class">.ndktest</span> D/System<span class="selector-class">.out</span>: debug日志</span><br><span class="line"><span class="number">08</span>-<span class="number">17</span> <span class="number">20</span>:<span class="number">30</span>:<span class="number">05.637</span> <span class="number">8791</span>-<span class="number">8791</span>/com<span class="selector-class">.liuwei</span><span class="selector-class">.ndktest</span> E/Test: Hi Java</span><br></pre></td></tr></table></figure><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>这里说一下GetMethodID方法，第一个参数：Java类对象；第二个参数：参数名（或方法名）；第三个参数：该参数（或方法）的签名。</p><p>比较麻烦的是第三个参数，JNI是以”(*)+”形式表示函数的有哪些传入参数，传入参数的类型，返回值的类型。”()” 中的字符表示传入参数，后面的则代表返回值。</p><p>例如：</p><p> “()V” 就表示void Func();</p><p> “(II)V” 表示 void Func(int, int);</p><p> “(Ljava/lang/String;Ljava/lang/String;)I”.表示 int Func(String,String)</p><p><img src="/2018/08/17/Android-JNI学习/jni6.png" alt=""></p><p>另外数组类型的简写,则用”[“加上如表A所示的对应类型的简写形式进行表示就可以了，<br>比如：<strong>[I</strong> 表示 int [];<strong>[L/java/lang/objects;</strong>表示Objects[],另外。引用类型（除基本类型的数组外）的标示最后都有个”;”</p><h2 id="补充二"><a href="#补充二" class="headerlink" title="补充二"></a>补充二</h2><p>对于这个方法参数中的JNIEnv* env参数的解释:</p><p>JNIEnv类型实际上代表了Java环境，通过这个JNIEnv* 指针，就可以对Java端的代码进行操作。例如，创建Java对象，调用Java对象的方法，获取Java对象中的属性等等。JNIEnv的指针会被JNI传入到本地方法的实现函数中来对Java端的代码进行操作。</p><p>JNIEnv类中有很多函数可以用：</p><p>NewObject:创建Java类中的对象</p><p>NewString:创建Java类中的String对象</p><p>New<type>Array:创建类型为Type的数组对象</type></p><p>Get<type>Field:获取类型为Type的字段</type></p><p>Set<type>Field:设置类型为Type的字段的值</type></p><p>GetStatic<type>Field:获取类型为Type的static的字段</type></p><p>SetStatic<type>Field:设置类型为Type的static的字段的值</type></p><p>Call<type>Method:调用返回类型为Type的方法</type></p><p>CallStatic<type>Method:调用返回值类型为Type的static方法</type></p><p>等许多的函数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JNI是Android中比较重要的一块知识，Java层与C/C++层进行调用的桥梁。所以今天就来学习一下JNI相关的知识。&lt;/p&gt;
&lt;h2 id=&quot;JNI（Java-Native-Interface）&quot;&gt;&lt;a href=&quot;#JNI（Java-Native-Interface
      
    
    </summary>
    
      <category term="Android系统" scheme="http://yoursite.com/categories/Android%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="JNI" scheme="http://yoursite.com/tags/JNI/"/>
    
      <category term="NDK" scheme="http://yoursite.com/tags/NDK/"/>
    
  </entry>
  
  <entry>
    <title>Java动态代理</title>
    <link href="http://yoursite.com/2018/08/15/Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>http://yoursite.com/2018/08/15/Java动态代理/</id>
    <published>2018-08-15T09:27:15.000Z</published>
    <updated>2018-08-19T04:13:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>Java动态代理在平时的开发中经常会听到，感觉挺高大上，但一直没有认真理解其中的原理，今天就来学习一下Java动态代理(最常见的retrofit框架就使用了动态代理)。</p><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>首先我们需要了解下什么是代理模式。代理模式是Java常用的设计模式，它的特征就是代理类与委托类有相同的接口。代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后处理消息等。 代理类与委托类之间通常会存在关联关系，一个代理类的对象与一个委托类的对象关联，代理类的对象本身并不真正实现服务，而是通过调用委托类的对象的相关方法，来提供特定的服务。简单的说就是，我们在访问实际对象时，是通过代理对象来访问的，代理模式就是在访问实际对象时引入一定程度的间接性，因为这种间接性，可以附加多种用途。</p><p><img src="/2018/08/15/Java动态代理/image001.png" alt=""></p><p>按照代理的创建时期，代理类可以被分为两类：</p><ol><li>静态代理(由程序员创建代理类或特定工具自动生成源代码再对其编译。在程序运行前代理类的.class文件就已经存在了)</li><li>动态代理(在程序运行时运用反射机制动态创建而成)</li></ol><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>根据上面代理模式的类图，来写一个简单的静态代理的例子。我这儿举一个比较粗糙的例子，假如一个班的同学要向老师交班费，但是都是通过班长把自己的钱转交给老师。这里，班长就是代理学生上交班费，班长就是学生的代理。</p><p>首先，我们创建一个Person接口。这个接口就是学生（被代理类），和班长（代理类）的公共接口，他们都有上交班费的行为。这样，学生上交班费就可以让班长来代理执行。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建Person接口</span></span><br><span class="line"><span class="comment"> * @author Gonjan</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Person</span> &#123;</span><br><span class="line">    <span class="comment">//上交班费</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">giveMoney</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Student类实现Person接口。Student可以具体实施上交班费的动作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">giveMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(name + <span class="string">"上交班费50元"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StudentsProxy类，这个类也实现了Person接口，但是还另外持有一个学生类对象，由于实现了Peson接口，同时持有一个学生对象，那么他可以代理学生类对象执行上交班费（执行giveMoney()方法）行为。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 学生代理类，也实现了Person接口，保存一个学生实体，这样既可以代理学生产生行为</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Gonjan</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentsProxy</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="comment">//被代理的学生</span></span><br><span class="line">    Student stu;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StudentsProxy</span><span class="params">(Person stu)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 只代理学生对象</span></span><br><span class="line">        <span class="keyword">if</span>(stu.getClass() == Student.class) &#123;</span><br><span class="line">            <span class="keyword">this</span>.stu = (Student)stu;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//代理上交班费，调用被代理学生的上交班费行为</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">giveMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stu.giveMoney();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面测试一下，看如何使用代理模式：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        <span class="comment">//被代理的学生张三，他的班费上交有代理对象monitor（班长）完成</span></span><br><span class="line">        Person zhangsan = <span class="keyword">new</span> <span class="type">Student</span>(<span class="string">"张三"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//生成代理对象，并将张三传给代理对象</span></span><br><span class="line">        Person monitor = <span class="keyword">new</span> <span class="type">StudentsProxy</span>(zhangsan);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//班长代理上交班费</span></span><br><span class="line">        monitor.giveMoney();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/2018/08/15/Java动态代理/prox2.png" alt=""></p><p>这里并没有直接通过张三（被代理对象）来执行上交班费的行为，而是通过班长（代理对象）来代理执行了。这就是代理模式。</p><p>代理模式最主要的就是有一个公共接口（Person），一个具体的类（Student），一个代理类（StudentsProxy）,代理类持有具体类的实例，代为执行具体类实例方法。上面说到，代理模式就是在访问实际对象时引入一定程度的间接性，因为这种间接性，可以附加多种用途。这里的间接性就是指不直接调用实际对象的方法，那么我们在代理过程中就可以加上一些其他用途。就这个例子来说，加入班长在帮张三上交班费之前想要先反映一下张三最近学习有很大进步，通过代理模式很轻松就能办到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentsProxy</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="comment">//被代理的学生</span></span><br><span class="line">    Student stu;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StudentsProxy</span><span class="params">(Person stu)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 只代理学生对象</span></span><br><span class="line">        <span class="keyword">if</span>(stu.getClass() == Student.class) &#123;</span><br><span class="line">            <span class="keyword">this</span>.stu = (Student)stu;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//代理上交班费，调用被代理学生的上交班费行为</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">giveMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"张三最近学习有进步！"</span>);</span><br><span class="line">        stu.giveMoney();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/2018/08/15/Java动态代理/prox3.png" alt=""></p><p>可以看到，只需要在代理类中帮张三上交班费之前，执行其他操作就可以了。这种操作，也是使用代理模式的一个很大的优点。最直白的就是在Spring中的面向切面编程（AOP），我们能在一个切点之前执行一些操作，在一个切点之后执行一些操作，这个切点就是一个个方法。这些方法所在类肯定就是被代理了，在代理过程中切入了一些其他操作。</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>代理类在程序运行时创建的代理方式被成为动态代理。 我们上面静态代理的例子中，代理类(studentProxy)是自己定义好的，在程序运行之前就已经编译完成。然而动态代理，代理类并不是在Java代码中定义的，而是在运行时根据我们在Java代码中的“指示”动态生成的。相比于静态代理， 动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类中的方法。 比如说，想要在每个代理的方法前都加上一个处理方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">giveMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//调用被代理方法前加入处理方法</span></span><br><span class="line">       beforeMethod();</span><br><span class="line">       stu.giveMoney();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这里只有一个giveMoney方法，就写一次beforeMethod方法，但是如果出了giveMonney还有很多其他的方法，那就需要写很多次beforeMethod方法，麻烦。那看看下面动态代理如何实现。</p><h3 id="动态代理的实现"><a href="#动态代理的实现" class="headerlink" title="动态代理的实现"></a>动态代理的实现</h3><p>在java的java.lang.reflect包下提供了一个Proxy类和一个InvocationHandler接口，通过这个类和这个接口可以生成JDK动态代理类和动态代理对象。</p><p>还是上面静态代理的例子，班长需要帮学生代交班费。</p><p>首先是定义一个Person接口:</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建Person接口</span></span><br><span class="line"><span class="comment"> * @author Gonjan</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Person</span> &#123;</span><br><span class="line">    <span class="comment">//上交班费</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">giveMoney</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建需要被代理的实际类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">giveMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//假设数钱花了一秒时间</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">       System.out.println(name + <span class="string">"上交班费50元"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再定义一个检测方法执行时间的工具类，在任何方法执行前先调用start方法，执行后调用finsh方法，就可以计算出该方法的运行时间，这也是一个最简单的方法执行时间检测工具。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MonitorUtil</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Long&gt; tl = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        tl.<span class="keyword">set</span>(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//结束时打印耗时</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">finish</span>(<span class="params">String methodName</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> finishTime = System.currentTimeMillis();</span><br><span class="line">        System.<span class="keyword">out</span>.println(methodName + <span class="string">"方法耗时"</span> + (finishTime - tl.<span class="keyword">get</span>()) + <span class="string">"ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建StuInvocationHandler类，实现InvocationHandler接口，这个类中持有一个被代理对象的实例target。InvocationHandler中有一个invoke方法，所有执行代理对象的方法都会被替换成执行invoke方法。</p><p>再在invoke方法中执行被代理对象target的相应方法。当然，在代理过程中，我们在真正执行被代理对象的方法前加入自己其他处理。这也是Spring中的AOP实现的主要原理，这里还涉及到一个很重要的关于java反射方面的基础知识。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StuInvocationHandler</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">   <span class="comment">//invocationHandler持有的被代理对象</span></span><br><span class="line">    T <span class="keyword">target</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StuInvocationHandler</span><span class="params">(T <span class="keyword">target</span>)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.<span class="keyword">target</span> = <span class="keyword">target</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * proxy:代表动态代理对象</span></span><br><span class="line"><span class="comment">     * method：代表正在执行的方法</span></span><br><span class="line"><span class="comment">     * args：代表调用目标方法时传入的实参</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"代理执行"</span> +method.getName() + <span class="string">"方法"</span>);</span><br><span class="line">     */   </span><br><span class="line">        <span class="comment">//代理过程中插入监测方法,计算该方法耗时</span></span><br><span class="line">        MonitorUtil.start();</span><br><span class="line">        Object result = method.invoke(<span class="keyword">target</span>, args);</span><br><span class="line">        MonitorUtil.finish(method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>做完上面的工作后，我们就可以具体来创建动态代理对象了，我们使用简化的方式创建动态代理对象：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建一个实例对象，这个对象是被代理的对象</span></span><br><span class="line">        Person zhangsan = <span class="keyword">new</span> <span class="type">Student</span>(<span class="string">"张三"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建一个与代理对象相关联的InvocationHandler</span></span><br><span class="line">        InvocationHandler stuHandler = <span class="keyword">new</span> <span class="type">StuInvocationHandler</span>&lt;Person&gt;(zhangsan);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建一个代理对象stuProxy来代理zhangsan，代理对象的每个执行方法都会替换执行Invocation中的invoke方法</span></span><br><span class="line">        Person stuProxy = (Person) Proxy.<span class="keyword">new</span><span class="type">ProxyInstance</span>(Person.class.getClassLoader(), <span class="keyword">new</span> <span class="type">Class</span>&lt;?&gt;[]&#123;Person.class&#125;, stuHandler)；</span><br><span class="line"></span><br><span class="line">       <span class="comment">//代理执行上交班费的方法</span></span><br><span class="line">        stuProxy.giveMoney();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们执行这个ProxyTest类，先想一下，我们创建了一个需要被代理的学生张三，将zhangsan对象传给了stuHandler中，我们在创建代理对象stuProxy时，将stuHandler作为参数了的，上面也有说到所有执行代理对象的方法都会被替换成执行invoke方法，也就是说，最后执行的是StuInvocationHandler中的invoke方法。所以在看到下面的运行结果也就理所当然了。</p><p><img src="/2018/08/15/Java动态代理/prox4.png" alt=""></p><p>上面说到，动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类中的方法。是因为所有被代理执行的方法，都是通过在InvocationHandler中的invoke方法调用的，所以我们只要在invoke方法中统一处理，就可以对所有被代理的方法进行相同的操作了。例如，这里的方法计时，所有的被代理对象执行的方法都会被计时，然而我只做了很少的代码量。</p><p>动态代理的过程，代理对象和被代理对象的关系不像静态代理那样一目了然，清晰明了。因为动态代理的过程中，我们并没有实际看到代理类，也没有很清晰地的看到代理类的具体样子，而且动态代理中被代理对象和代理对象是通过InvocationHandler来完成的代理过程的，其中具体是怎样操作的，为什么代理对象执行的方法都会通过InvocationHandler中的invoke方法来执行。带着这些问题，我们就需要对java动态代理的源码进行简要的分析，弄清楚其中缘由。</p><h2 id="动态代理原理分析"><a href="#动态代理原理分析" class="headerlink" title="动态代理原理分析"></a>动态代理原理分析</h2><p>上面我们利用Proxy类的newProxyInstance方法创建了一个动态代理对象，查看该方法的源码，发现它只是封装了创建动态代理类的步骤：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object newProxyInstance(ClassLoader loader,</span><br><span class="line">                                          <span class="keyword">Class</span>&lt;?&gt;[] interfaces,</span><br><span class="line">                                          InvocationHandler h)</span><br><span class="line">        <span class="keyword">throws</span> IllegalArgumentException</span><br><span class="line">    &#123;</span><br><span class="line">        Objects.requireNonNull(h);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">Class</span>&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line">        <span class="keyword">final</span> SecurityManager sm = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Look up or generate the designated proxy class.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">Class</span>&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Invoke its constructor with the designated invocation handler.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">                checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">            <span class="keyword">final</span> InvocationHandler ih = h;</span><br><span class="line">            <span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">                AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;<span class="keyword">Void</span>&gt;() &#123;</span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">Void</span> run() &#123;</span><br><span class="line">                        cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> Object[]&#123;h&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException|InstantiationException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            Throwable t = e.getCause();</span><br><span class="line">            <span class="keyword">if</span> (t <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (RuntimeException) t;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(t.toString(), t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其实，我们最应该关注的是 Class&lt;?&gt; cl = getProxyClass0(loader, intfs);这句，这里产生了代理类，后面代码中的构造器也是通过这里产生的类来获得，可以看出，这个类的产生就是整个动态代理的关键，由于是动态生成的类文件，我这里不具体进入分析如何产生的这个类文件，只需要知道这个类文件时缓存在java虚拟机中的，我们可以通过下面的方法将其打印到文件里面，一睹真容：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] classFile = ProxyGenerator.generateProxyClass(<span class="string">"$Proxy0"</span>, Student.class.getInterfaces());</span><br><span class="line">        <span class="keyword">String</span> path = <span class="string">"G:/javacode/javase/Test/bin/proxy/StuProxy.class"</span>;</span><br><span class="line">        <span class="built_in">try</span>(FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(path)) &#123;</span><br><span class="line">            fos.<span class="built_in">write</span>(classFile);</span><br><span class="line">            fos.<span class="built_in">flush</span>();</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"代理类class文件写入成功"</span>);</span><br><span class="line">        &#125; <span class="built_in">catch</span> (Exception e) &#123;</span><br><span class="line">           System.out.<span class="built_in">println</span>(<span class="string">"写文件错误"</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>对这个class文件进行反编译，我们看看jdk为我们生成了什么样的内容：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"><span class="keyword">import</span> proxy.Person;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> $Proxy0 <span class="keyword">extends</span> Proxy <span class="keyword">implements</span> Person</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  *注意这里是生成代理类的构造方法，方法参数为InvocationHandler类型，看到这，是不是就有点明白</span></span><br><span class="line"><span class="comment">  *为何代理对象调用方法都是执行InvocationHandler中的invoke方法，而InvocationHandler又持有一个</span></span><br><span class="line"><span class="comment">  *被代理对象的实例，不禁会想难道是....？ 没错，就是你想的那样。</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  *super(paramInvocationHandler)，是调用父类Proxy的构造方法。</span></span><br><span class="line"><span class="comment">  *父类持有：protected InvocationHandler h;</span></span><br><span class="line"><span class="comment">  *Proxy构造方法：</span></span><br><span class="line"><span class="comment">  *    protected Proxy(InvocationHandler h) &#123;</span></span><br><span class="line"><span class="comment">  *         Objects.requireNonNull(h);</span></span><br><span class="line"><span class="comment">  *         this.h = h;</span></span><br><span class="line"><span class="comment">  *     &#125;</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> $Proxy0(InvocationHandler paramInvocationHandler)</span><br><span class="line">    <span class="keyword">throws</span> </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">super</span>(paramInvocationHandler);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//这个静态块本来是在最后的，我把它拿到前面来，方便描述</span></span><br><span class="line">   <span class="keyword">static</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//看看这儿静态块儿里面有什么，是不是找到了giveMoney方法。请记住giveMoney通过反射得到的名字m3，其他的先不管</span></span><br><span class="line">      m1 = <span class="keyword">Class</span>.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, <span class="keyword">new</span> <span class="keyword">Class</span>[] &#123; <span class="keyword">Class</span>.forName(<span class="string">"java.lang.Object"</span>) &#125;);</span><br><span class="line">      m2 = <span class="keyword">Class</span>.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>, <span class="keyword">new</span> <span class="keyword">Class</span>[<span class="number">0</span>]);</span><br><span class="line">      m3 = <span class="keyword">Class</span>.forName(<span class="string">"proxy.Person"</span>).getMethod(<span class="string">"giveMoney"</span>, <span class="keyword">new</span> <span class="keyword">Class</span>[<span class="number">0</span>]);</span><br><span class="line">      m0 = <span class="keyword">Class</span>.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>, <span class="keyword">new</span> <span class="keyword">Class</span>[<span class="number">0</span>]);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (NoSuchMethodException localNoSuchMethodException)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(localNoSuchMethodException.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ClassNotFoundException localClassNotFoundException)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(localClassNotFoundException.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  *这里调用代理对象的giveMoney方法，直接就调用了InvocationHandler中的invoke方法，并把m3传了进去。</span></span><br><span class="line"><span class="comment">  *this.h.invoke(this, m3, null);这里简单，明了。</span></span><br><span class="line"><span class="comment">  *来，再想想，代理对象持有一个InvocationHandler对象，InvocationHandler对象持有一个被代理的对象，</span></span><br><span class="line"><span class="comment">  *再联系到InvacationHandler中的invoke方法。嗯，就是这样。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> giveMoney()</span><br><span class="line">    <span class="keyword">throws</span> </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">this</span>.h.invoke(<span class="keyword">this</span>, m3, <span class="keyword">null</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Error|RuntimeException localError)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">throw</span> localError;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable localThrowable)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(localThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//注意，这里为了节省篇幅，省去了toString，hashCode、equals方法的内容。原理和giveMoney方法一毛一样。</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jdk为我们的生成了一个叫<code>$Proxy0</code>（这个名字后面的0是编号，有多个代理类会一次递增）的代理类，这个类文件时放在内存中的，我们在创建代理对象时，就是通过反射获得这个类的构造方法，然后创建的代理实例。通过对这个生成的代理类源码的查看，我们很容易能看出，动态代理实现的具体过程。</p><p>我们可以对InvocationHandler看做一个中介类，中介类持有一个被代理对象，在invoke方法中调用了被代理对象的相应方法。通过聚合方式持有被代理对象的引用，把外部对invoke的调用最终都转为对被代理对象的调用。</p><p>代理类调用自己方法时，通过自身持有的中介类对象来调用中介类对象的invoke方法，从而达到代理执行被代理对象的方法。也就是说，动态代理通过中介类实现了具体的代理功能。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>生成的代理类：<code>$Proxy0 extends Proxy implements Person</code>，我们看到代理类继承了Proxy类，所以也就决定了java动态代理只能对接口进行代理，Java的继承机制注定了这些动态代理类们无法实现对class的动态代理。<br>上面的动态代理的例子，其实就是AOP的一个简单实现了，在目标对象的方法执行之前和执行之后进行了处理，对方法耗时统计。Spring的AOP实现其实也是用了Proxy和InvocationHandler这两个东西的。</p><p>转自：<a href="https://www.cnblogs.com/gonjan-blog/p/6685611.html" target="_blank" rel="noopener">Gonjian</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java动态代理在平时的开发中经常会听到，感觉挺高大上，但一直没有认真理解其中的原理，今天就来学习一下Java动态代理(最常见的retrofit框架就使用了动态代理)。&lt;/p&gt;
&lt;h2 id=&quot;代理模式&quot;&gt;&lt;a href=&quot;#代理模式&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap源码分析</title>
    <link href="http://yoursite.com/2018/08/13/ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2018/08/13/ConcurrentHashMap源码分析/</id>
    <published>2018-08-13T11:36:53.000Z</published>
    <updated>2018-08-04T05:51:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>HashMap、HashTable是JDK中提供的两种的容器，在平时开发中经常会使用到。但在并发编程中，HashMap可能会导致程序死循环，而HashTable就是在所有涉及对该哈希表操作的方法上都加上了synchronized关键字，进行加锁操作。这么做实现了线程安全，但是效率非常低。因此就有了ConcurrentHashMap。</p><h1 id="JDK1-7"><a href="#JDK1-7" class="headerlink" title="JDK1.7"></a>JDK1.7</h1><p>在JDK1.7中ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。</p><p><img src="/2018/08/13/ConcurrentHashMap源码分析/CHashMap1.png" alt=""></p><p>Segment是一个可重入锁，HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个SegMent数组，Segment的结构和HashMap类似，是一种数组和链表结构。一个Segment里包含了一个HashEntry数组，每个HashEntry是一个链表结构的元素，每个Segment守护着一个HashEntry数组里的元素，当对HashEntry的数据进行修改时，必须先获得与它对应的Segment锁。</p><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>先经过一次再散列，然后使用这个散列值通过散列运算定位到Segment，再通过散列算法定位到元素。get操作的高效之处在于get方法将要使用的共享变量都定义成volatile类型。</p><h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><p>当执行put方法插入数据时，根据key的hash值，在Segment数组中找到相应的位置，如果相应位置的Segment还未初始化，则通过CAS进行赋值，接着执行Segment对象的put方法通过加锁机制插入数据，实现如下：</p><p>线程A和线程B同时执行相同Segment对象的put方法</p><ol><li>线程A执行tryLock()方法成功获取锁，则把HashEntry对象插入到相应的位置；</li><li>线程B获取锁失败，则执行scanAndLockForPut()方法，在scanAndLockForPut方法中，会通过重复执行tryLock()方法尝试获取锁，在多处理器环境下，重复次数为64，单处理器重复次数为1，当执行tryLock()方法的次数超过上限时，则执行lock()方法挂起线程B；</li><li>当线程A执行完插入操作时，会通过unlock()方法释放锁，接着唤醒线程B继续执行；</li></ol><h3 id="size"><a href="#size" class="headerlink" title="size"></a>size</h3><p>Segment中的全局变量count是一个volatile变量。先尝试两次通过不锁住Segment的方式统计各个Segment大小，如果两次统计结果相同，则说明计算出的元素个数是准确的。如果两次结果不同，则给每个Segment加锁，在进行一次计算。</p><h1 id="JDK1-8"><a href="#JDK1-8" class="headerlink" title="JDK1.8"></a>JDK1.8</h1><p>在JDK1.8中已经抛弃了Segment分段锁机制，利用CAS+Synchronized来保证并发更新的安全，底层采用数组+链表+红黑树的存储结构。</p><p><img src="/2018/08/13/ConcurrentHashMap源码分析/CHashMap2.png" alt=""></p><h2 id="1、重要属性"><a href="#1、重要属性" class="headerlink" title="1、重要属性"></a>1、重要属性</h2><p>sizeCtl这个属性在ConcurrentHashMap中出镜率很高，因为它是一个控制标识符，在不同的地方有不同用途，而且它的取值不同，也代表不同的含义。</p><ul><li>负数代表正在进行初始化或扩容操作</li><li>-1代表正在初始化</li><li>-N 表示有N-1个线程正在进行扩容操作</li><li>正数或0代表hash表还没有被初始化，这个数值表示初始化或下一次进行扩容的大小，这一点类似于扩容阈值的概念。还后面可以看到，它的值始终是当前ConcurrentHashMap容量的0.75倍，这与loadfactor是对应的。</li></ul><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 盛装Node元素的数组 它的大小是2的整数次幂</span></span><br><span class="line"><span class="comment">   * Size is always a power of two. Accessed directly by iterators.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Table initialization and resizing control.  When negative, the</span></span><br><span class="line"><span class="comment">   * table is being initialized or resized: -1 for initialization,</span></span><br><span class="line"><span class="comment">   * else -(1 + the number of active resizing threads).  Otherwise,</span></span><br><span class="line"><span class="comment">   * when table is null, holds the initial table size to use upon</span></span><br><span class="line"><span class="comment">   * creation, or 0 for default. After initialization, holds the</span></span><br><span class="line"><span class="comment">   * next element count value upon which to resize the table.</span></span><br><span class="line"><span class="comment">   hash表初始化或扩容时的一个控制位标识量。</span></span><br><span class="line"><span class="comment">   负数代表正在进行初始化或扩容操作</span></span><br><span class="line"><span class="comment">   -1代表正在初始化</span></span><br><span class="line"><span class="comment">   -N 表示有N-1个线程正在进行扩容操作</span></span><br><span class="line"><span class="comment">   正数或0代表hash表还没有被初始化，这个数值表示初始化或下一次进行扩容的大小</span></span><br><span class="line"><span class="comment">   </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl; </span><br><span class="line">  <span class="comment">// 以下两个是用来控制扩容的时候 单线程进入的变量</span></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The number of bits used for generation stamp in sizeCtl.</span></span><br><span class="line"><span class="comment">   * Must be at least 6 for 32bit arrays.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> RESIZE_STAMP_BITS = <span class="number">16</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The bit shift for recording size stamp in sizeCtl.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESIZE_STAMP_SHIFT = <span class="number">32</span> - RESIZE_STAMP_BITS;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Encodings for Node hash fields. See above for explanation.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED     = -<span class="number">1</span>; <span class="comment">// hash值是-1，表示这是一个forwardNode节点</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEBIN   = -<span class="number">2</span>; <span class="comment">// hash值是-2  表示这时一个TreeBin节点</span></span><br></pre></td></tr></table></figure><h2 id="2、重要的类"><a href="#2、重要的类" class="headerlink" title="2、重要的类"></a>2、重要的类</h2><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>Node是最核心的内部类，它包装了key-value键值对，所有插入ConcurrentHashMap的数据都包装在这里面。它与HashMap中的定义很相似，但是但是有一些差别它对value和next属性设置了volatile同步锁(与JDK7的Segment相同)，它不允许调用setValue方法直接改变Node的value域，它增加了find方法辅助map.get()方法。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; &#123;</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V val;</span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中value和next都用volatile修饰，保证并发的可见性。</p><h3 id="TreeNode"><a href="#TreeNode" class="headerlink" title="TreeNode"></a>TreeNode</h3><p>树节点类，另外一个核心的数据结构。当链表长度过长的时候，会转换为TreeNode。但是与HashMap不相同的是，它并不是直接转换为红黑树，而是把这些结点包装成TreeNode放在TreeBin对象中，由TreeBin完成对红黑树的包装。而且TreeNode在ConcurrentHashMap集成自Node类，而并非HashMap中的集成自LinkedHashMap.Entry&lt;K,V&gt;类，也就是说TreeNode带有next指针，这样做的目的是方便基于TreeBin的访问。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Nodes for use in TreeBins</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    static <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode&lt;K</span>,<span class="title">V&gt;</span> <span class="keyword">extends</span> <span class="title">Node&lt;K</span>,<span class="title">V&gt;</span> </span>&#123;</span><br><span class="line">        <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">        <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; left;</span><br><span class="line">        <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; right;</span><br><span class="line">        <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">        boolean red;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span>(int hash, <span class="type">K</span> key, <span class="type">V</span> <span class="keyword">val</span>, <span class="type">Node</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; next,</span><br><span class="line">                 <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; parent) &#123;</span><br><span class="line">            <span class="keyword">super</span>(hash, key, <span class="keyword">val</span>, next);</span><br><span class="line">            <span class="keyword">this</span>.parent = parent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Node</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; find(int h, <span class="type">Object</span> k) &#123;</span><br><span class="line">            <span class="keyword">return</span> findTreeNode(h, k, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Returns the TreeNode (or null if not found) for the given key</span></span><br><span class="line"><span class="comment">         * starting at given root.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; findTreeNode(int h, <span class="type">Object</span> k, <span class="type">Class</span>&lt;?&gt; kc) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; p = <span class="keyword">this</span>;</span><br><span class="line">                do  &#123;</span><br><span class="line">                    int ph, dir; <span class="type">K</span> pk; <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; q;</span><br><span class="line">                    <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; pl = p.left, pr = p.right;</span><br><span class="line">                    <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                        p = pl;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                        p = pr;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (pk != <span class="literal">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                        <span class="keyword">return</span> p;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (pl == <span class="literal">null</span>)</span><br><span class="line">                        p = pr;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="literal">null</span>)</span><br><span class="line">                        p = pl;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> ((kc != <span class="literal">null</span> ||</span><br><span class="line">                              (kc = comparableClassFor(k)) != <span class="literal">null</span>) &amp;&amp;</span><br><span class="line">                             (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>)</span><br><span class="line">                        p = (dir &lt; <span class="number">0</span>) ? pl : pr;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> ((q = pr.findTreeNode(h, k, kc)) != <span class="literal">null</span>)</span><br><span class="line">                        <span class="keyword">return</span> q;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        p = pl;</span><br><span class="line">                &#125; <span class="keyword">while</span> (p != <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="TreeBin"><a href="#TreeBin" class="headerlink" title="TreeBin"></a>TreeBin</h3><p>这个类并不负责包装用户的key、value信息，而是包装的很多TreeNode节点。它代替了TreeNode的根节点，也就是说在实际的ConcurrentHashMap“数组”中，存放的是TreeBin对象，而不是TreeNode对象，这是与HashMap的区别。另外这个类还带有了读写锁。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * TreeNodes used at the heads of bins. TreeBins do not hold user</span></span><br><span class="line"><span class="comment">     * keys or values, but instead point to list of TreeNodes and</span></span><br><span class="line"><span class="comment">     * their root. They also maintain a parasitic read-write lock</span></span><br><span class="line"><span class="comment">     * forcing writers (who hold bin lock) to wait for readers (who do</span></span><br><span class="line"><span class="comment">     * not) to complete before tree restructuring operations.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeBin</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; &#123;</span></span><br><span class="line">        TreeNode&lt;K,V&gt; root;</span><br><span class="line">        <span class="keyword">volatile</span> TreeNode&lt;K,V&gt; first;</span><br><span class="line">        <span class="keyword">volatile</span> Thread waiter;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> lockState;</span><br><span class="line">        <span class="comment">// values for lockState</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WRITER = <span class="number">1</span>; <span class="comment">// set while holding write lock</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WAITER = <span class="number">2</span>; <span class="comment">// set when waiting for write lock</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> READER = <span class="number">4</span>; <span class="comment">// increment value for setting read lock</span></span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ForwardingNode"><a href="#ForwardingNode" class="headerlink" title="ForwardingNode"></a>ForwardingNode</h3><p>一个用于连接两个table的节点类。它包含一个nextTable指针，用于指向下一张表。而且这个节点的key value next指针全部为null，它的hash值为-1. 这里面定义的find的方法是从nextTable里进行查询节点，而不是以自身为头节点进行查找。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Encapsulates traversal for methods such as containsValue; also</span></span><br><span class="line"><span class="comment">    * serves as a base class for other iterators and spliterators.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * Method advance visits once each still-valid node that was</span></span><br><span class="line"><span class="comment">    * reachable upon iterator construction. It might miss some that</span></span><br><span class="line"><span class="comment">    * were added to a bin after the bin was visited, which is OK wrt</span></span><br><span class="line"><span class="comment">    * consistency guarantees. Maintaining this property in the face</span></span><br><span class="line"><span class="comment">    * of possible ongoing resizes requires a fair amount of</span></span><br><span class="line"><span class="comment">    * bookkeeping state that is difficult to optimize away amidst</span></span><br><span class="line"><span class="comment">    * volatile accesses.  Even so, traversal maintains reasonable</span></span><br><span class="line"><span class="comment">    * throughput.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * Normally, iteration proceeds bin-by-bin traversing lists.</span></span><br><span class="line"><span class="comment">    * However, if the table has been resized, then all future steps</span></span><br><span class="line"><span class="comment">    * must traverse both the bin at the current index as well as at</span></span><br><span class="line"><span class="comment">    * (index + baseSize); and so on for further resizings. To</span></span><br><span class="line"><span class="comment">    * paranoically cope with potential sharing by users of iterators</span></span><br><span class="line"><span class="comment">    * across threads, iteration terminates if a bounds checks fails</span></span><br><span class="line"><span class="comment">    * for a table read.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Traverser</span>&lt;K,V&gt; &#123;</span></span><br><span class="line">       Node&lt;K,V&gt;[] tab;        <span class="comment">// current table; updated if resized</span></span><br><span class="line">       Node&lt;K,V&gt; next;         <span class="comment">// the next entry to use</span></span><br><span class="line">       TableStack&lt;K,V&gt; <span class="built_in">stack</span>, spare; <span class="comment">// to save/restore on ForwardingNodes</span></span><br><span class="line">       <span class="keyword">int</span> index;              <span class="comment">// index of bin to use next</span></span><br><span class="line">       <span class="keyword">int</span> baseIndex;          <span class="comment">// current index of initial table</span></span><br><span class="line">       <span class="keyword">int</span> baseLimit;          <span class="comment">// index bound for initial table</span></span><br><span class="line">       final <span class="keyword">int</span> baseSize;     <span class="comment">// initial table size</span></span><br><span class="line">       ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、核心方法"><a href="#3、核心方法" class="headerlink" title="3、核心方法"></a>3、核心方法</h2><p>ConcurrentHashMap定义了三个原子操作，用于对指定位置的节点进行操作。正是这些原子操作保证了ConcurrentHashMap的线程安全。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  //获得在i位置上的<span class="keyword">Node</span><span class="title">节点</span></span><br><span class="line"><span class="title">  static</span> final <span class="tag">&lt;K,V&gt;</span> <span class="keyword">Node</span><span class="title">&lt;K</span>,V&gt; tabAt(<span class="keyword">Node</span><span class="title">&lt;K</span>,V&gt;[] tab, int i) &#123;</span><br><span class="line">      return (<span class="keyword">Node</span><span class="title">&lt;K</span>,V&gt;)U.getObjectVolatile(tab, ((long)i <span class="tag">&lt;&lt; ASHIFT) + ABASE);</span></span><br><span class="line"><span class="tag">  &#125;</span></span><br><span class="line"><span class="tag">//利用CAS算法设置i位置上的Node节点。之所以能实现并发是因为他指定了原来这个节点的值是多少</span></span><br><span class="line"><span class="tag">   static final &lt;K,V&gt;</span> boolean casTabAt(<span class="keyword">Node</span><span class="title">&lt;K</span>,V&gt;[] tab, int i,</span><br><span class="line">                                      <span class="keyword">Node</span><span class="title">&lt;K</span>,V&gt; c, <span class="keyword">Node</span><span class="title">&lt;K</span>,V&gt; v) &#123;</span><br><span class="line">      return U.compareAndSwapObject(tab, ((long)i <span class="tag">&lt;&lt; ASHIFT) + ABASE, c, v);</span></span><br><span class="line"><span class="tag">  &#125;</span></span><br><span class="line"><span class="tag">//利用volatile方法设置节点位置的值</span></span><br><span class="line"><span class="tag">  static final &lt;K,V&gt;</span> void setTabAt(<span class="keyword">Node</span><span class="title">&lt;K</span>,V&gt;[] tab, int i, <span class="keyword">Node</span><span class="title">&lt;K</span>,V&gt; v) &#123;</span><br><span class="line">      U.putObjectVolatile(tab, ((long)i <span class="tag">&lt;&lt; ASHIFT) + ABASE, v);</span></span><br><span class="line"><span class="tag">  &#125;</span></span><br></pre></td></tr></table></figure><h2 id="3-1-初始化"><a href="#3-1-初始化" class="headerlink" title="3.1 初始化"></a>3.1 初始化</h2><p>对于ConcurrentHashMap来说，调用它的构造方法仅仅是设置了一些参数而已。而整个table的初始化是在向ConcurrentHashMap中插入元素的时候发生的。如调用put、computeIfAbsent、compute、merge等方法的时候，调用时机是检查table==null。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Initializes table, using the size recorded in sizeCtl.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   private final Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">       Node&lt;K,V&gt;[] <span class="keyword">tab</span>; int <span class="keyword">sc</span>;</span><br><span class="line">       <span class="keyword">while</span> ((<span class="keyword">tab</span> = <span class="keyword">table</span>) == null || <span class="keyword">tab</span>.length == 0) &#123;</span><br><span class="line">           <span class="comment">//sizeCtl表示有其他线程正在进行初始化操作，把线程挂起。对于table的初始化工作，只能有一个线程在进行。</span></span><br><span class="line">           <span class="keyword">if</span> ((<span class="keyword">sc</span> = sizeCtl) &lt; 0)</span><br><span class="line">               Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">U</span>.compareAndSwapInt(this, SIZECTL, <span class="keyword">sc</span>, -1)) &#123;<span class="comment">//利用CAS方法把sizectl的值置为-1 表示本线程正在进行初始化</span></span><br><span class="line">               try &#123;</span><br><span class="line">                   <span class="keyword">if</span> ((<span class="keyword">tab</span> = <span class="keyword">table</span>) == null || <span class="keyword">tab</span>.length == 0) &#123;</span><br><span class="line">                       int <span class="keyword">n</span> = (<span class="keyword">sc</span> &gt; 0) ? <span class="keyword">sc</span> : DEFAULT_CAPACITY;</span><br><span class="line">                       @SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line">                       Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[<span class="keyword">n</span>];</span><br><span class="line">                       <span class="keyword">table</span> = <span class="keyword">tab</span> = nt;</span><br><span class="line">                       <span class="keyword">sc</span> = <span class="keyword">n</span> - (<span class="keyword">n</span> &gt;&gt;&gt; 2); <span class="comment">//相当于0.75*n 设置一个扩容的阈值</span></span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; finally &#123;</span><br><span class="line">                   sizeCtl = <span class="keyword">sc</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">tab</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-扩容"><a href="#3-2-扩容" class="headerlink" title="3.2 扩容"></a>3.2 扩容</h2><ol><li><p>如果新增节点之后，所在链表的元素个数达到了阈值 8，则会调用treeifyBin方法把链表转换成红黑树,不过在结构转换之前，会对数组长度进行判断,如果数组长度n小于阈值MIN_TREEIFY_CAPACITY，默认是64，则会调用tryPresize方法把数组长度扩大到原来的两倍，并触发transfer方法，重新调整节点的位置。</p></li><li><p>新增节点之后，会调用addCount方法记录元素个数，并检查是否需要进行扩容，当数组元素个数达到阈值时，会触发transfer方法，重新调整节点的位置。</p></li></ol><h3 id="transfer实现"><a href="#transfer实现" class="headerlink" title="transfer实现"></a>transfer实现</h3><p>整个扩容操作分为两个部分：</p><ol><li><p>第一部分是构建一个nextTable,它的容量是原来的两倍，这个操作是单线程完成的。这个单线程的保证是通过RESIZE_STAMP_SHIFT这个常量经过一次运算来保证的；</p></li><li><p>第二个部分就是将原来table中的元素复制到nextTable中，这里允许多线程进行操作。</p></li></ol><p>先来看一下单线程是如何完成的，它的大体思想就是遍历、复制的过程。首先根据运算得到需要遍历的次数i，然后利用tabAt方法获得i位置的元素：</p><ol><li><p>如果这个位置为空，就在原table中的i位置放入forwardNode节点，这个也是触发并发扩容的关键点；</p></li><li><p>如果这个位置是Node节点（fh&gt;=0），如果它是一个链表的头节点，就构造一个反序链表，把他们分别放在nextTable的i和i+n的位置上</p></li><li><p>如果这个位置是TreeBin节点（fh&lt;0），也做一个反序处理，并且判断是否需要untreefi，把处理的结果分别放在nextTable的i和i+n的位置上</p></li><li><p>遍历过所有的节点以后就完成了复制工作，这时让nextTable作为新的table，并且更新sizeCtl为新容量的0.75倍 ，完成扩容。</p></li></ol><p>再看一下多线程是如何完成的：</p><p>如果遍历到的节点是forward节点，就向后继续遍历，再加上给节点上锁的机制，就完成了多线程的控制。多线程遍历节点，处理了一个节点，就把对应点的值set为forward，另一个线程看到forward，就向后遍历。这样交叉就完成了复制工作。而且还很好的解决了线程安全的问题。</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Moves and/or copies the nodes in each bin to new table. See</span></span><br><span class="line"><span class="comment"> * above for explanation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) &#123;</span><br><span class="line">    int <span class="attr">n</span> = tab.length, stride;</span><br><span class="line">    // 将 length / <span class="number">8</span> 然后除以 CPU核心数。如果得到的结果小于 <span class="number">16</span>，那么就使用 <span class="number">16</span>。</span><br><span class="line">    // 这里的目的是让每个 CPU 处理的桶一样多，避免出现转移任务不均匀的现象，如果桶较少的话，默认一个 CPU（一个线程）处理 <span class="number">16</span> 个桶</span><br><span class="line">    <span class="keyword">if</span> ((<span class="attr">stride</span> = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        <span class="attr">stride</span> = MIN_TRANSFER_STRIDE; // subdivide range</span><br><span class="line">    <span class="keyword">if</span> (<span class="attr">nextTab</span> == <span class="literal">null</span>) &#123;            // initiating</span><br><span class="line">        try &#123;</span><br><span class="line">            @SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line">            Node&lt;K,V&gt;[] <span class="attr">nt</span> = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];//构造一个nextTable对象 它的容量是原来的两倍</span><br><span class="line">            <span class="attr">nextTab</span> = nt;</span><br><span class="line">        &#125; catch (Throwable ex) &#123;      // try to cope <span class="keyword">with</span> OOME</span><br><span class="line">            <span class="attr">sizeCtl</span> = Integer.MAX_VALUE;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attr">nextTable</span> = nextTab;</span><br><span class="line">        <span class="attr">transferIndex</span> = n;</span><br><span class="line">    &#125;</span><br><span class="line">    int <span class="attr">nextn</span> = nextTab.length;</span><br><span class="line">    ForwardingNode&lt;K,V&gt; <span class="attr">fwd</span> = new ForwardingNode&lt;K,V&gt;(nextTab);//构造一个连节点指针 用于标志位</span><br><span class="line">    boolean <span class="attr">advance</span> = <span class="literal">true</span>;//并发扩容的关键属性 如果等于<span class="literal">true</span> 说明这个节点已经处理过</span><br><span class="line">    boolean <span class="attr">finishing</span> = <span class="literal">false</span>; // to ensure sweep before committing nextTab</span><br><span class="line">    for (int <span class="attr">i</span> = <span class="number">0</span>, <span class="attr">bound</span> = <span class="number">0</span>;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; int fh;</span><br><span class="line">        //这个while循环体的作用就是在控制i--  通过i--可以依次遍历原hash表中的节点</span><br><span class="line">        while (advance) &#123;</span><br><span class="line">            int nextIndex, nextBound;</span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                <span class="attr">advance</span> = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="attr">nextIndex</span> = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="attr">i</span> = -<span class="number">1</span>;</span><br><span class="line">                <span class="attr">advance</span> = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                     (this, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      <span class="attr">nextBound</span> = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="attr">bound</span> = nextBound;</span><br><span class="line">                <span class="attr">i</span> = nextIndex - <span class="number">1</span>;</span><br><span class="line">                <span class="attr">advance</span> = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            int sc;</span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                //如果所有的节点都已经完成复制工作  就把nextTable赋值给table 清空临时对象nextTable</span><br><span class="line">                <span class="attr">nextTable</span> = <span class="literal">null</span>;</span><br><span class="line">                <span class="attr">table</span> = nextTab;</span><br><span class="line">                <span class="attr">sizeCtl</span> = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);//扩容阈值设置为原来容量的<span class="number">1.5</span>倍  依然相当于现在容量的<span class="number">0.75</span>倍</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            //利用CAS方法更新这个扩容阈值，在这里面sizectl值减一，说明新加入一个线程参与到扩容操作</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(this, SIZECTL, <span class="attr">sc</span> = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    return;</span><br><span class="line">                <span class="attr">finishing</span> = <span class="attr">advance</span> = <span class="literal">true</span>;</span><br><span class="line">                <span class="attr">i</span> = n; // recheck before commit</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果遍历到的节点为空 则放入ForwardingNode指针</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="attr">f</span> = tabAt(tab, i)) == <span class="literal">null</span>)</span><br><span class="line">            <span class="attr">advance</span> = casTabAt(tab, i, <span class="literal">null</span>, fwd);</span><br><span class="line">        //如果遍历到ForwardingNode节点  说明这个点已经被处理过了 直接跳过  这里是控制并发扩容的核心</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="attr">fh</span> = f.hash) == MOVED)</span><br><span class="line">            <span class="attr">advance</span> = <span class="literal">true</span>; // already processed</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            //节点上锁</span><br><span class="line">            synchronized (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                    //如果fh&gt;=<span class="number">0</span> 证明这是一个Node节点</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        int <span class="attr">runBit</span> = fh &amp; n;</span><br><span class="line">                        //以下的部分在完成的工作是构造两个链表  一个是原链表  另一个是原链表的反序排列</span><br><span class="line">                        Node&lt;K,V&gt; <span class="attr">lastRun</span> = f;</span><br><span class="line">                        for (Node&lt;K,V&gt; <span class="attr">p</span> = f.next; p != <span class="literal">null</span>; <span class="attr">p</span> = p.next) &#123;</span><br><span class="line">                            int <span class="attr">b</span> = p.hash &amp; n;</span><br><span class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                <span class="attr">runBit</span> = b;</span><br><span class="line">                                <span class="attr">lastRun</span> = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="attr">runBit</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="attr">ln</span> = lastRun;</span><br><span class="line">                            <span class="attr">hn</span> = <span class="literal">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="attr">hn</span> = lastRun;</span><br><span class="line">                            <span class="attr">ln</span> = <span class="literal">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        for (Node&lt;K,V&gt; <span class="attr">p</span> = f; p != lastRun; <span class="attr">p</span> = p.next) &#123;</span><br><span class="line">                            int <span class="attr">ph</span> = p.hash; K <span class="attr">pk</span> = p.key; V <span class="attr">pv</span> = p.val;</span><br><span class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                <span class="attr">ln</span> = new Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                <span class="attr">hn</span> = new Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line">                        //在nextTable的i位置上插入一个链表</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        //在nextTable的i+n的位置上插入另一个链表</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        //在table的i位置上插入forwardNode节点  表示已经处理过该节点</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        //设置advance为<span class="literal">true</span> 返回到上面的while循环中 就可以执行i--操作</span><br><span class="line">                        <span class="attr">advance</span> = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //对TreeBin对象进行处理  与上面的过程类似</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f instanceof TreeBin) &#123;</span><br><span class="line">                        TreeBin&lt;K,V&gt; <span class="attr">t</span> = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; <span class="attr">lo</span> = <span class="literal">null</span>, <span class="attr">loTail</span> = <span class="literal">null</span>;</span><br><span class="line">                        TreeNode&lt;K,V&gt; <span class="attr">hi</span> = <span class="literal">null</span>, <span class="attr">hiTail</span> = <span class="literal">null</span>;</span><br><span class="line">                        int <span class="attr">lc</span> = <span class="number">0</span>, <span class="attr">hc</span> = <span class="number">0</span>;</span><br><span class="line">                        //构造正序和反序两个链表</span><br><span class="line">                        for (Node&lt;K,V&gt; <span class="attr">e</span> = t.first; e != <span class="literal">null</span>; <span class="attr">e</span> = e.next) &#123;</span><br><span class="line">                            int <span class="attr">h</span> = e.hash;</span><br><span class="line">                            TreeNode&lt;K,V&gt; <span class="attr">p</span> = new TreeNode&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">                            <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.<span class="attr">prev</span> = loTail) == <span class="literal">null</span>)</span><br><span class="line">                                    <span class="attr">lo</span> = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.<span class="attr">next</span> = p;</span><br><span class="line">                                <span class="attr">loTail</span> = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.<span class="attr">prev</span> = hiTail) == <span class="literal">null</span>)</span><br><span class="line">                                    <span class="attr">hi</span> = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.<span class="attr">next</span> = p;</span><br><span class="line">                                <span class="attr">hiTail</span> = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        //如果扩容后已经不再需要tree的结构 反向转换为链表结构</span><br><span class="line">                        <span class="attr">ln</span> = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                            (hc != <span class="number">0</span>) ? new TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        <span class="attr">hn</span> = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                            (lc != <span class="number">0</span>) ? new TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                        //在nextTable的i位置上插入一个链表  </span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        //在nextTable的i+n的位置上插入另一个链表</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        //在table的i位置上插入forwardNode节点  表示已经处理过该节点</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        //设置advance为<span class="literal">true</span> 返回到上面的while循环中 就可以执行i--操作</span><br><span class="line">                        <span class="attr">advance</span> = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-put"><a href="#3-3-put" class="headerlink" title="3.3 put"></a>3.3 put</h2><p>这个put方法依然沿用HashMap的put方法的思想，根据hash值计算这个新插入的点在table中的位置i，如果i位置是空的，直接放进去，否则进行判断，如果i位置是树节点，按照树的方式插入新的节点，否则把i插入到链表的末尾。ConcurrentHashMap中依然沿用这个思想，有一个最重要的不同点就是ConcurrentHashMap不允许key或value为null值。另外由于涉及到多线程，put方法就要复杂一点。在多线程中可能有以下两个情况:</p><ol><li><p>如果一个或多个线程正在对ConcurrentHashMap进行扩容操作，当前线程也要进入扩容的操作中。这个扩容的操作之所以能被检测到，是因为transfer方法中在空结点上插入forward节点，如果检测到需要插入的位置被forward节点占有，就帮助进行扩容；</p></li><li><p>如果检测到要插入的节点是非空且不是forward节点，就对这个节点加锁，这样就保证了线程安全。尽管这个有一些影响效率，但是还是会比hashTable的synchronized要好得多。‘</p></li></ol><p>整体流程就是首先定义不允许key或value为null的情况放入  对于每一个放入的值，首先利用spread方法对key的hashcode进行一次hash计算，由此来确定这个值在table中的位置。</p><p>如果这个位置是空的，那么直接放入，而且不需要加锁操作。</p><p> 如果这个位置存在结点，说明发生了hash碰撞，首先判断这个节点的类型。如果是链表节点（fh&gt;0）,则得到的结点就是hash值相同的节点组成的链表的头节点。需要依次向后遍历确定这个新加入的值所在位置。如果遇到hash值与key值都与新加入节点是一致的情况，则只需要更新value值即可。否则依次向后遍历，直到链表尾插入这个结点。如果加入这个节点以后链表长度大于8，就把这个链表转换成红黑树。如果这个节点的类型已经是树节点的话，直接调用树节点的插入方法进行插入新的值。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Maps the specified key to the specified value in this table.</span></span><br><span class="line"><span class="comment">   * Neither the key nor the value can be null.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;The value can be retrieved by calling the &#123;@code get&#125; method</span></span><br><span class="line"><span class="comment">   * with a key that is equal to the original key.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @param key key with which the specified value is to be associated</span></span><br><span class="line"><span class="comment">   * @param value value to be associated with the specified key</span></span><br><span class="line"><span class="comment">   * @return the previous value associated with &#123;@code key&#125;, or</span></span><br><span class="line"><span class="comment">   *         &#123;@code null&#125; if there was no mapping for &#123;@code key&#125;</span></span><br><span class="line"><span class="comment">   * @throws NullPointerException if the specified key or value is null</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  public V put(K <span class="built_in">key</span>, V value) &#123;</span><br><span class="line">      <span class="keyword">return</span> putVal(<span class="built_in">key</span>, value, false);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line">  final V putVal(K <span class="built_in">key</span>, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">key</span> == <span class="built_in">null</span> || value == <span class="built_in">null</span>) throw <span class="keyword">new</span> NullPointerException();</span><br><span class="line">      int hash = spread(<span class="built_in">key</span>.hashCode());</span><br><span class="line">      int binCount = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">//死循环 何时插入成功 何时跳出</span></span><br><span class="line">      <span class="keyword">for</span> (Node&lt;K,V&gt;[] <span class="built_in">tab</span> = table;;) &#123;</span><br><span class="line">          Node&lt;K,V&gt; f; int n, i, fh;</span><br><span class="line">          <span class="comment">//如果table为空的话，初始化table</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">tab</span> == <span class="built_in">null</span> || (n = <span class="built_in">tab</span>.length) == <span class="number">0</span>)</span><br><span class="line">              <span class="built_in">tab</span> = initTable();</span><br><span class="line">          <span class="comment">//根据hash值计算出在table里面的位置 </span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(<span class="built_in">tab</span>, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="built_in">null</span>) &#123;</span><br><span class="line">              <span class="comment">//如果这个位置没有值 ，直接放进去，不需要加锁</span></span><br><span class="line">              <span class="keyword">if</span> (casTabAt(<span class="built_in">tab</span>, i, <span class="built_in">null</span>,</span><br><span class="line">                           <span class="keyword">new</span> Node&lt;K,V&gt;(hash, <span class="built_in">key</span>, value, <span class="built_in">null</span>)))</span><br><span class="line">                  <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//当遇到表连接点时，需要进行整合表的操作</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">              <span class="built_in">tab</span> = helpTransfer(<span class="built_in">tab</span>, f);</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">              V oldVal = <span class="built_in">null</span>;</span><br><span class="line">              <span class="comment">//结点上锁  这里的结点可以理解为hash值相同组成的链表的头结点</span></span><br><span class="line">              synchronized (f) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (tabAt(<span class="built_in">tab</span>, i) == f) &#123;</span><br><span class="line">                      <span class="comment">//fh&gt;0 说明这个节点是一个链表的节点 不是树的节点</span></span><br><span class="line">                      <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                          binCount = <span class="number">1</span>;</span><br><span class="line">                          <span class="comment">//在这里遍历链表所有的结点</span></span><br><span class="line">                          <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                              K ek;</span><br><span class="line">                              <span class="comment">//如果hash值和key值相同  则修改对应结点的value值</span></span><br><span class="line">                              <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                  ((ek = e.<span class="built_in">key</span>) == <span class="built_in">key</span> ||</span><br><span class="line">                                   (ek != <span class="built_in">null</span> &amp;&amp; <span class="built_in">key</span>.equals(ek)))) &#123;</span><br><span class="line">                                  oldVal = e.val;</span><br><span class="line">                                  <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                      e.val = value;</span><br><span class="line">                                  <span class="keyword">break</span>;</span><br><span class="line">                              &#125;</span><br><span class="line">                              Node&lt;K,V&gt; pred = e;</span><br><span class="line">                              <span class="comment">//如果遍历到了最后一个结点，那么就证明新的节点需要插入 就把它插入在链表尾部</span></span><br><span class="line">                              <span class="keyword">if</span> ((e = e.next) == <span class="built_in">null</span>) &#123;</span><br><span class="line">                                  pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, <span class="built_in">key</span>,</span><br><span class="line">                                                            value, <span class="built_in">null</span>);</span><br><span class="line">                                  <span class="keyword">break</span>;</span><br><span class="line">                              &#125;</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                      <span class="comment">//如果这个节点是树节点，就按照树的方式插入值</span></span><br><span class="line">                      <span class="keyword">else</span> <span class="keyword">if</span> (f instanceof TreeBin) &#123;</span><br><span class="line">                          Node&lt;K,V&gt; p;</span><br><span class="line">                          binCount = <span class="number">2</span>;</span><br><span class="line">                          <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, <span class="built_in">key</span>,</span><br><span class="line">                                                         value)) != <span class="built_in">null</span>) &#123;</span><br><span class="line">                              oldVal = p.val;</span><br><span class="line">                              <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                  p.val = value;</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                  <span class="comment">//如果链表长度已经达到临界值8 就需要把链表转换为树结构</span></span><br><span class="line">                  <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                      treeifyBin(<span class="built_in">tab</span>, i);</span><br><span class="line">                  <span class="keyword">if</span> (oldVal != <span class="built_in">null</span>)</span><br><span class="line">                      <span class="keyword">return</span> oldVal;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//将当前ConcurrentHashMap的元素数量+1</span></span><br><span class="line">      addCount(<span class="number">1</span>L, binCount);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>我们可以发现JDK8中的实现也是锁分离的思想，只是锁住的是一个Node，而不是JDK7中的Segment，而锁住Node之前的操作是无锁的并且也是线程安全的，建立在之前提到的3个原子操作上。</p><h2 id="3-4-get"><a href="#3-4-get" class="headerlink" title="3.4 get"></a>3.4 get</h2><p>get方法比较简单，给定一个key来确定value的时候，必须满足两个条件  key相同  hash值相同，对于节点可能在链表或树上的情况，需要分别去查找。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="built_in">get</span>(<span class="keyword">Object</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="built_in">int</span> n, eh; K ek;</span><br><span class="line">        <span class="comment">//计算hash值</span></span><br><span class="line">        <span class="built_in">int</span> h = spread(<span class="built_in">key</span>.hashCode());</span><br><span class="line">        <span class="comment">//根据hash值确定节点位置</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果搜索到的节点key与传入的key相同且不为null,直接返回这个节点</span></span><br><span class="line">            <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((ek = e.<span class="built_in">key</span>) == <span class="built_in">key</span> || (ek != <span class="keyword">null</span> &amp;&amp; <span class="built_in">key</span>.equals(ek)))</span><br><span class="line">                    <span class="keyword">return</span> e.val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果eh&lt;0 说明这个节点在树上 直接寻找</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> (p = e.find(h, <span class="built_in">key</span>)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">             <span class="comment">//否则遍历链表 找到对应的值并返回</span></span><br><span class="line">            <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                    ((ek = e.<span class="built_in">key</span>) == <span class="built_in">key</span> || (ek != <span class="keyword">null</span> &amp;&amp; <span class="built_in">key</span>.equals(ek))))</span><br><span class="line">                    <span class="keyword">return</span> e.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;HashMap、HashTable是JDK中提供的两种的容器，在平时开发中经常会使用到。但在并发编程中，HashMap可能会导致程序死循环，而HashTable就是在所有涉及对该哈希表操作的方法上都加上了synchronized关键字，进行加锁操作。这么做实现了线程安全，但
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal解析</title>
    <link href="http://yoursite.com/2018/08/13/ThreadLocal%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2018/08/13/ThreadLocal解析/</id>
    <published>2018-08-13T01:27:38.000Z</published>
    <updated>2018-08-13T03:25:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>在面试中，ThreadLocal是一个经常会被问到的知识点，所以今天就好好分析一下它的实现原理。(基于JDK1.8)</p><h2 id="什么是ThreadLocal"><a href="#什么是ThreadLocal" class="headerlink" title="什么是ThreadLocal"></a>什么是ThreadLocal</h2><p>ThreadLocal是一个数据结构，类似于HashMap，可以保存key:value键值对，但是一个ThreadLocal只能保存一个，并且各个线程之间的数据互不干扰。</p><p>看下它的<code>set(T value)</code>和<code>get()</code>方法的源码</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="literal">void</span> <span class="built_in">set</span>(T value) &#123;</span><br><span class="line">     <span class="keyword">Thread</span> t = <span class="keyword">Thread</span>.currentThread();</span><br><span class="line">     ThreadLocalMap <span class="built_in">map</span> = getMap(t);</span><br><span class="line">     <span class="keyword">if</span> (<span class="built_in">map</span> != <span class="built_in">null</span>)</span><br><span class="line">         <span class="built_in">map</span>.<span class="built_in">set</span>(this, value);</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">         createMap(t, value);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="keyword">public</span> T get() &#123;</span><br><span class="line">     <span class="keyword">Thread</span> t = <span class="keyword">Thread</span>.currentThread();</span><br><span class="line">     ThreadLocalMap <span class="built_in">map</span> = getMap(t);</span><br><span class="line">     <span class="keyword">if</span> (<span class="built_in">map</span> != <span class="built_in">null</span>) &#123;</span><br><span class="line">         ThreadLocalMap.Entry e = <span class="built_in">map</span>.getEntry(this);</span><br><span class="line">         <span class="keyword">if</span> (e != <span class="built_in">null</span>) &#123;</span><br><span class="line">             @SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line">             T result = (T)e.value;</span><br><span class="line">             <span class="keyword">return</span> result;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> setInitialValue();</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> ThreadLocalMap getMap(<span class="keyword">Thread</span> t) &#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>可以看到每个线程中都会有一个<code>ThreadLocal</code>数据结构，set方法是将值保存到当前线程中的<code>threadLocals</code>变量中，get方法是从当前线程中的<code>threadLocals</code>变量中获取。所以对于线程1中的数据在线程2中是无法访问的，保证了线程之间的互不干扰。</p><p>那接下来就看其中的关键类<code>ThreadLocalMap</code>是什么了。</p><h2 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h2><p>ThreadLocalMap是ThreadLocal的一个静态内部类。它也是Thread类的一个属性。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">  static <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">       static <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</span> </span>&#123;</span><br><span class="line">            <span class="type">Object</span> value;</span><br><span class="line"></span><br><span class="line">            <span class="type">Entry</span>(<span class="type">ThreadLocal</span>&lt;?&gt; k, <span class="type">Object</span> v) &#123;</span><br><span class="line">                <span class="keyword">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 初始化大小，必须是二的幂.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> static <span class="keyword">final</span> int <span class="type">INITIAL_CAPACITY</span> = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The table, resized as necessary.</span></span><br><span class="line"><span class="comment">         * table.length MUST always be a power of two.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">Entry</span>[] table;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The number of entries in the table.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> int size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The next size value at which to resize.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> int threshold; <span class="comment">// Default to 0</span></span><br><span class="line"> </span><br><span class="line">               </span><br><span class="line">    <span class="type">ThreadLocalMap</span>(<span class="type">ThreadLocal</span>&lt;?&gt; firstKey, <span class="type">Object</span> firstValue) &#123;</span><br><span class="line">            table = <span class="keyword">new</span> <span class="type">Entry</span>[<span class="type">INITIAL_CAPACITY</span>];</span><br><span class="line">            int i = firstKey.threadLocalHashCode &amp; (<span class="type">INITIAL_CAPACITY</span> - <span class="number">1</span>);</span><br><span class="line">            table[i] = <span class="keyword">new</span> <span class="type">Entry</span>(firstKey, firstValue);</span><br><span class="line">            size = <span class="number">1</span>;</span><br><span class="line">            setThreshold(<span class="type">INITIAL_CAPACITY</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ThreadLocal中，初始化了一个大小为16的Entry数组，Entry对象用来保存key-value键值对，只不过在这里key永远都是ThreadLocal对象(<code>map.set(this, value);</code>)。</p><p>Entry继承的是WeakReference，并且Entry中没有next字段，所以不会形成链表。</p><p>Thread、ThreadLocal和ThreadLocalMap的关系</p><p><img src="/2018/08/13/ThreadLocal解析/threadlocal1.png" alt=""></p><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="built_in">set</span>(ThreadLocal&lt;?&gt; <span class="built_in">key</span>, <span class="keyword">Object</span> value) &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="built_in">int</span> len = tab.length;</span><br><span class="line">    <span class="built_in">int</span> i = <span class="built_in">key</span>.threadLocalHashCode &amp; (len<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="built_in">key</span>) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(<span class="built_in">key</span>, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry(<span class="built_in">key</span>, value);</span><br><span class="line">    <span class="built_in">int</span> sz = ++<span class="built_in">size</span>;</span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>由于Entry是继承WeakReference，这就导致了在ThreadLocal没有外部强引用时，发生GC时就会被回收，如果创建ThreadLocal的线程一直持续运行，那么这个Entry对象中的value就有可能一直得不到回收，发生内存泄露。</p><h3 id="如何避免内存泄露"><a href="#如何避免内存泄露" class="headerlink" title="如何避免内存泄露"></a>如何避免内存泄露</h3><p>remove方法，如果使用ThreadLocal的set方法之后，没有显示的调用remove方法，就有可能发生内存泄露，所以养成良好的编程习惯十分重要，使用完ThreadLocal之后，记得调用remove方法。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;String&gt; localName = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    localName.<span class="keyword">set</span>(<span class="string">"哈哈"</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    localName.<span class="keyword">remove</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在面试中，ThreadLocal是一个经常会被问到的知识点，所以今天就好好分析一下它的实现原理。(基于JDK1.8)&lt;/p&gt;
&lt;h2 id=&quot;什么是ThreadLocal&quot;&gt;&lt;a href=&quot;#什么是ThreadLocal&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>HashMap源码分析</title>
    <link href="http://yoursite.com/2018/08/12/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2018/08/12/HashMap源码分析/</id>
    <published>2018-08-12T05:31:13.000Z</published>
    <updated>2018-08-04T07:06:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>在JDK1.6，JDK1.7中，HashMap采用位桶+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，HashMap采用位桶+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。这里就主要研究一下JDK1.8的HashMap源码。</p><p>先简单说下HashMap的实现原理：</p><p>首先有一个每个元素都是链表的数组，当添加一个元素（key-value）时，就首先计算元素key的hash值，以此确定插入数组中的位置，但是可能存在同一hash值的元素已经被放在数组同一位置了，这时就添加到同一hash值的元素的后面，他们在数组的同一位置，但是形成了链表，同一各链表上的Hash值是相同的，所以说数组存放的是链表。而当链表长度太长时，链表就转换为红黑树，这样大大提高了查找的效率。</p><p>当链表数组的容量超过初始容量的0.75时，再散列将链表数组扩大2倍，把原链表数组的搬移到新的数组中</p><p><img src="/2018/08/12/HashMap源码分析/hashmap1.png" alt=""></p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><strong>1、 位桶数组</strong></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transient <span class="keyword">Node</span><span class="title">&lt;k</span>,v&gt;[] table;//存储（位桶）的数组<span class="tag">&lt;/k,v&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2、 数组元素Node&lt;K,V&gt;</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Node是单向链表，它实现了Map.Entry接口</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">k</span>,<span class="title">v</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">k</span>,<span class="title">v</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;k,v&gt; next;</span><br><span class="line">    <span class="comment">//构造函数Hash值 键 值 下一个节点</span></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;k,v&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + = + value; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断两个node是否相等,若key和value都相等，返回true。可以与自身比较为true</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;!--?,?--&gt; e = (Map.Entry&lt;!--?,?--&gt;)o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>3、红黑树</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//红黑树</span></span><br><span class="line">static <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode&lt;k</span>,<span class="title">v&gt;</span> <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry&lt;k</span>,<span class="title">v&gt;</span> </span>&#123;</span><br><span class="line">    <span class="type">TreeNode</span>&lt;k,v&gt; parent;  <span class="comment">// 父节点</span></span><br><span class="line">    <span class="type">TreeNode</span>&lt;k,v&gt; left; <span class="comment">//左子树</span></span><br><span class="line">    <span class="type">TreeNode</span>&lt;k,v&gt; right;<span class="comment">//右子树</span></span><br><span class="line">    <span class="type">TreeNode</span>&lt;k,v&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    boolean red;    <span class="comment">//颜色属性</span></span><br><span class="line">    <span class="type">TreeNode</span>(int hash, <span class="type">K</span> key, <span class="type">V</span> <span class="keyword">val</span>, <span class="type">Node</span>&lt;k,v&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, <span class="keyword">val</span>, next);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//返回当前节点的根节点</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">TreeNode</span>&lt;k,v&gt; root() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">TreeNode</span>&lt;k,v&gt; r = <span class="keyword">this</span>, p;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((p = r.parent) == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            r = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="数据域"><a href="#数据域" class="headerlink" title="数据域"></a>数据域</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">-------类常量------------</span><br><span class="line"><span class="comment">//默认hash桶初始长度16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//hash表最大容量2的30次幂</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认负载因子 0.75</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75</span>f;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链表的数量大于等于8个并且桶的数量大于等于64时链表树化 </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//hash表某个节点链表的数量小于等于6时树拆分</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//树化时最小桶的数量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------实例变量---------</span><br><span class="line"><span class="comment">//hash桶</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;                         </span><br><span class="line"></span><br><span class="line"><span class="comment">//键值对的数量</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> <span class="keyword">size</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//HashMap结构修改的次数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩容的阀值，当键值对的数量超过这个阀值会产生扩容</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">//负载因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造函数1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//指定的初始容量非负</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(Illegal initial capacity:  +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="comment">//如果指定的初始容量大于最大容量,置为最大容量</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="comment">//填充比为正</span></span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(Illegal load factor:  +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);<span class="comment">//新的扩容临界值</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//构造函数2</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//构造函数3</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//构造函数4用m的元素初始化散列映射</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;!--? <span class="keyword">extends</span> K, ? <span class="keyword">extends</span> V--&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tableSizeFor(initialCapacity)方法，这个方法的作用是，将你传入的initialCapacity做计算，返回一个大于等于initialCapacity 最小的2的幂次方。所以这个操作保证无论你传入的初始化Hash桶长度参数是多少，最后hash表初始化的长度都是2的幂次方。比如你输入的是6，计算出来结果就是8。</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static final <span class="built_in">int</span> tableSizeFor(<span class="built_in">int</span> cap) &#123;                                                                      </span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">n</span> = cap - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">n</span> |= <span class="built_in">n</span> &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">n</span> |= <span class="built_in">n</span> &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">n</span> |= <span class="built_in">n</span> &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        <span class="built_in">n</span> |= <span class="built_in">n</span> &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">        <span class="built_in">n</span> |= <span class="built_in">n</span> &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">        return (<span class="built_in">n</span> &lt; <span class="number">0</span>) ? <span class="number">1</span> <span class="symbol">:</span> (<span class="built_in">n</span> &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY <span class="symbol">:</span> <span class="built_in">n</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="built_in">get</span>(<span class="keyword">Object</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = getNode(hash(<span class="built_in">key</span>), <span class="built_in">key</span>)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implements Map.get and related methods</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param hash hash for key</span></span><br><span class="line"><span class="comment">     * @param key the key</span></span><br><span class="line"><span class="comment">     * @return the node, or null if none</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; getNode(<span class="built_in">int</span> hash, <span class="keyword">Object</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;<span class="comment">//Entry对象数组</span></span><br><span class="line">Node&lt;K,V&gt; first,e; <span class="comment">//在tab数组中经过散列的第一个位置</span></span><br><span class="line"><span class="built_in">int</span> n;</span><br><span class="line">K k;</span><br><span class="line"><span class="comment">/*找到插入的第一个Node，方法是hash值和n-1相与，tab[(n - 1) &amp; hash]*/</span></span><br><span class="line"><span class="comment">//也就是说在一条链上的hash值相同的</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;(first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">/*检查第一个Node是不是要找的Node*/</span></span><br><span class="line">            <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">                ((k = first.<span class="built_in">key</span>) == <span class="built_in">key</span> || (<span class="built_in">key</span> != <span class="keyword">null</span> &amp;&amp; <span class="built_in">key</span>.equals(k))))<span class="comment">//判断条件是hash值要相同，key值要相同</span></span><br><span class="line">                <span class="keyword">return</span> first;</span><br><span class="line">  <span class="comment">/*检查first后面的node*/</span></span><br><span class="line">            <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, <span class="built_in">key</span>);</span><br><span class="line"><span class="comment">/*遍历后面的链表，找到key值和hash值都相同的Node*/</span></span><br><span class="line">                do &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.<span class="built_in">key</span>) == <span class="built_in">key</span> || (<span class="built_in">key</span> != <span class="keyword">null</span> &amp;&amp; <span class="built_in">key</span>.equals(k))))</span><br><span class="line">                        <span class="keyword">return</span> e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>get(key)方法时获取key的hash值，计算hash&amp;(n-1)得到在链表数组中的位置first=tab[hash&amp;(n-1)],先判断first的key是否与参数key相等，不等就遍历后面的链表找到相同的key值返回对应的Value值即可</p><h2 id="put"><a href="#put" class="headerlink" title="put"></a>put</h2><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V put(K <span class="built_in">key</span>, V value) &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(<span class="built_in">key</span>), <span class="built_in">key</span>, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> V putVal(<span class="built_in">int</span> hash, K <span class="built_in">key</span>, V value, <span class="built_in">boolean</span> onlyIfAbsent,                                     </span><br><span class="line">               <span class="built_in">boolean</span> evict) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="built_in">int</span> n, i;</span><br><span class="line">    <span class="comment">//当table为空时，这里初始化table，不是通过构造函数初始化，而是在插入时通过扩容初始化，</span></span><br><span class="line">    <span class="comment">//有效防止了初始化HashMap没有数据插入造成空间浪费可能造成内存泄露的情况</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//存放新键值对</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, <span class="built_in">key</span>, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//表示有冲突,开始处理冲突</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">//旧键值对的覆盖</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.<span class="built_in">key</span>) == <span class="built_in">key</span> || (<span class="built_in">key</span> != <span class="keyword">null</span> &amp;&amp; <span class="built_in">key</span>.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">//在红黑树中查找旧键值对更新</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, <span class="built_in">key</span>, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//将新键值对放在链表的最后</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, <span class="built_in">key</span>, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">//当链表的长度大于等于树化阀值，并且hash桶的长度大于等于MIN_TREEIFY_CAPACITY，链表转化为红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//链表中包含键值对</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.<span class="built_in">key</span>) == <span class="built_in">key</span> || (<span class="built_in">key</span> != <span class="keyword">null</span> &amp;&amp; <span class="built_in">key</span>.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//map中含有旧key，返回旧值</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; </span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//map调整次数加1</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">//键值对的数量达到阈值需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++<span class="built_in">size</span> &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>对key的hashCode()进行hash后计算数组下标index;</li><li>如果当前数组table为null，进行resize()初始化；</li><li>如果没碰撞直接放到对应下标的位置上；</li><li>如果碰撞了，且节点已经存在，就替换掉 value；</li><li>如果碰撞后发现为树结构，挂载到树上。</li><li>如果碰撞后为链表，添加到链表尾，并判断链表如果过长(大于等于TREEIFY_THRESHOLD，默认8)，就把链表转换成树结构；</li><li>数据 put 后，如果数据量超过threshold，就要resize。</li></ol><h2 id="扩容机制resize"><a href="#扩容机制resize" class="headerlink" title="扩容机制resize()"></a>扩容机制resize()</h2><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Initializes or doubles table size.  If null, allocates in</span></span><br><span class="line"><span class="comment">    * accord with initial capacity target held in field threshold.</span></span><br><span class="line"><span class="comment">    * Otherwise, because we are using power-of-two expansion, the</span></span><br><span class="line"><span class="comment">    * elements from each bin must either stay at same index, or move</span></span><br><span class="line"><span class="comment">    * with a power of two offset in the new table.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * @return the table</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">       Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">       int oldCap = (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : <span class="type">oldTab</span>.length;</span><br><span class="line">       int oldThr = threshold;</span><br><span class="line">       int <span class="keyword">new</span><span class="type">Cap</span>, <span class="keyword">new</span><span class="type">Thr</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*如果旧表的长度不是空*/</span></span><br><span class="line">       <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">               threshold = Integer.MAX_VALUE;</span><br><span class="line">               <span class="keyword">return</span> oldTab;</span><br><span class="line">           &#125;</span><br><span class="line"><span class="comment">/*把新表的长度设置为旧表长度的两倍，newCap=2*oldCap*/</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="keyword">new</span><span class="type">Cap</span> = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">      <span class="comment">/*把新表的门限设置为旧表门限的两倍，newThr=oldThr*2*/</span></span><br><span class="line">               <span class="keyword">new</span><span class="type">Thr</span> = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">       &#125;</span><br><span class="line">    <span class="comment">/*如果旧表的长度的是0，就是说第一次初始化表*/</span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">           <span class="keyword">new</span><span class="type">Cap</span> = oldThr;</span><br><span class="line">       <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">           <span class="keyword">new</span><span class="type">Cap</span> = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">           <span class="keyword">new</span><span class="type">Thr</span> = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">new</span><span class="type">Thr</span> == <span class="number">0</span>) &#123;</span><br><span class="line">           float ft = (float)<span class="keyword">new</span><span class="type">Cap</span> * loadFactor;<span class="comment">//新表长度乘以加载因子</span></span><br><span class="line">           <span class="keyword">new</span><span class="type">Thr</span> = (<span class="keyword">new</span><span class="type">Cap</span> &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                     (int)ft : <span class="type">Integer</span>.MAX_VALUE);</span><br><span class="line">       &#125;</span><br><span class="line">       threshold = <span class="keyword">new</span><span class="type">Thr</span>;</span><br><span class="line">       @SuppressWarnings(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line"><span class="comment">/*下面开始构造新表，初始化表中的数据*/</span></span><br><span class="line">       Node&lt;K,V&gt;[] <span class="keyword">new</span><span class="type">Tab</span> = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="type">Node</span>[<span class="keyword">new</span><span class="type">Cap</span>];</span><br><span class="line">       table = <span class="keyword">new</span><span class="type">Tab</span>;<span class="comment">//把新表赋值给table</span></span><br><span class="line">       <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;<span class="comment">//原表不是空要把原表中数据移动到新表中</span></span><br><span class="line">           <span class="comment">/*遍历原来的旧表*/</span></span><br><span class="line">           <span class="keyword">for</span> (int j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">               Node&lt;K,V&gt; e;</span><br><span class="line">               <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                   oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                   <span class="keyword">if</span> (e.next == <span class="literal">null</span>)<span class="comment">//说明这个node没有链表直接放在新表的e.hash &amp; (newCap - 1)位置</span></span><br><span class="line">                       <span class="keyword">new</span><span class="type">Tab</span>[e.hash &amp; (<span class="keyword">new</span><span class="type">Cap</span> - <span class="number">1</span>)] = e;</span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span> (e instanceof TreeNode)</span><br><span class="line">                       ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, <span class="keyword">new</span><span class="type">Tab</span>, j, oldCap);</span><br><span class="line">                <span class="comment">/*如果e后边有链表,到这里表示e后面带着个单链表，需要遍历单链表，将每个结点重*/</span></span><br><span class="line">                   <span class="keyword">else</span> &#123; <span class="comment">// preserve order保证顺序</span></span><br><span class="line"><span class="comment">////新计算在新表的位置，并进行搬运</span></span><br><span class="line">                       Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                       Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                       Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">                       <span class="keyword">do</span> &#123;</span><br><span class="line">                           next = e.next;<span class="comment">//记录下一个结点</span></span><br><span class="line">             <span class="comment">//新表是旧表的两倍容量，实例上就把单链表拆分为两队，</span></span><br><span class="line">　　　　　　　　　　　　　　<span class="comment">//e.hash&amp;oldCap为偶数一队，e.hash&amp;oldCap为奇数一对</span></span><br><span class="line">                           <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                               <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                   loHead = e;</span><br><span class="line">                               <span class="keyword">else</span></span><br><span class="line">                                   loTail.next = e;</span><br><span class="line">                               loTail = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="keyword">else</span> &#123;</span><br><span class="line">                               <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                   hiHead = e;</span><br><span class="line">                               <span class="keyword">else</span></span><br><span class="line">                                   hiTail.next = e;</span><br><span class="line">                               hiTail = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">                       <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;<span class="comment">//lo队不为null，放在新表原位置</span></span><br><span class="line">                           loTail.next = <span class="literal">null</span>;</span><br><span class="line">                           <span class="keyword">new</span><span class="type">Tab</span>[j] = loHead;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;<span class="comment">//hi队不为null，放在新表j+oldCap位置</span></span><br><span class="line">                           hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                           <span class="keyword">new</span><span class="type">Tab</span>[j + oldCap] = hiHead;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span><span class="type">Tab</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>那么什么时候回产生扩容呢？</p><p>（1）初始化HashMap时，第一次进行put操作</p><p>（2）当键值对的个数大于threshold阀值时产生扩容，threshold=size*loadFactor</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在JDK1.6，JDK1.7中，HashMap采用位桶+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，HashMap采用位桶+链表+红黑树实
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>TCP的可靠性传输</title>
    <link href="http://yoursite.com/2018/08/10/TCP%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%BC%A0%E8%BE%93/"/>
    <id>http://yoursite.com/2018/08/10/TCP的可靠性传输/</id>
    <published>2018-08-10T01:44:49.000Z</published>
    <updated>2018-08-11T02:12:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>TCP通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输。</p><h2 id="通过序列号与确认应答提高可靠性"><a href="#通过序列号与确认应答提高可靠性" class="headerlink" title="通过序列号与确认应答提高可靠性"></a>通过序列号与确认应答提高可靠性</h2><p>TCP通过肯定的<strong>确认应答(ACK)</strong>实现可靠的数据传输。当发送端将数据发出后会等待对端的确认应答。如果有确认应答，说明数据已经成功到达对端。反之，则数据丢失的可能性很大。</p><p><img src="/2018/08/10/TCP的可靠性传输/TCP1.png" alt=""></p><p>没有收到确认应答并不意味着数据一定丢失。也又可能是对方已经收到了数据，只是返回的确认应答在途中丢失。这种情况也会导致发送端没有收到确认应答而认为数据没有到达目的地，最终重发数据。</p><p><img src="/2018/08/10/TCP的可靠性传输/TCP2.png" alt=""></p><p>主机B已经收到了1-1000的数据，再有相同的数据到达时会丢弃相同数据。</p><p>有很多因素会导致确认应答延迟到达，源发送主机只要按照重发机制重发数据即可。但对于目标主机来说，这是一种“灾难”。它会反复收到相同的数据。而为了对上层应用提供可靠的传输，必须得放弃重复的数据包。因此就要使用一种能够识别是否已经接收数据，又能判断是否需要接收的机制。</p><p>上述这些确认应答、重发机制以及重复控制等功能都可以通过序列号实现。<strong>序列号</strong>是按顺序给发送的数据的每一个字节(8位字节)都标上号码的编号。接收端查询接收数据TCP首部中的序列号和数据的长度，将自己下一步应该接收的序号作为确认应答返送回去。就这样，通过序列号和确认应答号，TCP就可以实现可靠传输。</p><blockquote><p>序列号的初始值并非为0。而是在建立连接后由随机数生成。而后的计算则是对每一字节加一。</p></blockquote><h2 id="重发超时的确定"><a href="#重发超时的确定" class="headerlink" title="重发超时的确定"></a>重发超时的确定</h2><p>重发超时是指在重发数据之前，等待确认应答到来的那个特定时间。如果超过了这个时间仍未收到确认应答，发送端将进行数据重发。</p><p>在Unix以及Windows系统中，超时都是以0.5秒为单位进行控制，因此重发超时都是0.5的整数倍。由于最初的数据包还不知道往返时间，所以其重发超时一般设置在6秒左右。</p><p>数据重发之后若还是收不到确认应答，则进行再次发送。此时，等待应答的时间将会以2倍、4倍的指数函数延长。</p><p>此外，数据也不会无限、反复地重发。达到一定重发次数之后，如果仍然没有任何确认应答返回，就会判断为网络或对端主机发生异常，强制关闭连接。并且通知应用通信异常强行终止。</p><h2 id="连接管理-三次握手四次挥手"><a href="#连接管理-三次握手四次挥手" class="headerlink" title="连接管理(三次握手四次挥手)"></a>连接管理(三次握手四次挥手)</h2><p>TCP提供面向有连接的通信传输。面向有连接是指在数据通信开始之前先做好通信两端之间的准备工作。</p><p>TCP在数据通信之前，通过TCP首部发送一个SYN包作为建立连接的请求等待确认应答。如果对端发来确认应答，则认为可以进行数据通信。如果对端的确认应答未能到达，就不会进行数据通信。此外，在通信结束时会进行断开连接的处理(FIN包)。</p><p><img src="/2018/08/10/TCP的可靠性传输/TCP3.png" alt=""></p><h2 id="TCP以段发送数据"><a href="#TCP以段发送数据" class="headerlink" title="TCP以段发送数据"></a>TCP以段发送数据</h2><p>在建立TCP连接的同时，也可以确定发送数据包的单位，称其为<strong>“最大消息长度”(MSS)</strong>。最理想的情况是IP中不被分片处理的最大数据长度。</p><p>TCP在传输大量数据时，是以MSS的大小将数据进行分割发送。进行重发时也是以MSS为单位。(在上面的两张图中，传输数据都是1-1000，表示MSS的大小为1000)</p><p>MSS是在三次握手的时候，在两端主机之间被计算得出。两端的主机在发出建立连接的请求时，会在TCP首部中写入MSS选项，告诉对方自己的接口能够适应的MSS的大小。然后会在两者之间选择一个较小的值投入使用。</p><h2 id="利用窗口控制提高速度"><a href="#利用窗口控制提高速度" class="headerlink" title="利用窗口控制提高速度"></a>利用窗口控制提高速度</h2><p>TCP以一个段为单位，每发一个段进行一次确认应答的处理。这样的传输方式有一个缺点。那就是包的往返时间越长通信性能就越低。</p><p>为了解决这个问题，TCP引入了窗口这个概念。即时在往返时间较长的情况下，它也能控制网络性能的下降。</p><p><img src="/2018/08/10/TCP的可靠性传输/TCP4.png" alt=""></p><p>如图所示，确认应答不再是以每个分段，而是以更大的单位进行确认时，转发时间将被大幅度缩短。也就是说，发送端主机在发送了一个段以后不必一直等待确认应答，而是继续发送。</p><p><strong>窗口大小</strong>就是指无需等待确认应答而可以继续发送数据的最大值。上图中窗口大小为3个段。</p><p>如下图所示，黄色部分表示窗口。这个窗口中的数据即便没有收到应答确认也可以被发送出去。不过，在整个窗口的确认应答没有到达之前，如果其中部分数据出现丢包，那么发送端仍然需要重传。在收到确认应答的情况下，将窗口滑动到确认应答中的序列号的位置。这样可以顺序得将多个段同时发送提高通信性能。这种机制也被称为窗口滑动机制。<br><img src="/2018/08/10/TCP的可靠性传输/TCP5.png" alt=""></p><h2 id="窗口控制与重发控制"><a href="#窗口控制与重发控制" class="headerlink" title="窗口控制与重发控制"></a>窗口控制与重发控制</h2><p>在使用窗口控制中，如果出现段丢失该怎么办？</p><p>首先考虑确认应答未能返回的情况。在这种情况下，数据已经到达对端，是不需要进行重发的。使用了窗口机制，某些确认应答即便丢失也无需重发。可以通过下一个确认应答进行确认。</p><p><img src="/2018/08/10/TCP的可靠性传输/TCP6.png" alt=""></p><p>在来考虑一下某个报文段丢失的情况，如下图所示，接收主机如果收到一个自己应该接收的序号以外的数据时，会针对当前为止收到数据返回确认应答。当一段报文段丢失后，发送端回一直收到序号为1001的确认应答，这个确认应答好像在提醒发送端“我想接受的是1001开始的数据”。因此，在窗口比较大，又出现报文段丢失的情况下，同一个序号的确认应答将会被重复不断的返回。而发送端主机如果连续三次接收到同一个确认应答，就会将其对应的数据进行重发。这种机制比之前提到的超时管理更加高效，因此也被称为<strong>高速重发控制</strong>。</p><p><img src="/2018/08/10/TCP的可靠性传输/TCP7.png" alt=""></p><h2 id="流控制-窗口大小"><a href="#流控制-窗口大小" class="headerlink" title="流控制(窗口大小)"></a>流控制(窗口大小)</h2><p>发送端根据自己的实际情况发送数据。但是，接收端可能收到的是一个毫无关系的数据包又可能会在处理其他问题上花费一些时间。因此在为这个数据包做其他处理时会耗费一些时间，甚至在高负荷的情况下无法接收任何数据。如此一来，如果接收端将本应该接收的数据丢弃的话，就又会触发重发机制，导致网络流量的无端浪费。</p><p>TCP提供一种机制可以让发送端根据接收端的实际接收能力控制发送数据的数量。这就是流控制。具体操作就是接收端主机向发送端主机通知自己可以接收数据的大小，于是发送端会发送不超过这个限度的数据。该大小限度就被称作窗口大小。</p><p>TCP首部中，专门有一个字段用来通知窗口大小。接收主机将自己可以接收的缓冲区大小放入到这个字段中通知给发送端。这个字段的值越大，说明网络的吞吐量越大。当接收端的这个缓冲区一旦面临数据溢出时，窗口大小的值也会随之被设置成一个更小的值发送给发送端，从而控制数据发送量。</p><p><img src="/2018/08/10/TCP的可靠性传输/TCP8.png" alt=""></p><h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p>有了TCP的窗口控制，收发主机之间即使不再以一个数据段为单位发送确认应答，也能够连续发送大量数据包。然而，如果在通信刚开始的时候就发送大量数据，也可能会引发其他问题。</p><p>一般来说，计算机网络都处在一个共享的环境。因此也有可能会因为其他主机之间的通信使得网络拥堵。在网络出现拥堵时，如果突然发送一个较大量的数据，极有可能导致整个网络的瘫痪。</p><p>TCP为了防止该问题的出现，在通信一开始的时候就会通过一个叫做慢启动的算法得出的数值，对发送数据量进行控制。</p><p>首先为了在发送端调节所要发送数据的量，定义了一个叫做“拥塞窗口”的概念。于是在慢启动的时候，将这个拥塞窗口的大小设置为1个数据段(1MSS)发送数据。之后每收到一次确认应答，拥塞窗口的值就加1。在发送数据包时，将拥塞窗口的大小与接收端主机通知的窗口大小做比较，然后按照它们当中较小的那个值，发送比其还小的数据量。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;TCP通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输。&lt;/p&gt;
&lt;h2 id=&quot;通过序列号与确认应答提高可靠性&quot;&gt;&lt;a href=&quot;#通过序列号与确认应答提高可靠性&quot; class=&quot;headerlink&quot; title=&quot;通过序列号与确认应答
      
    
    </summary>
    
      <category term="网络" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="TCP" scheme="http://yoursite.com/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>Java队列同步器AQS</title>
    <link href="http://yoursite.com/2018/08/08/Java%E9%98%9F%E5%88%97%E5%90%8C%E6%AD%A5%E5%99%A8AQS/"/>
    <id>http://yoursite.com/2018/08/08/Java队列同步器AQS/</id>
    <published>2018-08-08T08:37:20.000Z</published>
    <updated>2018-08-07T11:19:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>队列同步器，AbstractQueuedSynchronized,简称AQS，是用来构建锁或者其他同步组建的基础框架，常用的有ReentrantLock、ReadWriteLock（实现类ReentrantReadWriteLock），内部实现都依赖于它。Doug Lea大神期望它能够成为实现大部分同步需求的基础。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">extends</span></span></span><br><span class="line"><span class="class">    <span class="title">AbstractOwnableSynchronizer</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123; </span><br><span class="line">    <span class="comment">//等待队列的头节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line">    <span class="comment">//等待队列的尾节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line">    <span class="comment">//同步状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> state;&#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123; state = newState;&#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> unsafe.<span class="title">compareAndSwapInt</span><span class="params">(<span class="keyword">this</span>, stateOffset, expect, update)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AQS使用了一个int成员变量state表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。基本结构如图所示：</p><p><img src="/2018/08/08/Java队列同步器AQS/AQS1.png" alt=""></p><p>当前线程获取同步状态失败时，AQS会将当前线程以及等待状态等信息构造成一个节点(Node)并将其加入到队列中(添加到队尾，要保证线程安全，使用CAS)，同时阻塞当前线程。当同步状态释放时，会把首节点的线程唤醒，使其再尝试获取同步状态。</p><p>节点类：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static final class <span class="keyword">Node</span> <span class="title">&#123;</span></span><br><span class="line"><span class="title">      static</span> final <span class="keyword">Node</span> <span class="title">SHARED</span> = new <span class="keyword">Node</span><span class="title">();</span></span><br><span class="line"><span class="title">      static</span> final <span class="keyword">Node</span> <span class="title">EXCLUSIVE</span> = null;</span><br><span class="line">      static final int CANCELLED =  <span class="number">1</span>;</span><br><span class="line">      static final int SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">      static final int CONDITION = -<span class="number">2</span>;</span><br><span class="line">      static final int PROPAGATE = -<span class="number">3</span>;</span><br><span class="line">      volatile int waitStatus;</span><br><span class="line">      volatile <span class="keyword">Node</span> <span class="title">prev</span>;</span><br><span class="line">      volatile <span class="keyword">Node</span> <span class="title">next</span>;</span><br><span class="line">      volatile Thread thread;</span><br><span class="line">      <span class="keyword">Node</span> <span class="title">nextWaiter</span>;</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>每个节点中， 除了存储了当前线程，前后节点的引用以外，还有一个waitStatus变量，用于描述节点当前的状态。一共有4中状态：</p><ul><li>CANCELLED 取消状态</li><li>SIGNAL 等待触发状态</li><li>CONDITION 等待条件状态</li><li>PROPAGATE 状态需要向后传播</li></ul><p>等待队列是FIFO先进先出，只有前一个节点的状态为SIGNAL时，当前节点的线程才能被挂起。</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>AQS的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态。子类重写tryAcquire和tryRelease方法通过CAS指令修改状态变量state。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码主要完成了同步状态获取、节点构造、加入同步队列以及在同步队列中自旋等待的相关工作。首先调用自定义同步器实现的<code>tryAcquire(arg)</code>，该方法保证线程安全地获取同步状态，如果获取同步状态失败，则构造同步节点并通过<code>addWaiter(Node node)</code>方法加入到同步队列的尾部，最后调用<code>acquireQueued(Node node, int arg)</code>方法使该节点以”死循环”的方式获取同步状态。如果获取不到则阻塞节点中的线程，而被阻塞的线程唤醒主要依靠前驱节点的出队或阻塞线程被中断来实现。</p><h3 id="1、节点构造和加入同步队列"><a href="#1、节点构造和加入同步队列" class="headerlink" title="1、节点构造和加入同步队列"></a>1、节点构造和加入同步队列</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private <span class="keyword">Node</span> <span class="title">addWaiter</span>(<span class="keyword">Node</span> <span class="title">mode</span>) &#123;</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">node</span> = new <span class="keyword">Node</span><span class="title">(Thread</span>.currentThread(), mode);</span><br><span class="line">        // Try the fast path of enq; backup to full enq on failure</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">pred</span> = tail;</span><br><span class="line">        if (pred != null) &#123;</span><br><span class="line">            <span class="keyword">node</span>.<span class="title">prev</span> = pred;</span><br><span class="line">            if (compareAndSetTail(pred, <span class="keyword">node</span><span class="title">)) &#123;</span></span><br><span class="line"><span class="title">                pred</span>.next = <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">                return</span> <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">            &#125;</span></span><br><span class="line"><span class="title">        &#125;</span></span><br><span class="line"><span class="title">        enq</span>(<span class="keyword">node</span><span class="title">);</span></span><br><span class="line"><span class="title">        return</span> <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">    &#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private <span class="keyword">Node</span> <span class="title">enq</span>(final <span class="keyword">Node</span> <span class="title">node</span>) &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            <span class="keyword">Node</span> <span class="title">t</span> = tail;</span><br><span class="line">            if (t == null) &#123; // Must initialize</span><br><span class="line">                if (compareAndSetHead(new <span class="keyword">Node</span><span class="title">()))</span></span><br><span class="line"><span class="title">                    tail</span> = head;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                <span class="keyword">node</span>.<span class="title">prev</span> = t;</span><br><span class="line">                if (compareAndSetTail(t, <span class="keyword">node</span><span class="title">)) &#123;</span></span><br><span class="line"><span class="title">                    t</span>.next = <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">                    return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="2、节点进入自旋"><a href="#2、节点进入自旋" class="headerlink" title="2、节点进入自旋"></a>2、节点进入自旋</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">final boolean acquireQueued(final <span class="keyword">Node</span> <span class="title">node</span>, int arg) &#123;</span><br><span class="line">        boolean failed = <span class="literal">true</span>;</span><br><span class="line">        try &#123;</span><br><span class="line">            boolean interrupted = <span class="literal">false</span>;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                //p为<span class="keyword">node</span><span class="title">的前驱节点</span></span><br><span class="line"><span class="title">                final</span> <span class="keyword">Node</span> <span class="title">p</span> = <span class="keyword">node</span>.<span class="title">predecessor</span>();</span><br><span class="line">                //前驱节点是头节点才尝试获取同步状态</span><br><span class="line">                //如果成功，将自己设为头节点</span><br><span class="line">                if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(<span class="keyword">node</span><span class="title">);</span></span><br><span class="line"><span class="title">                    p</span>.next = null; // help GC</span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    return interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                if (shouldParkAfterFailedAcquire(p, <span class="keyword">node</span><span class="title">) &amp;&amp;</span></span><br><span class="line"><span class="title">                    parkAndCheckInterrupt</span>())</span><br><span class="line">                    interrupted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (failed)</span><br><span class="line">                cancelAcquire(<span class="keyword">node</span><span class="title">);</span></span><br><span class="line"><span class="title">        &#125;</span></span><br><span class="line"><span class="title">    &#125;</span></span><br></pre></td></tr></table></figure><p><img src="/2018/08/08/Java队列同步器AQS/AQS2.png" alt=""></p><p>尝试获取失败则进入下面方法</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private static boolean shouldParkAfterFailedAcquire(<span class="keyword">Node</span> <span class="title">pred</span>, <span class="keyword">Node</span> <span class="title">node</span>) &#123;</span><br><span class="line">       int ws = pred.waitStatus;</span><br><span class="line">       if (ws == <span class="keyword">Node</span>.<span class="title">SIGNAL</span>)</span><br><span class="line">           /*</span><br><span class="line">            * This <span class="keyword">node</span> <span class="title">has</span> already set status asking a release</span><br><span class="line">            * to signal it, so it can safely park.</span><br><span class="line">            */</span><br><span class="line">           return <span class="literal">true</span>;</span><br><span class="line">       if (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           /*</span><br><span class="line">            * Predecessor was cancelled. Skip over predecessors <span class="keyword">and</span></span><br><span class="line">            * indicate retry.</span><br><span class="line">            */</span><br><span class="line">           do &#123;</span><br><span class="line">               <span class="keyword">node</span>.<span class="title">prev</span> = pred = pred.prev;</span><br><span class="line">           &#125; while (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">           pred.next = <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">       &#125; else</span> &#123;</span><br><span class="line">           /*</span><br><span class="line">            * waitStatus must be <span class="number">0</span> <span class="keyword">or</span> PROPAGATE.  Indicate that we</span><br><span class="line">            * need a signal, but don't park yet.  Caller will need to</span><br><span class="line">            * retry to make sure it cannot acquire before parking.</span><br><span class="line">            */</span><br><span class="line">           compareAndSetWaitStatus(pred, ws, <span class="keyword">Node</span>.<span class="title">SIGNAL</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       return <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="function"><span class="keyword">return</span> Thread.<span class="title">interrupted</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li>如果pred的waitStatus == 0，则通过CAS指令修改waitStatus为Node.SIGNAL。</li><li>如果pred的waitStatus &gt; 0，表明pred的线程状态CANCELLED，需从队列中删除。</li><li>如果pred的waitStatus为Node.SIGNAL，则通过LockSupport.park()方法把线程A挂起，并等待被唤醒</li><li>线程每次被唤醒时，都要进行中断检测，如果发现当前线程被中断，那么抛出InterruptedException并退出循环。从无限循环的代码可以看出，并不是被唤醒的线程一定能获得锁，必须调用tryAccquire重新竞争，因为锁是非公平的，有可能被新加入的线程获得，从而导致刚被唤醒的线程再次被阻塞，这个细节充分体现了“非公平”的精髓。</li></ol><h3 id="3、释放"><a href="#3、释放" class="headerlink" title="3、释放"></a>3、释放</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> void unparkSuccessor(Node node) &#123;</span><br><span class="line">    /*</span><br><span class="line">     * <span class="keyword">If</span> status <span class="keyword">is</span> negative (i.e., possibly needing signal) try</span><br><span class="line">     * <span class="keyword">to</span> clear <span class="keyword">in</span> anticipation of signalling.  It <span class="keyword">is</span> OK <span class="keyword">if</span> this</span><br><span class="line">     * fails <span class="keyword">or</span> <span class="keyword">if</span> status <span class="keyword">is</span> changed by waiting thread.</span><br><span class="line">     */</span><br><span class="line">    <span class="built_in">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Thread <span class="keyword">to</span> unpark <span class="keyword">is</span> held <span class="keyword">in</span> successor, which <span class="keyword">is</span> normally</span><br><span class="line">     * just the <span class="keyword">next</span> node.  But <span class="keyword">if</span> cancelled <span class="keyword">or</span> apparently <span class="literal">null</span>,</span><br><span class="line">     * traverse backwards from tail <span class="keyword">to</span> find the actual</span><br><span class="line">     * non-cancelled successor.</span><br><span class="line">     */</span><br><span class="line">    Node s = node.<span class="keyword">next</span>;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="literal">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>如果头结点head的waitStatus值为-1，则用CAS指令重置为0；</li><li>找到waitStatus值小于0的节点s，通过LockSupport.unpark(s.thread)唤醒线程。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在获取同步状态时，同步器维护了一个同步队列，获取状态失败的线程都会被加入到队列中并在队列中进行自旋；移出或停止自旋的条件是前驱节点为头节点且成功获取到了同步状态。在释放同步状态时，同步器调用<code>tryRelease(int arg)</code>方法释放同步状态，然后唤醒头节点的后续节点。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;队列同步器，AbstractQueuedSynchronized,简称AQS，是用来构建锁或者其他同步组建的基础框架，常用的有ReentrantLock、ReadWriteLock（实现类ReentrantReadWriteLock），内部实现都依赖于它。Doug Lea大
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="同步" scheme="http://yoursite.com/tags/%E5%90%8C%E6%AD%A5/"/>
    
      <category term="AQS" scheme="http://yoursite.com/tags/AQS/"/>
    
  </entry>
  
  <entry>
    <title>Binder机制简析(四)</title>
    <link href="http://yoursite.com/2018/08/07/Binder%E6%9C%BA%E5%88%B6%E7%AE%80%E6%9E%90-%E5%9B%9B/"/>
    <id>http://yoursite.com/2018/08/07/Binder机制简析-四/</id>
    <published>2018-08-07T03:23:28.000Z</published>
    <updated>2018-08-07T11:18:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>binder在framework层，采用JNI技术来调用native(C/C++)层的binder架构，从而为上层应用程序提供服务。 看过binder系列之前的文章，我们知道native层中，binder是C/S架构，分为Bn端(Server)和Bp端(Client)。对于java层在命名与架构上非常相近，同样实现了一套IPC通信架构。</p><h2 id="framework-Binder架构图"><a href="#framework-Binder架构图" class="headerlink" title="framework Binder架构图"></a>framework Binder架构图</h2><p><img src="/2018/08/07/Binder机制简析-四/java_binder.jpg" alt=""></p><p>图解：</p><ol><li>图中红色代表整个framework层 binder架构相关组件；</li><li>图中蓝色代表Native层Binder架构相关组件；</li><li>上层framework层的Binder逻辑是建立在Native层架构基础之上的，核心逻辑都是交予Native层方法来处理。</li><li>framework层的ServiceManager类与Native层的功能并不完全对应，framework层的ServiceManager类的实现最终是通过BinderProxy传递给Native层来完成的</li></ol><h2 id="Binder完整通信流程"><a href="#Binder完整通信流程" class="headerlink" title="Binder完整通信流程"></a>Binder完整通信流程</h2><p><img src="/2018/08/07/Binder机制简析-四/binder_ipc_process.jpg" alt=""></p><p>图解:</p><ol><li>发起端线程向Binder Driver发起binder ioctl请求后, 便采用环不断talkWithDriver,此时该线程处于阻塞状态, 直到收到如下BR_XXX命令才会结束该过程.</li><li>左图中waitForResponse收到BR_TRANSACTION_COMPLETE,则直接退出循环, 则没有机会执行executeCommand()方法, 故将其颜色画为灰色. 除以上5种BR_XXX命令, 当收到其他BR命令,则都会执行executeCommand过程.</li><li>目标Binder线程创建后, 便进入joinThreadPool()方法, 采用循环不断地循环执行getAndExecuteCommand()方法, 当bwr的读写buffer都没有数据时,则阻塞在binder_thread_read的wait_event过程. 另外,正常情况下binder线程一旦创建则不会退出.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;binder在framework层，采用JNI技术来调用native(C/C++)层的binder架构，从而为上层应用程序提供服务。 看过binder系列之前的文章，我们知道native层中，binder是C/S架构，分为Bn端(Server)和Bp端(Client)。对于
      
    
    </summary>
    
      <category term="Android系统" scheme="http://yoursite.com/categories/Android%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="系统" scheme="http://yoursite.com/tags/%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="binder" scheme="http://yoursite.com/tags/binder/"/>
    
  </entry>
  
  <entry>
    <title>Binder机制简析(三)</title>
    <link href="http://yoursite.com/2018/08/05/Binder%E6%9C%BA%E5%88%B6%E7%AE%80%E6%9E%90-%E4%B8%89/"/>
    <id>http://yoursite.com/2018/08/05/Binder机制简析-三/</id>
    <published>2018-08-05T12:01:04.000Z</published>
    <updated>2018-08-07T11:18:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="注册Service"><a href="#注册Service" class="headerlink" title="注册Service"></a>注册Service</h2><p>Service组件运行在Server进程中，首先要将Service注册到Service Manager中，再启动一个Binder线程池来等待和处理Client的通信请求。</p><p>注册过程(addService)核心工作：在服务所在进程创建<code>binder_node</code>，在ServiceManager进程创建<code>binder_ref</code>.</p><p>以Media服务为例，注册的过程涉及到MediaPlayerService(作为Client进程)和Service Manager(作为Service进程)，通信流程图如下所示：<br><img src="/2018/08/05/Binder机制简析-三/media_player_service_ipc.png" alt=""></p><p>过程分析：</p><ol><li><p>MediaPlayerService进程调用ioctl()向Binder驱动发送IPC数据，该过程可以理解成一个事务binder_transaction(记为T1)，执行当前操作的线程binder_thread(记为thread1)，则T1-&gt;from_parent=NULL，T1-&gt;from = thread1，thread1-&gt;transaction_stack=T1。其中IPC数据内容包含：</p><ul><li>Binder协议为BC_TRANSACTION；</li><li>Handle等于0；</li><li>RPC代码为ADD_SERVICE；</li><li>RPC数据为”media.player”</li></ul></li><li><p>Binder驱动收到该Binder请求，生成BR_TRANSACTION命令，选择目标处理该请求的线程，即ServiceManager的binder线程(记为thread2)，则 T1-&gt;to_parent = NULL，T1-&gt;to_thread = thread2。并将整个binder_transaction数据(记为T2)插入到目标线程的todo队列；</p></li><li>Service Manager的线程thread2收到T2后，调用服务注册函数将服务”media.player”注册到服务目录中。当服务注册完成后，生成IPC应答数据(BC_REPLY)，T2-&gt;form_parent = T1，T2-&gt;from = thread2, thread2-&gt;transaction_stack = T2。</li><li>Binder驱动收到该Binder应答请求，生成BR_REPLY命令，T2-&gt;to_parent = T1，T2-&gt;to_thread = thread1, thread1-&gt;transaction_stack = T2。 在MediaPlayerService收到该命令后，知道服务注册完成便可以正常使用。</li></ol><h2 id="获取Service"><a href="#获取Service" class="headerlink" title="获取Service"></a>获取Service</h2><p>请求服务(getService)过程，就是向servicemanager进程查询指定服务，当执行binder_transaction()时，会区分请求服务所属进程情况。</p><ol><li>当请求服务的进程与服务属于不同进程，则为请求服务所在进程创建<code>binder_ref</code>对象，指向服务进程中的<code>binder_node</code>;<ul><li>最终readStrongBinder()，返回的是BpBinder对象；</li></ul></li><li>当请求服务的进程与服务属于同一进程，则不再创建新对象，只是引用计数加1，并且修改type为<code>BINDER_TYPE_BINDER</code>或<code>BINDER_TYPE_WEAK_BINDER</code>。<ul><li>最终readStrongBinder()，返回的是BBinder对象的真实子类；</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;注册Service&quot;&gt;&lt;a href=&quot;#注册Service&quot; class=&quot;headerlink&quot; title=&quot;注册Service&quot;&gt;&lt;/a&gt;注册Service&lt;/h2&gt;&lt;p&gt;Service组件运行在Server进程中，首先要将Service注册到Servic
      
    
    </summary>
    
      <category term="Android系统" scheme="http://yoursite.com/categories/Android%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="系统" scheme="http://yoursite.com/tags/%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="binder" scheme="http://yoursite.com/tags/binder/"/>
    
  </entry>
  
  <entry>
    <title>Binder机制简析(二)</title>
    <link href="http://yoursite.com/2018/08/03/Binder%E6%9C%BA%E5%88%B6%E7%AE%80%E6%9E%90-%E4%BA%8C/"/>
    <id>http://yoursite.com/2018/08/03/Binder机制简析-二/</id>
    <published>2018-08-03T12:01:04.000Z</published>
    <updated>2018-08-07T11:18:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="https://david1840.github.io/2018/08/02/Binder%E6%9C%BA%E5%88%B6%E7%AE%80%E6%9E%90-%E4%B8%80/" target="_blank" rel="noopener">Binder机制简析(一)</a>中大概分析了Binder驱动，本章主要分析Service Manager。</p><h1 id="Service-Manager"><a href="#Service-Manager" class="headerlink" title="Service Manager"></a>Service Manager</h1><p>它扮演着Binder进程间通信机制上下文管理者的角色，同时负责管理系统中的Service组件，并且向Client组件提供获取Service代理对象的服务(主要工作：查询和注册服务)</p><h2 id="Service-Manager启动"><a href="#Service-Manager启动" class="headerlink" title="Service Manager启动"></a>Service Manager启动</h2><p>主要有下面几个步骤：</p><ol><li><code>binder_open</code> 打开驱动，将其映射到本进程的地址空间。</li><li><code>binder_become_context_manager</code> 注册为binder服务的大管家</li><li><code>binder_loop</code> 进入无限循环，处理从Client进程(Service和Client组件对Service Manager来说都是Client进程)通信请求。（循环调用<code>binder_thread_read</code>来检查Service Manager进程是否有新的进程间通信请求需要处理，如果有就交给<code>binder_parse</code>方法处理，在<code>binder_parse</code>中调用<code>svcmgr_handler</code>来解析信息，调用对应的方法，查询服务、注册服务、列举所有服务）</li></ol><p>流程图：</p><p><img src="/2018/08/03/Binder机制简析-二/create_servicemanager.jpg" alt=""></p><h3 id="main"><a href="#main" class="headerlink" title="main"></a>main</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_state</span> *<span class="title">bs</span>;</span></span><br><span class="line">    <span class="comment">//打开binder驱动，申请128k字节大小的内存空间 【见小节2.2】</span></span><br><span class="line">    bs = binder_open(<span class="number">128</span>*<span class="number">1024</span>);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//成为上下文管理者</span></span><br><span class="line">    <span class="keyword">if</span> (binder_become_context_manager(bs)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    selinux_enabled = is_selinux_enabled(); <span class="comment">//selinux权限是否使能</span></span><br><span class="line">    sehandle = selinux_android_service_context_handle();</span><br><span class="line">    selinux_status_open(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (selinux_enabled &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sehandle == <span class="literal">NULL</span>) &#123;  </span><br><span class="line">            <span class="built_in">abort</span>(); <span class="comment">//无法获取sehandle</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (getcon(&amp;service_manager_context) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">abort</span>(); <span class="comment">//无法获取service_manager上下文</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进入无限循环，处理client端发来的请求</span></span><br><span class="line">    binder_loop(bs, svcmgr_handler);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="binder-loop"><a href="#binder-loop" class="headerlink" title="binder_loop"></a>binder_loop</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">void</span> <span class="keyword">binder_loop(struct </span><span class="keyword">binder_state </span>*<span class="keyword">bs, </span><span class="keyword">binder_handler </span>func) &#123;</span><br><span class="line">    int res<span class="comment">;</span></span><br><span class="line">    <span class="keyword">struct </span><span class="keyword">binder_write_read </span><span class="keyword">bwr;</span></span><br><span class="line"><span class="keyword"> </span>   uint32_t readbuf[<span class="number">32</span>]<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bwr.write_size </span>= <span class="number">0</span><span class="comment">;</span></span><br><span class="line">    <span class="keyword">bwr.write_consumed </span>= <span class="number">0</span><span class="comment">;</span></span><br><span class="line">    <span class="keyword">bwr.write_buffer </span>= <span class="number">0</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    readbuf[<span class="number">0</span>] = <span class="keyword">BC_ENTER_LOOPER;</span></span><br><span class="line"><span class="keyword"> </span>   //将<span class="keyword">BC_ENTER_LOOPER命令发送给binder驱动，让Service </span>Manager进入循环</span><br><span class="line">    <span class="keyword">binder_write(bs, </span>readbuf, sizeof(uint32_t))<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    for (<span class="comment">;;) &#123;</span></span><br><span class="line">        <span class="keyword">bwr.read_size </span>= sizeof(readbuf)<span class="comment">;</span></span><br><span class="line">        <span class="keyword">bwr.read_consumed </span>= <span class="number">0</span><span class="comment">;</span></span><br><span class="line">        <span class="keyword">bwr.read_buffer </span>= (uintptr_t) readbuf<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">        res = ioctl(<span class="keyword">bs-&gt;fd, </span><span class="keyword">BINDER_WRITE_READ, </span>&amp;<span class="keyword">bwr); </span>//进入循环，不断地<span class="keyword">binder读写过程</span></span><br><span class="line"><span class="keyword"> </span>       <span class="meta">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break;</span></span><br><span class="line"><span class="keyword"> </span>       &#125;</span><br><span class="line"></span><br><span class="line">        // 解析<span class="keyword">binder信息 </span></span><br><span class="line">        res = <span class="keyword">binder_parse(bs, </span><span class="number">0</span>, (uintptr_t) readbuf, <span class="keyword">bwr.read_consumed, </span>func)<span class="comment">;</span></span><br><span class="line">        <span class="meta">if</span> (res == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break;</span></span><br><span class="line"><span class="keyword"> </span>       &#125;</span><br><span class="line">        <span class="meta">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break;</span></span><br><span class="line"><span class="keyword"> </span>       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="binder-parse"><a href="#binder-parse" class="headerlink" title="binder_parse"></a>binder_parse</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">int</span> <span class="keyword">binder_parse(struct </span><span class="keyword">binder_state </span>*<span class="keyword">bs, </span><span class="keyword">struct </span><span class="keyword">binder_io </span>*<span class="keyword">bio,</span></span><br><span class="line"><span class="keyword"> </span>                uintptr_t ptr, size_t size, <span class="keyword">binder_handler </span>func)</span><br><span class="line">&#123;</span><br><span class="line">    int r = <span class="number">1</span><span class="comment">;</span></span><br><span class="line">    uintptr_t <span class="meta">end</span> = ptr + (uintptr_t) size<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">while</span> (ptr &lt; <span class="meta">end</span>) &#123;</span><br><span class="line">        uint32_t cmd = *(uint32_t *) ptr<span class="comment">;</span></span><br><span class="line">        ptr += sizeof(uint32_t)<span class="comment">;</span></span><br><span class="line">        <span class="keyword">switch(cmd) </span>&#123;</span><br><span class="line">        case <span class="keyword">BR_NOOP: </span> //无操作，退出循环</span><br><span class="line">            <span class="keyword">break;</span></span><br><span class="line"><span class="keyword"> </span>       case <span class="keyword">BR_TRANSACTION_COMPLETE:</span></span><br><span class="line"><span class="keyword"> </span>           <span class="keyword">break;</span></span><br><span class="line"><span class="keyword"> </span>       case <span class="keyword">BR_INCREFS:</span></span><br><span class="line"><span class="keyword"> </span>       case <span class="keyword">BR_ACQUIRE:</span></span><br><span class="line"><span class="keyword"> </span>       case <span class="keyword">BR_RELEASE:</span></span><br><span class="line"><span class="keyword"> </span>       case <span class="keyword">BR_DECREFS:</span></span><br><span class="line"><span class="keyword"> </span>           ptr += sizeof(<span class="keyword">struct </span><span class="keyword">binder_ptr_cookie);</span></span><br><span class="line"><span class="keyword"> </span>           <span class="keyword">break;</span></span><br><span class="line"><span class="keyword"> </span>       case <span class="keyword">BR_TRANSACTION: </span>&#123;</span><br><span class="line">            <span class="keyword">struct </span><span class="keyword">binder_transaction_data </span>*txn = (<span class="keyword">struct </span><span class="keyword">binder_transaction_data </span>*) ptr<span class="comment">;</span></span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">binder_dump_txn(txn);</span></span><br><span class="line"><span class="keyword"> </span>           <span class="meta">if</span> (func) &#123;</span><br><span class="line">                unsigned rdata[<span class="number">256</span>/<span class="number">4</span>]<span class="comment">;</span></span><br><span class="line">                <span class="keyword">struct </span><span class="keyword">binder_io </span>msg<span class="comment">; </span></span><br><span class="line">                <span class="keyword">struct </span><span class="keyword">binder_io </span>reply<span class="comment">;</span></span><br><span class="line">                int res<span class="comment">;</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">bio_init(&amp;reply, </span>rdata, sizeof(rdata), <span class="number">4</span>)<span class="comment">;</span></span><br><span class="line">                <span class="keyword">bio_init_from_txn(&amp;msg, </span>txn)<span class="comment">; //从txn解析出binder_io信息</span></span><br><span class="line">                //func在这里就指向<span class="keyword">svcmgr_handler</span></span><br><span class="line"><span class="keyword"> </span>               res = func(<span class="keyword">bs, </span>txn, &amp;msg, &amp;reply)<span class="comment">;</span></span><br><span class="line">                <span class="keyword">binder_send_reply(bs, </span>&amp;reply, txn-&gt;<span class="meta">data</span>.ptr.<span class="keyword">buffer, </span>res)<span class="comment">;</span></span><br><span class="line">            &#125;</span><br><span class="line">            ptr += sizeof(*txn)<span class="comment">;</span></span><br><span class="line">            <span class="keyword">break;</span></span><br><span class="line"><span class="keyword"> </span>       &#125;</span><br><span class="line">        case <span class="keyword">BR_REPLY: </span>&#123;</span><br><span class="line">            <span class="keyword">struct </span><span class="keyword">binder_transaction_data </span>*txn = (<span class="keyword">struct </span><span class="keyword">binder_transaction_data </span>*) ptr<span class="comment">;</span></span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">binder_dump_txn(txn);</span></span><br><span class="line"><span class="keyword"> </span>           <span class="meta">if</span> (<span class="keyword">bio) </span>&#123;</span><br><span class="line">                <span class="keyword">bio_init_from_txn(bio, </span>txn)<span class="comment">;</span></span><br><span class="line">                <span class="keyword">bio </span>= <span class="number">0</span><span class="comment">;</span></span><br><span class="line">            &#125;</span><br><span class="line">            ptr += sizeof(*txn)<span class="comment">;</span></span><br><span class="line">            r = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">            <span class="keyword">break;</span></span><br><span class="line"><span class="keyword"> </span>       &#125;</span><br><span class="line">        case <span class="keyword">BR_DEAD_BINDER: </span>&#123;</span><br><span class="line">            <span class="keyword">struct </span><span class="keyword">binder_death </span>*death = (<span class="keyword">struct </span><span class="keyword">binder_death </span>*)(uintptr_t) *(<span class="keyword">binder_uintptr_t </span>*)ptr<span class="comment">;</span></span><br><span class="line">            ptr += sizeof(<span class="keyword">binder_uintptr_t);</span></span><br><span class="line"><span class="keyword"> </span>           // <span class="keyword">binder死亡消息</span></span><br><span class="line"><span class="keyword"> </span>           death-&gt;func(<span class="keyword">bs, </span>death-&gt;ptr)<span class="comment">;</span></span><br><span class="line">            <span class="keyword">break;</span></span><br><span class="line"><span class="keyword"> </span>       &#125;</span><br><span class="line">        case <span class="keyword">BR_FAILED_REPLY:</span></span><br><span class="line"><span class="keyword"> </span>           r = -<span class="number">1</span><span class="comment">;</span></span><br><span class="line">            <span class="keyword">break;</span></span><br><span class="line"><span class="keyword"> </span>       case <span class="keyword">BR_DEAD_REPLY:</span></span><br><span class="line"><span class="keyword"> </span>           r = -<span class="number">1</span><span class="comment">;</span></span><br><span class="line">            <span class="keyword">break;</span></span><br><span class="line"><span class="keyword"> </span>       default:</span><br><span class="line">            return -<span class="number">1</span><span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return r<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="svcmgr-handler"><a href="#svcmgr-handler" class="headerlink" title="svcmgr_handler"></a>svcmgr_handler</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">int</span> <span class="keyword">svcmgr_handler(struct </span><span class="keyword">binder_state </span>*<span class="keyword">bs,</span></span><br><span class="line"><span class="keyword"> </span>                  <span class="keyword">struct </span><span class="keyword">binder_transaction_data </span>*txn,</span><br><span class="line">                   <span class="keyword">struct </span><span class="keyword">binder_io </span>*msg,</span><br><span class="line">                   <span class="keyword">struct </span><span class="keyword">binder_io </span>*reply)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct </span><span class="keyword">svcinfo </span>*si<span class="comment">; </span></span><br><span class="line">    uint16_t *s<span class="comment">;</span></span><br><span class="line">    size_t len<span class="comment">;</span></span><br><span class="line">    uint32_t handle<span class="comment">;</span></span><br><span class="line">    uint32_t <span class="keyword">strict_policy;</span></span><br><span class="line"><span class="keyword"> </span>   int allow_isolated<span class="comment">;</span></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">strict_policy </span>= <span class="keyword">bio_get_uint32(msg);</span></span><br><span class="line"><span class="keyword"> </span>   s = <span class="keyword">bio_get_string16(msg, </span>&amp;len)<span class="comment">;</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch(txn-&gt;code) </span>&#123;</span><br><span class="line">    case <span class="keyword">SVC_MGR_GET_SERVICE:</span></span><br><span class="line"><span class="keyword"> </span>   case <span class="keyword">SVC_MGR_CHECK_SERVICE: </span></span><br><span class="line">        s = <span class="keyword">bio_get_string16(msg, </span>&amp;len)<span class="comment">; //服务名</span></span><br><span class="line">        //根据名称查找相应服务</span><br><span class="line">        handle = do_find_service(<span class="keyword">bs, </span>s, len, txn-&gt;sender_euid, txn-&gt;sender_pid)<span class="comment">;</span></span><br><span class="line">        <span class="keyword">bio_put_ref(reply, </span>handle)<span class="comment">;</span></span><br><span class="line">        return <span class="number">0</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    case <span class="keyword">SVC_MGR_ADD_SERVICE: </span></span><br><span class="line">        s = <span class="keyword">bio_get_string16(msg, </span>&amp;len)<span class="comment">; //服务名</span></span><br><span class="line">        handle = <span class="keyword">bio_get_ref(msg); </span>//handle</span><br><span class="line">        allow_isolated = <span class="keyword">bio_get_uint32(msg) </span>? <span class="number">1</span> : <span class="number">0</span><span class="comment">;</span></span><br><span class="line">         //注册指定服务</span><br><span class="line">        <span class="meta">if</span> (do_add_service(<span class="keyword">bs, </span>s, len, handle, txn-&gt;sender_euid,</span><br><span class="line">            allow_isolated, txn-&gt;sender_pid))</span><br><span class="line">            return -<span class="number">1</span><span class="comment">;</span></span><br><span class="line">        <span class="keyword">break;</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword"> </span>   case <span class="keyword">SVC_MGR_LIST_SERVICES: </span>&#123;  </span><br><span class="line">        uint32_t n = <span class="keyword">bio_get_uint32(msg);</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword"> </span>       <span class="meta">if</span> (!<span class="keyword">svc_can_list(txn-&gt;sender_pid)) </span>&#123;</span><br><span class="line">            return -<span class="number">1</span><span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">        si = <span class="keyword">svclist;</span></span><br><span class="line"><span class="keyword"> </span>       <span class="meta">while</span> ((n-- &gt; <span class="number">0</span>) &amp;&amp; si)</span><br><span class="line">            si = si-&gt;next<span class="comment">;</span></span><br><span class="line">        <span class="meta">if</span> (si) &#123;</span><br><span class="line">            <span class="keyword">bio_put_string16(reply, </span>si-&gt;name)<span class="comment">;</span></span><br><span class="line">            return <span class="number">0</span><span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">        return -<span class="number">1</span><span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="symbol">    default:</span></span><br><span class="line">        return -<span class="number">1</span><span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bio_put_uint32(reply, </span><span class="number">0</span>)<span class="comment">;</span></span><br><span class="line">    return <span class="number">0</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法的功能：查询服务，注册服务，以及列举所有服务</p><h2 id="核心工作"><a href="#核心工作" class="headerlink" title="核心工作"></a>核心工作</h2><p>servicemanager的核心工作就是注册服务和查询服务:</p><h3 id="注册服务"><a href="#注册服务" class="headerlink" title="注册服务"></a>注册服务</h3><p>记录服务名和handle信息，保存到svclist列表<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_add_service</span><span class="params">(struct binder_state *bs,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">const</span> <span class="keyword">uint16_t</span> *s, <span class="keyword">size_t</span> len,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">uint32_t</span> handle, <span class="keyword">uid_t</span> uid, <span class="keyword">int</span> allow_isolated,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">pid_t</span> spid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">svcinfo</span> *<span class="title">si</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!handle || (len == <span class="number">0</span>) || (len &gt; <span class="number">127</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//权限检查</span></span><br><span class="line">    <span class="keyword">if</span> (!svc_can_register(s, len, spid)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务检索</span></span><br><span class="line">    si = find_svc(s, len);</span><br><span class="line">    <span class="keyword">if</span> (si) &#123;</span><br><span class="line">        <span class="keyword">if</span> (si-&gt;handle) &#123;</span><br><span class="line">            svcinfo_death(bs, si); <span class="comment">//服务已注册时，释放相应的服务</span></span><br><span class="line">        &#125;</span><br><span class="line">        si-&gt;handle = handle;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        si = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*si) + (len + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>));</span><br><span class="line">        <span class="keyword">if</span> (!si) &#123;  <span class="comment">//内存不足，无法分配足够内存</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        si-&gt;handle = handle;</span><br><span class="line">        si-&gt;len = len;</span><br><span class="line">        <span class="built_in">memcpy</span>(si-&gt;name, s, (len + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>)); <span class="comment">//内存拷贝服务信息</span></span><br><span class="line">        si-&gt;name[len] = <span class="string">'\0'</span>;</span><br><span class="line">        si-&gt;death.func = (<span class="keyword">void</span>*) svcinfo_death;</span><br><span class="line">        si-&gt;death.ptr = si;</span><br><span class="line">        si-&gt;allow_isolated = allow_isolated;</span><br><span class="line">        si-&gt;next = svclist; <span class="comment">// svclist保存所有已注册的服务</span></span><br><span class="line">        svclist = si;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以BC_ACQUIRE命令，handle为目标的信息，通过ioctl发送给binder驱动</span></span><br><span class="line">    binder_acquire(bs, handle);</span><br><span class="line">    <span class="comment">//以BC_REQUEST_DEATH_NOTIFICATION命令的信息，通过ioctl发送给binder驱动，主要用于清理内存等收尾工作。</span></span><br><span class="line">    binder_link_to_death(bs, handle, &amp;si-&gt;death);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注册服务的分以下3部分工作：</p><ul><li><code>svc_can_register</code>：检查权限，检查selinux权限是否满足；</li><li><code>find_svc</code>：服务检索，根据服务名来查询匹配的服务；</li><li><code>svcinfo_death</code>：释放服务，当查询到已存在同名的服务，则先清理该服务信息，再将当前的服务加入到服务列表svclist；</li></ul><h3 id="查询服务"><a href="#查询服务" class="headerlink" title="查询服务"></a>查询服务</h3><p>根据服务名查询相应的的handle信息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> do_find_service(struct binder_state *bs, <span class="keyword">const</span> <span class="keyword">uint16_t</span> *s, <span class="keyword">size_t</span> len, <span class="keyword">uid_t</span> uid, <span class="keyword">pid_t</span> spid)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//查询相应的服务 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">svcinfo</span> *<span class="title">si</span> = <span class="title">find_svc</span>(<span class="title">s</span>, <span class="title">len</span>);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!si || !si-&gt;handle) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!si-&gt;allow_isolated) &#123;</span><br><span class="line">        <span class="keyword">uid_t</span> appid = uid % AID_USER;</span><br><span class="line">        <span class="comment">//检查该服务是否允许孤立于进程而单独存在</span></span><br><span class="line">        <span class="keyword">if</span> (appid &gt;= AID_ISOLATED_START &amp;&amp; appid &lt;= AID_ISOLATED_END) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务是否满足查询条件</span></span><br><span class="line">    <span class="keyword">if</span> (!svc_can_find(s, len, spid)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> si-&gt;handle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询到目标服务，并返回该服务所对应的handle</p><h2 id="获取Service-Manager代理"><a href="#获取Service-Manager代理" class="headerlink" title="获取Service Manager代理"></a>获取Service Manager代理</h2><p>由于Service Manager本身也是一个Service组件，因此，其他Service组件和Client组件在使用它提供的组件之前，也要获取它的代理对象。Service Manager代理对象的类型为BpServiceManager，它用来描述一个实现了IServiceManager接口的Client组件。</p><p>IServiceManager接口定义了getService()、chaekService()、addService()、listService()方法。</p><p>Android系统在应用程序框架层的Binder库中提供了一个函数<code>defaultServiceManager()</code>，该方法为单例模式，保证一个进程中最多只有一个Service Manager代理对象。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IServiceManager&gt; defaultServiceManager()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (gDefaultServiceManager != <span class="keyword">NULL</span>) <span class="keyword">return</span> gDefaultServiceManager;</span><br><span class="line">    &#123;</span><br><span class="line">        AutoMutex _l(gDefaultServiceManagerLock); <span class="comment">//加锁</span></span><br><span class="line">        <span class="keyword">while</span> (gDefaultServiceManager == <span class="keyword">NULL</span>) &#123;</span><br><span class="line">             <span class="comment">//关键代码</span></span><br><span class="line">            gDefaultServiceManager = interface_cast&lt;IServiceManager&gt;(ProcessState::self()-&gt;getContextObject(<span class="keyword">NULL</span>));</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (gDefaultServiceManager == <span class="keyword">NULL</span>)</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> gDefaultServiceManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当尝试创建或获取ServiceManager时，ServiceManager可能尚未准备就绪，这时通过sleep 1秒后，循环尝试获取直到成功。</p><p>gDefaultServiceManager的创建过程,可分解为以下3个步骤：</p><ol><li><code>ProcessState::self()</code>：用于获取ProcessState对象(也是单例模式)，每个进程有且只有一个ProcessState对象，存在则直接返回，不存在则创建。</li></ol><blockquote><pre><code>ProcessState::self()主要工作：    调用open()，打开/dev/binder驱动设备；    再利用mmap()，创建大小为1M-8K的内存地址空间；    设定当前进程最大的最大并发Binder线程个数为16。</code></pre></blockquote><ol start="2"><li><code>getContextObject()</code>： 用于获取BpBinder对象，对于handle=0的BpBinder对象，存在则直接返回，不存在才创建。</li><li><code>interface_cast&lt;IServiceManager&gt;()</code>：用于获取BpServiceManager对象。</li></ol><blockquote><pre><code>在整个Binder系统中handle=0代表ServiceManager所对应的BBinder</code></pre></blockquote><p><code>defaultServiceManager</code> 等价于 <code>new BpServiceManager(new BpBinder(0))</code>;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在&lt;a href=&quot;https://david1840.github.io/2018/08/02/Binder%E6%9C%BA%E5%88%B6%E7%AE%80%E6%9E%90-%E4%B8%80/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Bi
      
    
    </summary>
    
      <category term="Android系统" scheme="http://yoursite.com/categories/Android%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="系统" scheme="http://yoursite.com/tags/%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="binder" scheme="http://yoursite.com/tags/binder/"/>
    
  </entry>
  
</feed>
