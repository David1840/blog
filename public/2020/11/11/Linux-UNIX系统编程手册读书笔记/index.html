<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="本网站主要供个人学习记录使用，如有侵权请立即邮件联系"><meta name="keywords" content="Android, Java, Linux, 数据结构"><title>Linux_UNIX系统编程手册 | Programmer Liu</title><link rel="stylesheet" type="text/css" href="//fonts.neworld.org/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Linux_UNIX系统编程手册</h1><a id="logo" href="/.">Programmer Liu</a><p class="description">精彩生活，不惧挑战，做一只有理想的的程序猿</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Arama"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Linux_UNIX系统编程手册</h1><div class="post-meta"><a href="/2020/11/11/Linux-UNIX系统编程手册读书笔记/#comments" class="comment-count"></a><p><span class="date">Nov 11, 2020</span><span><a href="/categories/Linux系统/" class="category">Linux系统</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>系统调用是受控的内核入口，借助这一机制，进程可以请求内核以自己的名义去执行某些操作。以应用程序编程接口（API）的形式，内核提供有一系列服务供程序访问。</p>
<blockquote>
<ul>
<li>系统调用将处理器从用户态切换到核心态，以便CPU访问受到保护的内核内存</li>
<li>系统调用的组成是固定的，每个系统调用都由一个唯一的数字来标识。(程序通过名称来标识系统调用，对这一编号方案往往一无所知)</li>
<li>每个系统调用可辅之以一套参数，对用户空间(亦即进程的寻你地址空间)与内核空间之间传递的信息加以规范。</li>
</ul>
</blockquote>
<p>从编程角度来看，系统调用和C语言函数的调用很相似。然而，在执行系统调用时，其幕后会经历诸多步骤。以一个具体的硬件平台-x86-32为例，按事件发生的顺序对这些步骤加以分析。</p>
<ol>
<li>应用程序调用C语言函数库中的外壳（wrapper）函数，来发起系统调用。</li>
<li>对系统调用中断处理例程来说，外壳函数必须保证所有的系统调用参数可用，通过堆栈，这些参数传入外壳函数，但内核却希望将这些参数置入特定寄存器。因此，外壳函数会讲上述参数复制到寄存器。</li>
<li>由于所有系统调用进入内核的方式相同，内核需要去区分每个系统调用。为此外壳函数会讲系统调用编号复制到一个特殊的CPU寄存器（%eax）中。</li>
<li>外壳函数执行一条中断机器指令（int 0x80），引发处理器从用户态切换到核心态，并执行系统中断0x80的中断矢量所指向的代码。</li>
<li>为响应中断0x80，内核会调用system_call()例程来处理这次中断，具体如下：<ul>
<li>在内核栈中保存寄存器值</li>
<li>审核系统嗲用编号的有效性</li>
<li>以系统调用编号对存放所有调用服务例程的列表（内核变量sys_call_table）进行索引，发现并调用相应的系统调用服务例程。若系统调用服务例程带有参数，那么将首先检查参数的有效性。最后，该服务例程会将结果状态放回给system_call()例程</li>
<li>从内核栈中恢复各寄存器值，并将系统调用返回值置于栈中</li>
<li>返回至外壳函数，同时将处理器切换回用户态</li>
</ul>
</li>
<li>若系统调用服务例程的返回值表明调用有误，外壳函数会使用该值来设置全局变量errno。然后，外壳函数会返回到调用程序，并同时返回一个整型值，以表明系统调用是否成功。</li>
</ol>
<p>下图以系统调用execve()为例</p>
<p><img src="/2020/11/11/Linux-UNIX系统编程手册读书笔记/sys_call.png" alt="系统调用"></p>
<h2 id="1、文件I-O"><a href="#1、文件I-O" class="headerlink" title="1、文件I/O"></a>1、文件I/O</h2><p>所有执行I/O操作的系统嗲用都以文件描述符，一个非负整数(通常是小整数)，来指代打开的文件。文件描述符用以表示所有类型的已打开文件，包括管道(pipe)、FIFO、socket、终端、设备和普通文件。针对每个进程，文件描述符都自成一套。</p>
<h3 id="1-1通用I-O"><a href="#1-1通用I-O" class="headerlink" title="1.1通用I/O"></a>1.1通用I/O</h3><p>UNIX I/O模型的显著特点之一是其输入/输出的通用性概念。这就意味着使用4个同样的系统调用open()、read()、wrtie()和close()可以对所有类型的文件执行I/O操作，包括终端之类的设备。</p>
<h3 id="1-2打开一个文件：open"><a href="#1-2打开一个文件：open" class="headerlink" title="1.2打开一个文件：open()"></a>1.2打开一个文件：open()</h3><p>open()调用既能打开一个已存在的文件，也能创建并打开一个新文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname,<span class="keyword">int</span> flags,...<span class="comment">/* mode_t mode*/</span>)</span></span>;</span><br><span class="line">             </span><br><span class="line">                                              Return file descriptor on success,<span class="keyword">or</span> <span class="number">-1</span> on error</span><br></pre></td></tr></table></figure>
<p>参数flags为位掩码，用于制定文件的访问模式，可选下表所示的常量之一。</p>
<p><img src="/2020/11/11/Linux-UNIX系统编程手册读书笔记/UNIX_IO_mode.png" alt="系统调用"></p>
<p>open函数使用的例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只读方式打开已存在的文件</span></span><br><span class="line">fd = open(<span class="string">"startup"</span>,o_RDONLY);</span><br><span class="line"><span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">   errExit(<span class="string">"open"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读写方式打开或创建文件，清空文件内容</span></span><br><span class="line">fd = open(<span class="string">"myfile"</span>,O_RD_WD | O_CREAT | O_TRUNNC, S_IRUSR | S_IWUSR);</span><br><span class="line"><span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">   errExit(<span class="string">"open"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开或创建只写的文件，清空文件内容，总在文件尾部追加数据</span></span><br><span class="line">fd = open(<span class="string">"w.log"</span>,O_WRONLY | O_CREAT | O_TRUNNC | O_APPEND, S_IRUSR | S_IWUSR);</span><br><span class="line"><span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">   errExit(<span class="string">"open"</span>);</span><br></pre></td></tr></table></figure>
<p><strong>open()中flags参数</strong></p>
<p><img src="/2020/11/11/Linux-UNIX系统编程手册读书笔记/flags1.png" alt=""></p>
<p><img src="/2020/11/11/Linux-UNIX系统编程手册读书笔记/flags2.png" alt=""></p>
<h3 id="1-3读取文件内容：read"><a href="#1-3读取文件内容：read" class="headerlink" title="1.3读取文件内容：read()"></a>1.3读取文件内容：read()</h3><p>read()系统调用从文件描述符fd所指代的打开文件中读取数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> fd,<span class="keyword">void</span> *buffer,<span class="keyword">size_t</span> count);</span><br><span class="line">																				Returns number of bytes read,<span class="number">0</span>on EOF,<span class="keyword">or</span> <span class="number">-1</span> on error</span><br></pre></td></tr></table></figure>
<p>count 参数指定最多能读取的字节数。buffer参数提供用来存放输入数据的内存缓冲区地址。缓冲区至少有count个字节。</p>
<h3 id="1-4数据写入文件：write"><a href="#1-4数据写入文件：write" class="headerlink" title="1.4数据写入文件：write()"></a>1.4数据写入文件：write()</h3><p>write()系统调用将数据写入一个已打开的文件中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> write(<span class="keyword">int</span> fd,<span class="keyword">void</span> *buffer,<span class="keyword">size_t</span> count);</span><br><span class="line">																				Returns number of bytes wrttten,<span class="keyword">or</span> <span class="number">-1</span> on error</span><br></pre></td></tr></table></figure>
<h3 id="1-5关闭文件：close"><a href="#1-5关闭文件：close" class="headerlink" title="1.5关闭文件：close()"></a>1.5关闭文件：close()</h3><p>close()系统调用关闭一个打开的文件描述符，并将其释放回调用进程，供该进程继续使用。当一进程终止时，将自动关闭其已打开的所有文件描述符。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line">																				              Returns <span class="number">0</span> on success,<span class="keyword">or</span> <span class="number">-1</span> on error</span><br></pre></td></tr></table></figure>
<h3 id="1-6改变文件偏移量：lseek"><a href="#1-6改变文件偏移量：lseek" class="headerlink" title="1.6改变文件偏移量：lseek()"></a>1.6改变文件偏移量：lseek()</h3><p>对于每个打开的文件，系统内核会记录其文件偏移量，有时也将文件偏移量称为读写偏移量或指针。文件偏移量是指执行下一个read()或write()操作的文件起始位置，会以相对于文件头部起始点的文件当前位置脸表示。文件第一个字节的偏移量为0。</p>
<p>文件打开时，会将文件偏移量设置为指向文件开始，以后每次read()或write()调用将自动对其进行调整，以指向已读或已读数据后的下一字节。因此，连续read()或write()调用将按顺序递进，对文件进行操作。</p>
<p>针对文件描述符fd参数所指代的已打开文件，lseek()系统调用依照offset和whence参数调整该文件的偏移量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">off_t</span> lseek(<span class="keyword">int</span> fd,<span class="keyword">off_t</span> offset,<span class="keyword">int</span> whence);</span><br><span class="line">								Returns <span class="keyword">new</span> file offset <span class="keyword">if</span> successful,<span class="keyword">or</span> <span class="number">-1</span> on error</span><br></pre></td></tr></table></figure>
<p>offset参数指定了一个以字节为单位的数值。whence参数则表明应参照哪个基点来解释offset参数，应为下列其中之一：</p>
<p><strong>SEEK_SET:</strong> </p>
<p>​            将文件偏移量设置为从文件头部起始点开始的offset个字节。</p>
<p><strong>SEEK_CUR：</strong></p>
<p>​            相对于当前文件偏移量，将文件偏移量调整offset个字节。</p>
<p><strong>SEEK_END：</strong></p>
<p>​            将文件偏移量设置为起始于文件尾部的offset个字节。也就是说，offset参数应该从文件最后一个字节之后的下一个字节算起。</p>
<p><img src="/2020/11/11/Linux-UNIX系统编程手册读书笔记/lseek.png" alt=""></p>
<p>####文件空洞</p>
<p>如果程序的文件偏移量已然跨越了文件结尾，然后再执行I/O操作，read()会返回0，表示文件结尾。write()函数可以在文件结尾后的任意位置写入数据。</p>
<p>从文件结尾后到新写入数据间的这段空间被称为文件空洞。从编程角度看，文件空洞中是存在字节的，读取空洞将返回以0（空字节）填充的缓冲区。</p>
<p>然而，文件空洞不占用任何磁盘空间。直到后续某个时点，在文件空洞中写入了数据，文件系统才会为之分配磁盘块。文件空洞的主要优势在于，与为实际需要的空字节分配磁盘块相比，稀疏填充的文件会占用较少的磁盘空间。 </p>
<h3 id="1-7通用I-O模型以外的操作：ioctl"><a href="#1-7通用I-O模型以外的操作：ioctl" class="headerlink" title="1.7通用I/O模型以外的操作：ioctl()"></a>1.7通用I/O模型以外的操作：ioctl()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ioctl</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">int</span> request,...<span class="comment">/* argp */</span>)</span></span>;</span><br><span class="line"> 															Value returned on success depends on request,<span class="keyword">or</span> <span class="number">-1</span> on error</span><br></pre></td></tr></table></figure>
<h2 id="2、深入探究文件I-O"><a href="#2、深入探究文件I-O" class="headerlink" title="2、深入探究文件I/O"></a>2、深入探究文件I/O</h2><h3 id="2-1-原子操作和竞争条件"><a href="#2-1-原子操作和竞争条件" class="headerlink" title="2.1 原子操作和竞争条件"></a>2.1 原子操作和竞争条件</h3><p>所有系统调用都是以原子操作方式执行的。内核保证了某系统调用中的所有步骤会作为独立操作而一次性加以执行，其间不会为其它进程或线程所中断。</p>
<p>原子性是某些操作得以圆满成功的关键所在。特别是它规避了竞争状态。竞争状态是这样一种情形：操作共享资源的两个进程或线程，其结果取决于一个无法预期的顺序，即这些进程获得CPU使用权的先后相对顺序。</p>
<p><strong>以独占方式创建一个文件</strong></p>
<p>当同时指定O_EXCL与O_CREAT作为open()的标志位时，如果要打开的文件已经存在，则open()将返回一个错误。这提供了一种机制，保证进程是打开文件的创建者。对文件是否存在的检查和创建文件属于同一原子操作。而当代码中没有使用O_EXCL标志时。</p>
<p><img src="/2020/11/11/Linux-UNIX系统编程手册读书笔记/Atom.png" alt=""></p>
<p>如果两个进程如上图所示流程运行，两个进程都会声称自己以独占方式创建了文件。</p>
<p>由于第一个进程在检查文件是否存在和创建文件之间发生了中断，造成两个进程都声称自己是文件的创建者。结合O_CREAT和O_EXCL标志来一次性调用open()可以防止这种情况，因为这确保了检查文件和创建文件的步骤属于一个单一的原子(不可中断的)操作。</p>
<h3 id="2-2-文件控制操作：fcntl"><a href="#2-2-文件控制操作：fcntl" class="headerlink" title="2.2 文件控制操作：fcntl()"></a>2.2 文件控制操作：fcntl()</h3><p>fcntl()系统调用对一个打开的文件描述符执行一系列控制操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">int</span> cmd,...)</span></span>;</span><br><span class="line">															Return on success depends on cmd,<span class="keyword">or</span> <span class="number">-1</span> onn error</span><br></pre></td></tr></table></figure>
<p>cmd参数所支持的操作范围很广，下面会加以研讨。</p>
<h3 id="2-3-打开文件的状态标志"><a href="#2-3-打开文件的状态标志" class="headerlink" title="2.3 打开文件的状态标志"></a>2.3 打开文件的状态标志</h3><p>fcntl()的用途之一是针对一个打开的文件，获取或修改其访问模式和状态标志(这些值是通过指定open()调用的flag参数来设置的)。要获取这些设置，应将fcntl()的cmd参数设置为F_GETFL。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> flags，accessMode;</span><br><span class="line">flags = fcntl(fd,F_GETFL);</span><br><span class="line"><span class="keyword">if</span>(flage == <span class="number">-1</span>)</span><br><span class="line">   errRxit(<span class="string">"fcntl"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(flags &amp; O_SYNC)  <span class="comment">// 测试文件是否以同步写方式打开</span></span><br><span class="line">	 <span class="built_in">printf</span>(<span class="string">"writes are synchronized\n"</span>);</span><br></pre></td></tr></table></figure>
<p>判定文件的访问模式有一点复杂，这是因为O_RDONLY(0)、O_WRONLY(1)和O_RDWR(2)这3个常量并不与打开文件状态标志中的单个比特位对应。因此，要判定访问模式，需使用掩码O_ACCMODE与flag相与，将结果与3个常量进行比对，示例代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">accessMode = flags &amp; O_ACCMODE;</span><br><span class="line"><span class="keyword">if</span>(accessMode == O_WRONLY || accessMode == O_RDWR)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"file is writable\n"</span>);</span><br></pre></td></tr></table></figure>
<p>可以使用fcntl()的F_SETFL 命令来修改打开文件的某些状态标志。允许更改的标志有O_APPEND、O_NONBLOCK、O_NOATIME、O_ASYNC和O_DIRECT。</p>
<p>使用fcntl()修改文件状态标志，尤其适用如下场景。</p>
<ul>
<li>文件不是有调用程序打开的，所以程序也无法使用open()调用来控制文件的状态标志。</li>
<li>文件描述符的获取是通过open()之外的系统调用。比如pipe()调用，该调用创建一个管道，并返回两个文件描述符分别对应管道的两端。再比如socket()调用，该调用创建一个套接字并返回指向该套机诶字的文件描述符。</li>
</ul>
<p>例如，为了添加O_APPEND标志：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> flags;</span><br><span class="line"></span><br><span class="line">flags  = fnctl(fd,F_GETFL);</span><br><span class="line"><span class="keyword">if</span>(flags == <span class="number">-1</span>)</span><br><span class="line">	 errExit(<span class="string">"fcntl"</span>);</span><br><span class="line">flags |= O_APPEND;</span><br><span class="line"><span class="keyword">if</span>(fcntl(fd,F_SETFL,flags) == <span class="number">-1</span>)</span><br><span class="line">   errExit(<span class="string">"fcntl"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="2-4-文件描述符和打开文件之间的关系"><a href="#2-4-文件描述符和打开文件之间的关系" class="headerlink" title="2.4 文件描述符和打开文件之间的关系"></a>2.4 文件描述符和打开文件之间的关系</h3><p>到目前为止，文件描述符和打开文件之前似乎呈现出一一对应的关系。然而，实际并非如此。多个文件描述符指向同一打开文件，这既有可能，也属必要。这些文件描述符可在相同或不同的进程中打开。</p>
<p>要理解具体情况如何，需要查看由内核维护的3个数据结构。</p>
<ul>
<li>进程级的文件描述符表。</li>
<li>系统级的打开文件表。</li>
<li>文件系统的i-node表。</li>
</ul>
<p>针对每个进程，内核为其维护打开文件的描述符(open file descriptor)表。该表的每一条目都记录了单个文件描述符的相关信息。</p>
<p>内核对所有打开的文件维护有一个系统级的描述表格(opeb file description table)。也可称为打开文件表(open file table)，并将表中各条目称为打开文件句柄(open file handle)。一个打开文件句柄存储了与一个打开文件相关的全部信息.</p>
<ul>
<li>当前文件偏移量</li>
<li>打开文件时所使用的状态标志</li>
<li>文件访问模式</li>
<li>与信号驱动I/O相关的设置</li>
<li>对该文件i-node 对象的引用</li>
</ul>
<p>每个文件系统都会为驻留其上的所有文件建立一个i-node表。每个文件的i-node信息</p>
<ul>
<li>文件类型和访问权限</li>
<li>一个指针，指向该文件所持有的锁的列表</li>
<li>文件的各种属性，包括文件大小以及不同类型操作相关的时间戳</li>
</ul>
<p><img src="/2020/11/11/Linux-UNIX系统编程手册读书笔记/2_4.png" alt=""></p>
<h3 id="2-5复制文件描述符"><a href="#2-5复制文件描述符" class="headerlink" title="2.5复制文件描述符"></a>2.5复制文件描述符</h3><p>Bourne shell的I/O重定向语法 2&gt;&amp;1，意在通知shell把标准错误(文件描述符2)重定向到标准输入(文件描述符1)。</p>
<p>dup()调用复制一个打开的文件描述符oldfd，并返回一个新描述符，二者都指向同一个打开的文件句柄。系统会保证新描述符一定是编号值最低的未用文件描述符。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> oldfd)</span></span>;</span><br><span class="line"></span><br><span class="line">							Returns(<span class="keyword">new</span>)file descriptor on success,<span class="keyword">or</span> <span class="number">-1</span> on error</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<p><code>newfd= dup(1);</code></p>
<p>在假定正常情况下，shell已经代表程序打开了文件描述符0，1和2，且没有其它描述符在用，dup()调用会创建文件描述符1的副本，返回的文件描述符编号值为3。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> oldfd，<span class="keyword">int</span> newfd)</span></span>;</span><br><span class="line"></span><br><span class="line">							Returns(<span class="keyword">new</span>)file descriptor on success,<span class="keyword">or</span> <span class="number">-1</span> on error</span><br></pre></td></tr></table></figure>
<p>dup2()系统调用会为oldfd参数所指定的文件描述符创建副本，其编号由newfd参数指定。如果由newfd参数所指定的文件描述符之前已经打开，那么dup2()会先将其关闭。</p>
<p>fcntl()的F_DUPFD操作是复制文件描述符的另一接口，更具灵活性。</p>
<p><code>newfd = fcntl(oldfd,F_DUPFD,startfd);</code></p>
<p>该调用为oldfd创建一个副本，且将使用大于等于startfd的最小未用值作为描述符编号。</p>
<p>dup3()系统调用完成的工作与dup2()相同，只是增加了一个附加参数flag，这是一个可以修改系统调用行为的位掩码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GUN_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup3</span><span class="params">(<span class="keyword">int</span> oldfd，<span class="keyword">int</span> newfd,<span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line">							Returns(<span class="keyword">new</span>)file descriptor on success,<span class="keyword">or</span> <span class="number">-1</span> on error</span><br></pre></td></tr></table></figure>
<p>目前，dup3()只支持一个标志O_CLOEXEC,这将促使内核为新文件描述符设置close-on-exec标志(FD_CLOEXEC)。</p>
<h3 id="2-6-在文件特定偏移量处的I-O：pread-和pwrite"><a href="#2-6-在文件特定偏移量处的I-O：pread-和pwrite" class="headerlink" title="2.6 在文件特定偏移量处的I/O：pread()和pwrite()"></a>2.6 在文件特定偏移量处的I/O：pread()和pwrite()</h3><p>系统调用pread()和pwrite()完成与read()和write()相类似的工作，只是前两者会在offset参数所指定的位置进行文件I/O操作，而非始于文件的当前偏移量处，且它们不会改变文件的当前偏移量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> pread(<span class="keyword">int</span> fd,<span class="keyword">void</span> *buf,<span class="keyword">size_t</span> count,<span class="keyword">off_t</span> offset);</span><br><span class="line">								 Returns number of bytes read,<span class="number">0</span> on EOF,<span class="keyword">or</span> <span class="number">-1</span> on error</span><br><span class="line"><span class="keyword">ssize_t</span> pwrite(<span class="keyword">int</span> fd,<span class="keyword">const</span> <span class="keyword">void</span> *buf,<span class="keyword">size_t</span> count,<span class="keyword">off_t</span> offset);</span><br><span class="line">								       Returns number of bytes written,<span class="keyword">or</span> <span class="number">-1</span> on error</span><br></pre></td></tr></table></figure>
<p>pread()调用等于将如下调用纳入同一原子操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">off_t</span> orig;</span><br><span class="line"></span><br><span class="line">orig = lseek(fd,<span class="number">0</span>,SEEK_CUR);  <span class="comment">//保存当前偏移量</span></span><br><span class="line">lseek(fd,offset,SEEK_SET);</span><br><span class="line">s= read(fd,buf,len);</span><br><span class="line">lseek(fd,orig,SEEK_SET); <span class="comment">//恢复原本的偏移量</span></span><br></pre></td></tr></table></figure>
<h3 id="2-7-分散输入和集中输出-Scatter-Gather-I-O-readv-和writev"><a href="#2-7-分散输入和集中输出-Scatter-Gather-I-O-readv-和writev" class="headerlink" title="2.7 分散输入和集中输出(Scatter-Gather I/O):readv()和writev()"></a>2.7 分散输入和集中输出(Scatter-Gather I/O):readv()和writev()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> readv(<span class="keyword">int</span> fd,<span class="keyword">const</span> struct iovec *iov,<span class="keyword">int</span> iovcnt);</span><br><span class="line">							Returns number of bytes read,<span class="number">0</span> on EOF,<span class="keyword">or</span> <span class="number">-1</span> on error</span><br><span class="line">							</span><br><span class="line"><span class="keyword">ssize_t</span> writev(<span class="keyword">int</span> fd,<span class="keyword">const</span> struct iovec *iov,<span class="keyword">int</span> iovcnt);</span><br><span class="line">							Returns number of bytes written,<span class="keyword">or</span> <span class="number">-1</span> on error</span><br></pre></td></tr></table></figure>
<p>readv()实现了分散输入的功能：从文件描述符fd所指代的文件中读取一片连续的字节，然后将其分散放置于iov指定的缓冲区中。这一散置动作从iov[0]开始，一次填满每个缓冲区。</p>
<p>writev()将iov所指定的所有缓冲区中的数据拼接起来，然后以连续的字节序列写入文件描述符fd所指代的文件中。</p>
<h3 id="2-8截断文件：truncate-和ftruncate-系统调用"><a href="#2-8截断文件：truncate-和ftruncate-系统调用" class="headerlink" title="2.8截断文件：truncate()和ftruncate()系统调用"></a>2.8截断文件：truncate()和ftruncate()系统调用</h3><p>truncate()和ftruncate()将文件大小设置为length参数指定的参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">truncate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname,<span class="keyword">off_t</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ftruncate</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">off_t</span> length)</span></span>;</span><br><span class="line"></span><br><span class="line">											Both <span class="keyword">return</span> <span class="number">0</span> on success,<span class="keyword">or</span> <span class="number">-1</span> on error</span><br></pre></td></tr></table></figure>
<p>若文件当前长度大于参数length，调用将丢弃超出部分，若小于参数length，调用将在文件尾部添加一系列空字节或是一个文件空洞。</p>
<h3 id="2-9-创建临时文件"><a href="#2-9-创建临时文件" class="headerlink" title="2.9 创建临时文件"></a>2.9 创建临时文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkstemp</span><span class="params">(<span class="keyword">char</span> *tempplate)</span></span>;</span><br><span class="line"></span><br><span class="line">									Returns file descriptor on success,<span class="keyword">or</span> <span class="number">-1</span> on error</span><br></pre></td></tr></table></figure>
<p>基于调用者提供的模版，mkstemp()函数声称一个唯一文件名并打开该文件，返回一个可用于I/O调用的文件描述符。</p>
<p>模版参数采用路径名形式，其中最后6个字符必须为XXXXXX。这6个字符将被替换，以保证文件名的唯一性，且修改后的字符串将通过template参数传回。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">FILE *<span class="title">tmpfile</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">									<span class="keyword">return</span> file pointer on success,<span class="keyword">or</span> <span class="literal">NULL</span> on error</span><br></pre></td></tr></table></figure>
<p>tmpfile()函数执行成功，将返回一个文件流供stdio库函数使用。文件流关闭后将自动删除临时文件。</p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="3-1进程号和父进程号"><a href="#3-1进程号和父进程号" class="headerlink" title="3.1进程号和父进程号"></a>3.1进程号和父进程号</h3><p>返回调用进程的进程号</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> getpid(<span class="keyword">void</span>);</span><br><span class="line">     </span><br><span class="line">     						Always successfully returns peocess ID of caller</span><br></pre></td></tr></table></figure>
<p>每个进程都有一个创建自己的父进程，getppid()可以获取父进程的进程号。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pit_t</span> getppid(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line">			Always successfully returns peocess ID of parent of caller</span><br></pre></td></tr></table></figure>
<h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2></div><div class="tags"><a href="/tags/Linux/">Linux</a></div><div class="post-share"><div class="bdsharebuttonbox"><span style="float:left;line-height: 28px;height: 28px;font-size:16px;font-weight:blod">分享到：</span><a href="#" data-cmd="more" class="bds_more"></a><a href="#" data-cmd="mshare" title="分享到一键分享" class="bds_mshare"></a><a href="#" data-cmd="fbook" title="分享到Facebook" class="bds_fbook"></a><a href="#" data-cmd="twi" title="分享到Twitter" class="bds_twi"></a><a href="#" data-cmd="linkedin" title="分享到linkedin" class="bds_linkedin"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a></div></div><div class="post-nav"><a href="/2020/11/30/C-引用/" class="pre">C++ 引用</a><a href="/2020/11/09/Android-JNI函数动态注册/" class="next">Android JNI学习-函数动态注册</a></div><div id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC8zODA5Ny8xNDYyNw=="></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#系统调用"><span class="toc-text">系统调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1、文件I-O"><span class="toc-text">1、文件I/O</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1通用I-O"><span class="toc-text">1.1通用I/O</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2打开一个文件：open"><span class="toc-text">1.2打开一个文件：open()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3读取文件内容：read"><span class="toc-text">1.3读取文件内容：read()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4数据写入文件：write"><span class="toc-text">1.4数据写入文件：write()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5关闭文件：close"><span class="toc-text">1.5关闭文件：close()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6改变文件偏移量：lseek"><span class="toc-text">1.6改变文件偏移量：lseek()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7通用I-O模型以外的操作：ioctl"><span class="toc-text">1.7通用I/O模型以外的操作：ioctl()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2、深入探究文件I-O"><span class="toc-text">2、深入探究文件I/O</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-原子操作和竞争条件"><span class="toc-text">2.1 原子操作和竞争条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-文件控制操作：fcntl"><span class="toc-text">2.2 文件控制操作：fcntl()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-打开文件的状态标志"><span class="toc-text">2.3 打开文件的状态标志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-文件描述符和打开文件之间的关系"><span class="toc-text">2.4 文件描述符和打开文件之间的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5复制文件描述符"><span class="toc-text">2.5复制文件描述符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-在文件特定偏移量处的I-O：pread-和pwrite"><span class="toc-text">2.6 在文件特定偏移量处的I/O：pread()和pwrite()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-分散输入和集中输出-Scatter-Gather-I-O-readv-和writev"><span class="toc-text">2.7 分散输入和集中输出(Scatter-Gather I/O):readv()和writev()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8截断文件：truncate-和ftruncate-系统调用"><span class="toc-text">2.8截断文件：truncate()和ftruncate()系统调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-9-创建临时文件"><span class="toc-text">2.9 创建临时文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程"><span class="toc-text">进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1进程号和父进程号"><span class="toc-text">3.1进程号和父进程号</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内存分配"><span class="toc-text">内存分配</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/11/30/C-引用/">C++ 引用</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/11/11/Linux-UNIX系统编程手册读书笔记/">Linux_UNIX系统编程手册</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/11/09/Android-JNI函数动态注册/">Android JNI学习-函数动态注册</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/03/Android-理解Context/">Android 理解Context</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/20/FFmpeg将H264封装为MP4文件/">FFmpeg将H264封装为MP4文件</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/18/FFmpeg编码yuv转H264/">FFmpeg编码yuv转H264</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/07/Android7-1-Launcher3去除抽屉/">Android7.1 Launcher3去除抽屉</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/07/Android-添加自定义系统服务/">Android系统 添加自定义系统服务</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/30/Android系统定制笔记/">Android系统定制笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/14/FFmpeg滤镜Filter/">FFmpeg Filter</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android开发/">Android开发</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android系统/">Android系统</a><span class="category-list-count">20</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android音视频/">Android音视频</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/C-C/">C/C++</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/FFmpeg/">FFmpeg</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kotlin/">Kotlin</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux系统/">Linux系统</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Netty/">Netty</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OpenGL-ES-3-0/">OpenGL ES 3.0</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SDL2/">SDL2</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web/">Web</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/微信小程序/">微信小程序</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构与算法/">数据结构与算法</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络/">网络</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a><span class="category-list-count">3</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/源码/" style="font-size: 15px;">源码</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/JNI/" style="font-size: 15px;">JNI</a> <a href="/tags/NDK/" style="font-size: 15px;">NDK</a> <a href="/tags/Service/" style="font-size: 15px;">Service</a> <a href="/tags/Context/" style="font-size: 15px;">Context</a> <a href="/tags/Launcher3/" style="font-size: 15px;">Launcher3</a> <a href="/tags/ClassLoader/" style="font-size: 15px;">ClassLoader</a> <a href="/tags/BroadCast/" style="font-size: 15px;">BroadCast</a> <a href="/tags/原理/" style="font-size: 15px;">原理</a> <a href="/tags/CameraX/" style="font-size: 15px;">CameraX</a> <a href="/tags/Camera2/" style="font-size: 15px;">Camera2</a> <a href="/tags/MediaCodec/" style="font-size: 15px;">MediaCodec</a> <a href="/tags/音频/" style="font-size: 15px;">音频</a> <a href="/tags/OpenGL-ES/" style="font-size: 15px;">OpenGL ES</a> <a href="/tags/Camera/" style="font-size: 15px;">Camera</a> <a href="/tags/binder/" style="font-size: 15px;">binder</a> <a href="/tags/FFmpeg/" style="font-size: 15px;">FFmpeg</a> <a href="/tags/直播/" style="font-size: 15px;">直播</a> <a href="/tags/C/" style="font-size: 15px;">C++</a> <a href="/tags/C语言/" style="font-size: 15px;">C语言</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/多线程/" style="font-size: 15px;">多线程</a> <a href="/tags/系统/" style="font-size: 15px;">系统</a> <a href="/tags/音视频/" style="font-size: 15px;">音视频</a> <a href="/tags/SDL2/" style="font-size: 15px;">SDL2</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/系统调用/" style="font-size: 15px;">系统调用</a> <a href="/tags/内存/" style="font-size: 15px;">内存</a> <a href="/tags/GC/" style="font-size: 15px;">GC</a> <a href="/tags/同步/" style="font-size: 15px;">同步</a> <a href="/tags/JMM/" style="font-size: 15px;">JMM</a> <a href="/tags/AQS/" style="font-size: 15px;">AQS</a> <a href="/tags/LRU/" style="font-size: 15px;">LRU</a> <a href="/tags/中断/" style="font-size: 15px;">中断</a> <a href="/tags/Netty/" style="font-size: 15px;">Netty</a> <a href="/tags/Reactor/" style="font-size: 15px;">Reactor</a> <a href="/tags/高性能/" style="font-size: 15px;">高性能</a> <a href="/tags/TCP/" style="font-size: 15px;">TCP</a> <a href="/tags/微信小程序/" style="font-size: 15px;">微信小程序</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/交叉编译/" style="font-size: 15px;">交叉编译</a> <a href="/tags/Makefile/" style="font-size: 15px;">Makefile</a> <a href="/tags/编译时注解/" style="font-size: 15px;">编译时注解</a> <a href="/tags/KAPT/" style="font-size: 15px;">KAPT</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/UML/" style="font-size: 15px;">UML</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">九月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">八月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">七月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="http://gityuan.com/" title="Gityuan" target="_blank">Gityuan</a><ul></ul><a href="https://richardwrq.github.io/" title="Richard Wu" target="_blank">Richard Wu</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Baidu Site Haritası</a> |  <a href="/atom.xml">订阅</a> |  <a href="/about/">关于</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">刘伟.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","weixin","tsina","qzone","linkedin","fbook","twi","print","renren","sqq","evernotecn","bdysc","tqq","tqf","bdxc","kaixin001","tieba","douban","bdhome","thx","ibaidu","meilishuo","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","people","xinhua","mail","isohu","yaolan","wealink","ty","iguba","h163","copy"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"]}};with(document)0[(getElementsByTagName('head')[0]||head).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script><script>(function(d, s) {
  var j, e = d.getElementsByTagName('body')[0];
  if (typeof LivereTower === 'function') { return; }
  j = d.createElement(s);
  j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
  j.async = true;
  e.appendChild(j);
})(document, 'script');
</script></body></html>