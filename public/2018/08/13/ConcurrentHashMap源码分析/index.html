<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="本网站主要供个人学习记录使用，如有侵权请立即邮件联系"><meta name="keywords" content="Android, Java, Linux, 数据结构"><title>ConcurrentHashMap源码分析 | Programmer Liu</title><link rel="stylesheet" type="text/css" href="//fonts.neworld.org/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">ConcurrentHashMap源码分析</h1><a id="logo" href="/.">Programmer Liu</a><p class="description">一只有崇高理想的的程序猿</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Arama"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">ConcurrentHashMap源码分析</h1><div class="post-meta"><a href="/2018/08/13/ConcurrentHashMap源码分析/#comments" class="comment-count"></a><p><span class="date">Aug 13, 2018</span><span><a href="/categories/Java/" class="category">Java</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>HashMap、HashTable是JDK中提供的两种的容器，在平时开发中经常会使用到。但在并发编程中，HashMap可能会导致程序死循环，而HashTable就是在所有涉及对该哈希表操作的方法上都加上了synchronized关键字，进行加锁操作。这么做实现了线程安全，但是效率非常低。因此就有了ConcurrentHashMap。</p>
<h1 id="JDK1-7"><a href="#JDK1-7" class="headerlink" title="JDK1.7"></a>JDK1.7</h1><p>在JDK1.7中ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。</p>
<p><img src="/2018/08/13/ConcurrentHashMap源码分析/CHashMap1.png" alt=""></p>
<p>Segment是一个可重入锁，HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个SegMent数组，Segment的结构和HashMap类似，是一种数组和链表结构。一个Segment里包含了一个HashEntry数组，每个HashEntry是一个链表结构的元素，每个Segment守护着一个HashEntry数组里的元素，当对HashEntry的数据进行修改时，必须先获得与它对应的Segment锁。</p>
<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>先经过一次再散列，然后使用这个散列值通过散列运算定位到Segment，再通过散列算法定位到元素。get操作的高效之处在于get方法将要使用的共享变量都定义成volatile类型。</p>
<h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><p>当执行put方法插入数据时，根据key的hash值，在Segment数组中找到相应的位置，如果相应位置的Segment还未初始化，则通过CAS进行赋值，接着执行Segment对象的put方法通过加锁机制插入数据，实现如下：</p>
<p>线程A和线程B同时执行相同Segment对象的put方法</p>
<ol>
<li>线程A执行tryLock()方法成功获取锁，则把HashEntry对象插入到相应的位置；</li>
<li>线程B获取锁失败，则执行scanAndLockForPut()方法，在scanAndLockForPut方法中，会通过重复执行tryLock()方法尝试获取锁，在多处理器环境下，重复次数为64，单处理器重复次数为1，当执行tryLock()方法的次数超过上限时，则执行lock()方法挂起线程B；</li>
<li>当线程A执行完插入操作时，会通过unlock()方法释放锁，接着唤醒线程B继续执行；</li>
</ol>
<h3 id="size"><a href="#size" class="headerlink" title="size"></a>size</h3><p>Segment中的全局变量count是一个volatile变量。先尝试两次通过不锁住Segment的方式统计各个Segment大小，如果两次统计结果相同，则说明计算出的元素个数是准确的。如果两次结果不同，则给每个Segment加锁，在进行一次计算。</p>
<h1 id="JDK1-8"><a href="#JDK1-8" class="headerlink" title="JDK1.8"></a>JDK1.8</h1><p>在JDK1.8中已经抛弃了Segment分段锁机制，利用CAS+Synchronized来保证并发更新的安全，底层采用数组+链表+红黑树的存储结构。</p>
<p><img src="/2018/08/13/ConcurrentHashMap源码分析/CHashMap2.png" alt=""></p>
<h2 id="1、重要属性"><a href="#1、重要属性" class="headerlink" title="1、重要属性"></a>1、重要属性</h2><p>sizeCtl这个属性在ConcurrentHashMap中出镜率很高，因为它是一个控制标识符，在不同的地方有不同用途，而且它的取值不同，也代表不同的含义。</p>
<ul>
<li>负数代表正在进行初始化或扩容操作</li>
<li>-1代表正在初始化</li>
<li>-N 表示有N-1个线程正在进行扩容操作</li>
<li>正数或0代表hash表还没有被初始化，这个数值表示初始化或下一次进行扩容的大小，这一点类似于扩容阈值的概念。还后面可以看到，它的值始终是当前ConcurrentHashMap容量的0.75倍，这与loadfactor是对应的。</li>
</ul>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 盛装Node元素的数组 它的大小是2的整数次幂</span></span><br><span class="line"><span class="comment">   * Size is always a power of two. Accessed directly by iterators.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Table initialization and resizing control.  When negative, the</span></span><br><span class="line"><span class="comment">   * table is being initialized or resized: -1 for initialization,</span></span><br><span class="line"><span class="comment">   * else -(1 + the number of active resizing threads).  Otherwise,</span></span><br><span class="line"><span class="comment">   * when table is null, holds the initial table size to use upon</span></span><br><span class="line"><span class="comment">   * creation, or 0 for default. After initialization, holds the</span></span><br><span class="line"><span class="comment">   * next element count value upon which to resize the table.</span></span><br><span class="line"><span class="comment">   hash表初始化或扩容时的一个控制位标识量。</span></span><br><span class="line"><span class="comment">   负数代表正在进行初始化或扩容操作</span></span><br><span class="line"><span class="comment">   -1代表正在初始化</span></span><br><span class="line"><span class="comment">   -N 表示有N-1个线程正在进行扩容操作</span></span><br><span class="line"><span class="comment">   正数或0代表hash表还没有被初始化，这个数值表示初始化或下一次进行扩容的大小</span></span><br><span class="line"><span class="comment">   </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl; </span><br><span class="line">  <span class="comment">// 以下两个是用来控制扩容的时候 单线程进入的变量</span></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The number of bits used for generation stamp in sizeCtl.</span></span><br><span class="line"><span class="comment">   * Must be at least 6 for 32bit arrays.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> RESIZE_STAMP_BITS = <span class="number">16</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The bit shift for recording size stamp in sizeCtl.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESIZE_STAMP_SHIFT = <span class="number">32</span> - RESIZE_STAMP_BITS;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Encodings for Node hash fields. See above for explanation.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED     = -<span class="number">1</span>; <span class="comment">// hash值是-1，表示这是一个forwardNode节点</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEBIN   = -<span class="number">2</span>; <span class="comment">// hash值是-2  表示这时一个TreeBin节点</span></span><br></pre></td></tr></table></figure>
<h2 id="2、重要的类"><a href="#2、重要的类" class="headerlink" title="2、重要的类"></a>2、重要的类</h2><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>Node是最核心的内部类，它包装了key-value键值对，所有插入ConcurrentHashMap的数据都包装在这里面。它与HashMap中的定义很相似，但是但是有一些差别它对value和next属性设置了volatile同步锁(与JDK7的Segment相同)，它不允许调用setValue方法直接改变Node的value域，它增加了find方法辅助map.get()方法。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; &#123;</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V val;</span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中value和next都用volatile修饰，保证并发的可见性。</p>
<h3 id="TreeNode"><a href="#TreeNode" class="headerlink" title="TreeNode"></a>TreeNode</h3><p>树节点类，另外一个核心的数据结构。当链表长度过长的时候，会转换为TreeNode。但是与HashMap不相同的是，它并不是直接转换为红黑树，而是把这些结点包装成TreeNode放在TreeBin对象中，由TreeBin完成对红黑树的包装。而且TreeNode在ConcurrentHashMap集成自Node类，而并非HashMap中的集成自LinkedHashMap.Entry&lt;K,V&gt;类，也就是说TreeNode带有next指针，这样做的目的是方便基于TreeBin的访问。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Nodes for use in TreeBins</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    static <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode&lt;K</span>,<span class="title">V&gt;</span> <span class="keyword">extends</span> <span class="title">Node&lt;K</span>,<span class="title">V&gt;</span> </span>&#123;</span><br><span class="line">        <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">        <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; left;</span><br><span class="line">        <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; right;</span><br><span class="line">        <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">        boolean red;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span>(int hash, <span class="type">K</span> key, <span class="type">V</span> <span class="keyword">val</span>, <span class="type">Node</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; next,</span><br><span class="line">                 <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; parent) &#123;</span><br><span class="line">            <span class="keyword">super</span>(hash, key, <span class="keyword">val</span>, next);</span><br><span class="line">            <span class="keyword">this</span>.parent = parent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Node</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; find(int h, <span class="type">Object</span> k) &#123;</span><br><span class="line">            <span class="keyword">return</span> findTreeNode(h, k, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Returns the TreeNode (or null if not found) for the given key</span></span><br><span class="line"><span class="comment">         * starting at given root.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; findTreeNode(int h, <span class="type">Object</span> k, <span class="type">Class</span>&lt;?&gt; kc) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; p = <span class="keyword">this</span>;</span><br><span class="line">                do  &#123;</span><br><span class="line">                    int ph, dir; <span class="type">K</span> pk; <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; q;</span><br><span class="line">                    <span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; pl = p.left, pr = p.right;</span><br><span class="line">                    <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                        p = pl;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                        p = pr;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (pk != <span class="literal">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                        <span class="keyword">return</span> p;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (pl == <span class="literal">null</span>)</span><br><span class="line">                        p = pr;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="literal">null</span>)</span><br><span class="line">                        p = pl;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> ((kc != <span class="literal">null</span> ||</span><br><span class="line">                              (kc = comparableClassFor(k)) != <span class="literal">null</span>) &amp;&amp;</span><br><span class="line">                             (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>)</span><br><span class="line">                        p = (dir &lt; <span class="number">0</span>) ? pl : pr;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> ((q = pr.findTreeNode(h, k, kc)) != <span class="literal">null</span>)</span><br><span class="line">                        <span class="keyword">return</span> q;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        p = pl;</span><br><span class="line">                &#125; <span class="keyword">while</span> (p != <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="TreeBin"><a href="#TreeBin" class="headerlink" title="TreeBin"></a>TreeBin</h3><p>这个类并不负责包装用户的key、value信息，而是包装的很多TreeNode节点。它代替了TreeNode的根节点，也就是说在实际的ConcurrentHashMap“数组”中，存放的是TreeBin对象，而不是TreeNode对象，这是与HashMap的区别。另外这个类还带有了读写锁。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * TreeNodes used at the heads of bins. TreeBins do not hold user</span></span><br><span class="line"><span class="comment">     * keys or values, but instead point to list of TreeNodes and</span></span><br><span class="line"><span class="comment">     * their root. They also maintain a parasitic read-write lock</span></span><br><span class="line"><span class="comment">     * forcing writers (who hold bin lock) to wait for readers (who do</span></span><br><span class="line"><span class="comment">     * not) to complete before tree restructuring operations.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeBin</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; &#123;</span></span><br><span class="line">        TreeNode&lt;K,V&gt; root;</span><br><span class="line">        <span class="keyword">volatile</span> TreeNode&lt;K,V&gt; first;</span><br><span class="line">        <span class="keyword">volatile</span> Thread waiter;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> lockState;</span><br><span class="line">        <span class="comment">// values for lockState</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WRITER = <span class="number">1</span>; <span class="comment">// set while holding write lock</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WAITER = <span class="number">2</span>; <span class="comment">// set when waiting for write lock</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> READER = <span class="number">4</span>; <span class="comment">// increment value for setting read lock</span></span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ForwardingNode"><a href="#ForwardingNode" class="headerlink" title="ForwardingNode"></a>ForwardingNode</h3><p>一个用于连接两个table的节点类。它包含一个nextTable指针，用于指向下一张表。而且这个节点的key value next指针全部为null，它的hash值为-1. 这里面定义的find的方法是从nextTable里进行查询节点，而不是以自身为头节点进行查找。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Encapsulates traversal for methods such as containsValue; also</span></span><br><span class="line"><span class="comment">    * serves as a base class for other iterators and spliterators.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * Method advance visits once each still-valid node that was</span></span><br><span class="line"><span class="comment">    * reachable upon iterator construction. It might miss some that</span></span><br><span class="line"><span class="comment">    * were added to a bin after the bin was visited, which is OK wrt</span></span><br><span class="line"><span class="comment">    * consistency guarantees. Maintaining this property in the face</span></span><br><span class="line"><span class="comment">    * of possible ongoing resizes requires a fair amount of</span></span><br><span class="line"><span class="comment">    * bookkeeping state that is difficult to optimize away amidst</span></span><br><span class="line"><span class="comment">    * volatile accesses.  Even so, traversal maintains reasonable</span></span><br><span class="line"><span class="comment">    * throughput.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * Normally, iteration proceeds bin-by-bin traversing lists.</span></span><br><span class="line"><span class="comment">    * However, if the table has been resized, then all future steps</span></span><br><span class="line"><span class="comment">    * must traverse both the bin at the current index as well as at</span></span><br><span class="line"><span class="comment">    * (index + baseSize); and so on for further resizings. To</span></span><br><span class="line"><span class="comment">    * paranoically cope with potential sharing by users of iterators</span></span><br><span class="line"><span class="comment">    * across threads, iteration terminates if a bounds checks fails</span></span><br><span class="line"><span class="comment">    * for a table read.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Traverser</span>&lt;K,V&gt; &#123;</span></span><br><span class="line">       Node&lt;K,V&gt;[] tab;        <span class="comment">// current table; updated if resized</span></span><br><span class="line">       Node&lt;K,V&gt; next;         <span class="comment">// the next entry to use</span></span><br><span class="line">       TableStack&lt;K,V&gt; <span class="built_in">stack</span>, spare; <span class="comment">// to save/restore on ForwardingNodes</span></span><br><span class="line">       <span class="keyword">int</span> index;              <span class="comment">// index of bin to use next</span></span><br><span class="line">       <span class="keyword">int</span> baseIndex;          <span class="comment">// current index of initial table</span></span><br><span class="line">       <span class="keyword">int</span> baseLimit;          <span class="comment">// index bound for initial table</span></span><br><span class="line">       final <span class="keyword">int</span> baseSize;     <span class="comment">// initial table size</span></span><br><span class="line">       ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3、核心方法"><a href="#3、核心方法" class="headerlink" title="3、核心方法"></a>3、核心方法</h2><p>ConcurrentHashMap定义了三个原子操作，用于对指定位置的节点进行操作。正是这些原子操作保证了ConcurrentHashMap的线程安全。</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  //获得在i位置上的<span class="keyword">Node</span><span class="title">节点</span></span><br><span class="line"><span class="title">  static</span> final <span class="tag">&lt;K,V&gt;</span> <span class="keyword">Node</span><span class="title">&lt;K</span>,V&gt; tabAt(<span class="keyword">Node</span><span class="title">&lt;K</span>,V&gt;[] tab, int i) &#123;</span><br><span class="line">      return (<span class="keyword">Node</span><span class="title">&lt;K</span>,V&gt;)U.getObjectVolatile(tab, ((long)i <span class="tag">&lt;&lt; ASHIFT) + ABASE);</span></span><br><span class="line"><span class="tag">  &#125;</span></span><br><span class="line"><span class="tag">//利用CAS算法设置i位置上的Node节点。之所以能实现并发是因为他指定了原来这个节点的值是多少</span></span><br><span class="line"><span class="tag">   static final &lt;K,V&gt;</span> boolean casTabAt(<span class="keyword">Node</span><span class="title">&lt;K</span>,V&gt;[] tab, int i,</span><br><span class="line">                                      <span class="keyword">Node</span><span class="title">&lt;K</span>,V&gt; c, <span class="keyword">Node</span><span class="title">&lt;K</span>,V&gt; v) &#123;</span><br><span class="line">      return U.compareAndSwapObject(tab, ((long)i <span class="tag">&lt;&lt; ASHIFT) + ABASE, c, v);</span></span><br><span class="line"><span class="tag">  &#125;</span></span><br><span class="line"><span class="tag">//利用volatile方法设置节点位置的值</span></span><br><span class="line"><span class="tag">  static final &lt;K,V&gt;</span> void setTabAt(<span class="keyword">Node</span><span class="title">&lt;K</span>,V&gt;[] tab, int i, <span class="keyword">Node</span><span class="title">&lt;K</span>,V&gt; v) &#123;</span><br><span class="line">      U.putObjectVolatile(tab, ((long)i <span class="tag">&lt;&lt; ASHIFT) + ABASE, v);</span></span><br><span class="line"><span class="tag">  &#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="3-1-初始化"><a href="#3-1-初始化" class="headerlink" title="3.1 初始化"></a>3.1 初始化</h2><p>对于ConcurrentHashMap来说，调用它的构造方法仅仅是设置了一些参数而已。而整个table的初始化是在向ConcurrentHashMap中插入元素的时候发生的。如调用put、computeIfAbsent、compute、merge等方法的时候，调用时机是检查table==null。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Initializes table, using the size recorded in sizeCtl.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   private final Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">       Node&lt;K,V&gt;[] <span class="keyword">tab</span>; int <span class="keyword">sc</span>;</span><br><span class="line">       <span class="keyword">while</span> ((<span class="keyword">tab</span> = <span class="keyword">table</span>) == null || <span class="keyword">tab</span>.length == 0) &#123;</span><br><span class="line">           <span class="comment">//sizeCtl表示有其他线程正在进行初始化操作，把线程挂起。对于table的初始化工作，只能有一个线程在进行。</span></span><br><span class="line">           <span class="keyword">if</span> ((<span class="keyword">sc</span> = sizeCtl) &lt; 0)</span><br><span class="line">               Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">U</span>.compareAndSwapInt(this, SIZECTL, <span class="keyword">sc</span>, -1)) &#123;<span class="comment">//利用CAS方法把sizectl的值置为-1 表示本线程正在进行初始化</span></span><br><span class="line">               try &#123;</span><br><span class="line">                   <span class="keyword">if</span> ((<span class="keyword">tab</span> = <span class="keyword">table</span>) == null || <span class="keyword">tab</span>.length == 0) &#123;</span><br><span class="line">                       int <span class="keyword">n</span> = (<span class="keyword">sc</span> &gt; 0) ? <span class="keyword">sc</span> : DEFAULT_CAPACITY;</span><br><span class="line">                       @SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line">                       Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[<span class="keyword">n</span>];</span><br><span class="line">                       <span class="keyword">table</span> = <span class="keyword">tab</span> = nt;</span><br><span class="line">                       <span class="keyword">sc</span> = <span class="keyword">n</span> - (<span class="keyword">n</span> &gt;&gt;&gt; 2); <span class="comment">//相当于0.75*n 设置一个扩容的阈值</span></span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; finally &#123;</span><br><span class="line">                   sizeCtl = <span class="keyword">sc</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">tab</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-2-扩容"><a href="#3-2-扩容" class="headerlink" title="3.2 扩容"></a>3.2 扩容</h2><ol>
<li><p>如果新增节点之后，所在链表的元素个数达到了阈值 8，则会调用treeifyBin方法把链表转换成红黑树,不过在结构转换之前，会对数组长度进行判断,如果数组长度n小于阈值MIN_TREEIFY_CAPACITY，默认是64，则会调用tryPresize方法把数组长度扩大到原来的两倍，并触发transfer方法，重新调整节点的位置。</p>
</li>
<li><p>新增节点之后，会调用addCount方法记录元素个数，并检查是否需要进行扩容，当数组元素个数达到阈值时，会触发transfer方法，重新调整节点的位置。</p>
</li>
</ol>
<h3 id="transfer实现"><a href="#transfer实现" class="headerlink" title="transfer实现"></a>transfer实现</h3><p>整个扩容操作分为两个部分：</p>
<ol>
<li><p>第一部分是构建一个nextTable,它的容量是原来的两倍，这个操作是单线程完成的。这个单线程的保证是通过RESIZE_STAMP_SHIFT这个常量经过一次运算来保证的；</p>
</li>
<li><p>第二个部分就是将原来table中的元素复制到nextTable中，这里允许多线程进行操作。</p>
</li>
</ol>
<p>先来看一下单线程是如何完成的，它的大体思想就是遍历、复制的过程。首先根据运算得到需要遍历的次数i，然后利用tabAt方法获得i位置的元素：</p>
<ol>
<li><p>如果这个位置为空，就在原table中的i位置放入forwardNode节点，这个也是触发并发扩容的关键点；</p>
</li>
<li><p>如果这个位置是Node节点（fh&gt;=0），如果它是一个链表的头节点，就构造一个反序链表，把他们分别放在nextTable的i和i+n的位置上</p>
</li>
<li><p>如果这个位置是TreeBin节点（fh&lt;0），也做一个反序处理，并且判断是否需要untreefi，把处理的结果分别放在nextTable的i和i+n的位置上</p>
</li>
<li><p>遍历过所有的节点以后就完成了复制工作，这时让nextTable作为新的table，并且更新sizeCtl为新容量的0.75倍 ，完成扩容。</p>
</li>
</ol>
<p>再看一下多线程是如何完成的：</p>
<p>如果遍历到的节点是forward节点，就向后继续遍历，再加上给节点上锁的机制，就完成了多线程的控制。多线程遍历节点，处理了一个节点，就把对应点的值set为forward，另一个线程看到forward，就向后遍历。这样交叉就完成了复制工作。而且还很好的解决了线程安全的问题。</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Moves and/or copies the nodes in each bin to new table. See</span></span><br><span class="line"><span class="comment"> * above for explanation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) &#123;</span><br><span class="line">    int <span class="attr">n</span> = tab.length, stride;</span><br><span class="line">    // 将 length / <span class="number">8</span> 然后除以 CPU核心数。如果得到的结果小于 <span class="number">16</span>，那么就使用 <span class="number">16</span>。</span><br><span class="line">    // 这里的目的是让每个 CPU 处理的桶一样多，避免出现转移任务不均匀的现象，如果桶较少的话，默认一个 CPU（一个线程）处理 <span class="number">16</span> 个桶</span><br><span class="line">    <span class="keyword">if</span> ((<span class="attr">stride</span> = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        <span class="attr">stride</span> = MIN_TRANSFER_STRIDE; // subdivide range</span><br><span class="line">    <span class="keyword">if</span> (<span class="attr">nextTab</span> == <span class="literal">null</span>) &#123;            // initiating</span><br><span class="line">        try &#123;</span><br><span class="line">            @SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line">            Node&lt;K,V&gt;[] <span class="attr">nt</span> = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];//构造一个nextTable对象 它的容量是原来的两倍</span><br><span class="line">            <span class="attr">nextTab</span> = nt;</span><br><span class="line">        &#125; catch (Throwable ex) &#123;      // try to cope <span class="keyword">with</span> OOME</span><br><span class="line">            <span class="attr">sizeCtl</span> = Integer.MAX_VALUE;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attr">nextTable</span> = nextTab;</span><br><span class="line">        <span class="attr">transferIndex</span> = n;</span><br><span class="line">    &#125;</span><br><span class="line">    int <span class="attr">nextn</span> = nextTab.length;</span><br><span class="line">    ForwardingNode&lt;K,V&gt; <span class="attr">fwd</span> = new ForwardingNode&lt;K,V&gt;(nextTab);//构造一个连节点指针 用于标志位</span><br><span class="line">    boolean <span class="attr">advance</span> = <span class="literal">true</span>;//并发扩容的关键属性 如果等于<span class="literal">true</span> 说明这个节点已经处理过</span><br><span class="line">    boolean <span class="attr">finishing</span> = <span class="literal">false</span>; // to ensure sweep before committing nextTab</span><br><span class="line">    for (int <span class="attr">i</span> = <span class="number">0</span>, <span class="attr">bound</span> = <span class="number">0</span>;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; int fh;</span><br><span class="line">        //这个while循环体的作用就是在控制i--  通过i--可以依次遍历原hash表中的节点</span><br><span class="line">        while (advance) &#123;</span><br><span class="line">            int nextIndex, nextBound;</span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                <span class="attr">advance</span> = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="attr">nextIndex</span> = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="attr">i</span> = -<span class="number">1</span>;</span><br><span class="line">                <span class="attr">advance</span> = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                     (this, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      <span class="attr">nextBound</span> = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="attr">bound</span> = nextBound;</span><br><span class="line">                <span class="attr">i</span> = nextIndex - <span class="number">1</span>;</span><br><span class="line">                <span class="attr">advance</span> = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            int sc;</span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                //如果所有的节点都已经完成复制工作  就把nextTable赋值给table 清空临时对象nextTable</span><br><span class="line">                <span class="attr">nextTable</span> = <span class="literal">null</span>;</span><br><span class="line">                <span class="attr">table</span> = nextTab;</span><br><span class="line">                <span class="attr">sizeCtl</span> = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);//扩容阈值设置为原来容量的<span class="number">1.5</span>倍  依然相当于现在容量的<span class="number">0.75</span>倍</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            //利用CAS方法更新这个扩容阈值，在这里面sizectl值减一，说明新加入一个线程参与到扩容操作</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(this, SIZECTL, <span class="attr">sc</span> = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    return;</span><br><span class="line">                <span class="attr">finishing</span> = <span class="attr">advance</span> = <span class="literal">true</span>;</span><br><span class="line">                <span class="attr">i</span> = n; // recheck before commit</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果遍历到的节点为空 则放入ForwardingNode指针</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="attr">f</span> = tabAt(tab, i)) == <span class="literal">null</span>)</span><br><span class="line">            <span class="attr">advance</span> = casTabAt(tab, i, <span class="literal">null</span>, fwd);</span><br><span class="line">        //如果遍历到ForwardingNode节点  说明这个点已经被处理过了 直接跳过  这里是控制并发扩容的核心</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="attr">fh</span> = f.hash) == MOVED)</span><br><span class="line">            <span class="attr">advance</span> = <span class="literal">true</span>; // already processed</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            //节点上锁</span><br><span class="line">            synchronized (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                    //如果fh&gt;=<span class="number">0</span> 证明这是一个Node节点</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        int <span class="attr">runBit</span> = fh &amp; n;</span><br><span class="line">                        //以下的部分在完成的工作是构造两个链表  一个是原链表  另一个是原链表的反序排列</span><br><span class="line">                        Node&lt;K,V&gt; <span class="attr">lastRun</span> = f;</span><br><span class="line">                        for (Node&lt;K,V&gt; <span class="attr">p</span> = f.next; p != <span class="literal">null</span>; <span class="attr">p</span> = p.next) &#123;</span><br><span class="line">                            int <span class="attr">b</span> = p.hash &amp; n;</span><br><span class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                <span class="attr">runBit</span> = b;</span><br><span class="line">                                <span class="attr">lastRun</span> = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="attr">runBit</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="attr">ln</span> = lastRun;</span><br><span class="line">                            <span class="attr">hn</span> = <span class="literal">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="attr">hn</span> = lastRun;</span><br><span class="line">                            <span class="attr">ln</span> = <span class="literal">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        for (Node&lt;K,V&gt; <span class="attr">p</span> = f; p != lastRun; <span class="attr">p</span> = p.next) &#123;</span><br><span class="line">                            int <span class="attr">ph</span> = p.hash; K <span class="attr">pk</span> = p.key; V <span class="attr">pv</span> = p.val;</span><br><span class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                <span class="attr">ln</span> = new Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                <span class="attr">hn</span> = new Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line">                        //在nextTable的i位置上插入一个链表</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        //在nextTable的i+n的位置上插入另一个链表</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        //在table的i位置上插入forwardNode节点  表示已经处理过该节点</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        //设置advance为<span class="literal">true</span> 返回到上面的while循环中 就可以执行i--操作</span><br><span class="line">                        <span class="attr">advance</span> = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //对TreeBin对象进行处理  与上面的过程类似</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f instanceof TreeBin) &#123;</span><br><span class="line">                        TreeBin&lt;K,V&gt; <span class="attr">t</span> = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; <span class="attr">lo</span> = <span class="literal">null</span>, <span class="attr">loTail</span> = <span class="literal">null</span>;</span><br><span class="line">                        TreeNode&lt;K,V&gt; <span class="attr">hi</span> = <span class="literal">null</span>, <span class="attr">hiTail</span> = <span class="literal">null</span>;</span><br><span class="line">                        int <span class="attr">lc</span> = <span class="number">0</span>, <span class="attr">hc</span> = <span class="number">0</span>;</span><br><span class="line">                        //构造正序和反序两个链表</span><br><span class="line">                        for (Node&lt;K,V&gt; <span class="attr">e</span> = t.first; e != <span class="literal">null</span>; <span class="attr">e</span> = e.next) &#123;</span><br><span class="line">                            int <span class="attr">h</span> = e.hash;</span><br><span class="line">                            TreeNode&lt;K,V&gt; <span class="attr">p</span> = new TreeNode&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">                            <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.<span class="attr">prev</span> = loTail) == <span class="literal">null</span>)</span><br><span class="line">                                    <span class="attr">lo</span> = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.<span class="attr">next</span> = p;</span><br><span class="line">                                <span class="attr">loTail</span> = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.<span class="attr">prev</span> = hiTail) == <span class="literal">null</span>)</span><br><span class="line">                                    <span class="attr">hi</span> = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.<span class="attr">next</span> = p;</span><br><span class="line">                                <span class="attr">hiTail</span> = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        //如果扩容后已经不再需要tree的结构 反向转换为链表结构</span><br><span class="line">                        <span class="attr">ln</span> = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                            (hc != <span class="number">0</span>) ? new TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        <span class="attr">hn</span> = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                            (lc != <span class="number">0</span>) ? new TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                        //在nextTable的i位置上插入一个链表  </span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        //在nextTable的i+n的位置上插入另一个链表</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        //在table的i位置上插入forwardNode节点  表示已经处理过该节点</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        //设置advance为<span class="literal">true</span> 返回到上面的while循环中 就可以执行i--操作</span><br><span class="line">                        <span class="attr">advance</span> = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-3-put"><a href="#3-3-put" class="headerlink" title="3.3 put"></a>3.3 put</h2><p>这个put方法依然沿用HashMap的put方法的思想，根据hash值计算这个新插入的点在table中的位置i，如果i位置是空的，直接放进去，否则进行判断，如果i位置是树节点，按照树的方式插入新的节点，否则把i插入到链表的末尾。ConcurrentHashMap中依然沿用这个思想，有一个最重要的不同点就是ConcurrentHashMap不允许key或value为null值。另外由于涉及到多线程，put方法就要复杂一点。在多线程中可能有以下两个情况:</p>
<ol>
<li><p>如果一个或多个线程正在对ConcurrentHashMap进行扩容操作，当前线程也要进入扩容的操作中。这个扩容的操作之所以能被检测到，是因为transfer方法中在空结点上插入forward节点，如果检测到需要插入的位置被forward节点占有，就帮助进行扩容；</p>
</li>
<li><p>如果检测到要插入的节点是非空且不是forward节点，就对这个节点加锁，这样就保证了线程安全。尽管这个有一些影响效率，但是还是会比hashTable的synchronized要好得多。‘</p>
</li>
</ol>
<p>整体流程就是首先定义不允许key或value为null的情况放入  对于每一个放入的值，首先利用spread方法对key的hashcode进行一次hash计算，由此来确定这个值在table中的位置。</p>
<p>如果这个位置是空的，那么直接放入，而且不需要加锁操作。</p>
<p> 如果这个位置存在结点，说明发生了hash碰撞，首先判断这个节点的类型。如果是链表节点（fh&gt;0）,则得到的结点就是hash值相同的节点组成的链表的头节点。需要依次向后遍历确定这个新加入的值所在位置。如果遇到hash值与key值都与新加入节点是一致的情况，则只需要更新value值即可。否则依次向后遍历，直到链表尾插入这个结点。如果加入这个节点以后链表长度大于8，就把这个链表转换成红黑树。如果这个节点的类型已经是树节点的话，直接调用树节点的插入方法进行插入新的值。</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Maps the specified key to the specified value in this table.</span></span><br><span class="line"><span class="comment">   * Neither the key nor the value can be null.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;The value can be retrieved by calling the &#123;@code get&#125; method</span></span><br><span class="line"><span class="comment">   * with a key that is equal to the original key.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @param key key with which the specified value is to be associated</span></span><br><span class="line"><span class="comment">   * @param value value to be associated with the specified key</span></span><br><span class="line"><span class="comment">   * @return the previous value associated with &#123;@code key&#125;, or</span></span><br><span class="line"><span class="comment">   *         &#123;@code null&#125; if there was no mapping for &#123;@code key&#125;</span></span><br><span class="line"><span class="comment">   * @throws NullPointerException if the specified key or value is null</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  public V put(K <span class="built_in">key</span>, V value) &#123;</span><br><span class="line">      <span class="keyword">return</span> putVal(<span class="built_in">key</span>, value, false);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line">  final V putVal(K <span class="built_in">key</span>, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">key</span> == <span class="built_in">null</span> || value == <span class="built_in">null</span>) throw <span class="keyword">new</span> NullPointerException();</span><br><span class="line">      int hash = spread(<span class="built_in">key</span>.hashCode());</span><br><span class="line">      int binCount = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">//死循环 何时插入成功 何时跳出</span></span><br><span class="line">      <span class="keyword">for</span> (Node&lt;K,V&gt;[] <span class="built_in">tab</span> = table;;) &#123;</span><br><span class="line">          Node&lt;K,V&gt; f; int n, i, fh;</span><br><span class="line">          <span class="comment">//如果table为空的话，初始化table</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">tab</span> == <span class="built_in">null</span> || (n = <span class="built_in">tab</span>.length) == <span class="number">0</span>)</span><br><span class="line">              <span class="built_in">tab</span> = initTable();</span><br><span class="line">          <span class="comment">//根据hash值计算出在table里面的位置 </span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(<span class="built_in">tab</span>, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="built_in">null</span>) &#123;</span><br><span class="line">              <span class="comment">//如果这个位置没有值 ，直接放进去，不需要加锁</span></span><br><span class="line">              <span class="keyword">if</span> (casTabAt(<span class="built_in">tab</span>, i, <span class="built_in">null</span>,</span><br><span class="line">                           <span class="keyword">new</span> Node&lt;K,V&gt;(hash, <span class="built_in">key</span>, value, <span class="built_in">null</span>)))</span><br><span class="line">                  <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//当遇到表连接点时，需要进行整合表的操作</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">              <span class="built_in">tab</span> = helpTransfer(<span class="built_in">tab</span>, f);</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">              V oldVal = <span class="built_in">null</span>;</span><br><span class="line">              <span class="comment">//结点上锁  这里的结点可以理解为hash值相同组成的链表的头结点</span></span><br><span class="line">              synchronized (f) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (tabAt(<span class="built_in">tab</span>, i) == f) &#123;</span><br><span class="line">                      <span class="comment">//fh&gt;0 说明这个节点是一个链表的节点 不是树的节点</span></span><br><span class="line">                      <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                          binCount = <span class="number">1</span>;</span><br><span class="line">                          <span class="comment">//在这里遍历链表所有的结点</span></span><br><span class="line">                          <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                              K ek;</span><br><span class="line">                              <span class="comment">//如果hash值和key值相同  则修改对应结点的value值</span></span><br><span class="line">                              <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                  ((ek = e.<span class="built_in">key</span>) == <span class="built_in">key</span> ||</span><br><span class="line">                                   (ek != <span class="built_in">null</span> &amp;&amp; <span class="built_in">key</span>.equals(ek)))) &#123;</span><br><span class="line">                                  oldVal = e.val;</span><br><span class="line">                                  <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                      e.val = value;</span><br><span class="line">                                  <span class="keyword">break</span>;</span><br><span class="line">                              &#125;</span><br><span class="line">                              Node&lt;K,V&gt; pred = e;</span><br><span class="line">                              <span class="comment">//如果遍历到了最后一个结点，那么就证明新的节点需要插入 就把它插入在链表尾部</span></span><br><span class="line">                              <span class="keyword">if</span> ((e = e.next) == <span class="built_in">null</span>) &#123;</span><br><span class="line">                                  pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, <span class="built_in">key</span>,</span><br><span class="line">                                                            value, <span class="built_in">null</span>);</span><br><span class="line">                                  <span class="keyword">break</span>;</span><br><span class="line">                              &#125;</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                      <span class="comment">//如果这个节点是树节点，就按照树的方式插入值</span></span><br><span class="line">                      <span class="keyword">else</span> <span class="keyword">if</span> (f instanceof TreeBin) &#123;</span><br><span class="line">                          Node&lt;K,V&gt; p;</span><br><span class="line">                          binCount = <span class="number">2</span>;</span><br><span class="line">                          <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, <span class="built_in">key</span>,</span><br><span class="line">                                                         value)) != <span class="built_in">null</span>) &#123;</span><br><span class="line">                              oldVal = p.val;</span><br><span class="line">                              <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                  p.val = value;</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                  <span class="comment">//如果链表长度已经达到临界值8 就需要把链表转换为树结构</span></span><br><span class="line">                  <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                      treeifyBin(<span class="built_in">tab</span>, i);</span><br><span class="line">                  <span class="keyword">if</span> (oldVal != <span class="built_in">null</span>)</span><br><span class="line">                      <span class="keyword">return</span> oldVal;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//将当前ConcurrentHashMap的元素数量+1</span></span><br><span class="line">      addCount(<span class="number">1</span>L, binCount);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>我们可以发现JDK8中的实现也是锁分离的思想，只是锁住的是一个Node，而不是JDK7中的Segment，而锁住Node之前的操作是无锁的并且也是线程安全的，建立在之前提到的3个原子操作上。</p>
<h2 id="3-4-get"><a href="#3-4-get" class="headerlink" title="3.4 get"></a>3.4 get</h2><p>get方法比较简单，给定一个key来确定value的时候，必须满足两个条件  key相同  hash值相同，对于节点可能在链表或树上的情况，需要分别去查找。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="built_in">get</span>(<span class="keyword">Object</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="built_in">int</span> n, eh; K ek;</span><br><span class="line">        <span class="comment">//计算hash值</span></span><br><span class="line">        <span class="built_in">int</span> h = spread(<span class="built_in">key</span>.hashCode());</span><br><span class="line">        <span class="comment">//根据hash值确定节点位置</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果搜索到的节点key与传入的key相同且不为null,直接返回这个节点	</span></span><br><span class="line">            <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((ek = e.<span class="built_in">key</span>) == <span class="built_in">key</span> || (ek != <span class="keyword">null</span> &amp;&amp; <span class="built_in">key</span>.equals(ek)))</span><br><span class="line">                    <span class="keyword">return</span> e.val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果eh&lt;0 说明这个节点在树上 直接寻找</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> (p = e.find(h, <span class="built_in">key</span>)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">             <span class="comment">//否则遍历链表 找到对应的值并返回</span></span><br><span class="line">            <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                    ((ek = e.<span class="built_in">key</span>) == <span class="built_in">key</span> || (ek != <span class="keyword">null</span> &amp;&amp; <span class="built_in">key</span>.equals(ek))))</span><br><span class="line">                    <span class="keyword">return</span> e.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><div class="tags"><a href="/tags/Java/">Java</a><a href="/tags/多线程/">多线程</a><a href="/tags/源码/">源码</a></div><div class="post-share"><div class="bdsharebuttonbox"><span style="float:left;line-height: 28px;height: 28px;font-size:16px;font-weight:blod">分享到：</span><a href="#" data-cmd="more" class="bds_more"></a><a href="#" data-cmd="mshare" title="分享到一键分享" class="bds_mshare"></a><a href="#" data-cmd="fbook" title="分享到Facebook" class="bds_fbook"></a><a href="#" data-cmd="twi" title="分享到Twitter" class="bds_twi"></a><a href="#" data-cmd="linkedin" title="分享到linkedin" class="bds_linkedin"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a></div></div><div class="post-nav"><a href="/2018/08/15/Java动态代理/" class="pre">Java动态代理</a><a href="/2018/08/13/ThreadLocal解析/" class="next">ThreadLocal解析</a></div><div id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC8zODA5Ny8xNDYyNw=="></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JDK1-7"><span class="toc-text">JDK1.7</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#get"><span class="toc-text">get</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#put"><span class="toc-text">put</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#size"><span class="toc-text">size</span></a></li></ol></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#JDK1-8"><span class="toc-text">JDK1.8</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1、重要属性"><span class="toc-text">1、重要属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2、重要的类"><span class="toc-text">2、重要的类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Node"><span class="toc-text">Node</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TreeNode"><span class="toc-text">TreeNode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TreeBin"><span class="toc-text">TreeBin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ForwardingNode"><span class="toc-text">ForwardingNode</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3、核心方法"><span class="toc-text">3、核心方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-初始化"><span class="toc-text">3.1 初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-扩容"><span class="toc-text">3.2 扩容</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#transfer实现"><span class="toc-text">transfer实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-put"><span class="toc-text">3.3 put</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-get"><span class="toc-text">3.4 get</span></a></li></ol></li></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/11/23/FFmpeg常用结构体、方法简介/">FFmpeg常用结构体、方法简介</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/23/FFmpeg实现简单直播系统/">FFmpeg实现简单直播系统</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/22/FFmpeg常用命令/">FFmpeg常用命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/21/Mac下FFmpeg的下载-编译和安装/">FFmpeg的下载,编译和安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/19/音视频基础概念/">音视频基础概念</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/28/Netty学习-一/">Netty学习(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/24/Java内存分配及GC回收/">Java内存分配及GC回收</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/22/Android中的ClassLoader简析/">Android中的ClassLoader简析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/22/Java中的ClassLoader简析/">Java中的ClassLoader简析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/20/LinkedHashMap和LRU/">LinkedHashMap和LRU</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android系统/">Android系统</a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/C-C/">C/C++</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kotlin/">Kotlin</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux系统/">Linux系统</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Netty/">Netty</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web/">Web</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络/">网络</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/音视频/">音视频</a><span class="category-list-count">5</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/FFmpeg/" style="font-size: 15px;">FFmpeg</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/JNI/" style="font-size: 15px;">JNI</a> <a href="/tags/NDK/" style="font-size: 15px;">NDK</a> <a href="/tags/ClassLoader/" style="font-size: 15px;">ClassLoader</a> <a href="/tags/BroadCast/" style="font-size: 15px;">BroadCast</a> <a href="/tags/原理/" style="font-size: 15px;">原理</a> <a href="/tags/binder/" style="font-size: 15px;">binder</a> <a href="/tags/C-C/" style="font-size: 15px;">C/C++</a> <a href="/tags/指针/" style="font-size: 15px;">指针</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/多线程/" style="font-size: 15px;">多线程</a> <a href="/tags/源码/" style="font-size: 15px;">源码</a> <a href="/tags/音视频/" style="font-size: 15px;">音视频</a> <a href="/tags/系统/" style="font-size: 15px;">系统</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/系统调用/" style="font-size: 15px;">系统调用</a> <a href="/tags/内存/" style="font-size: 15px;">内存</a> <a href="/tags/GC/" style="font-size: 15px;">GC</a> <a href="/tags/同步/" style="font-size: 15px;">同步</a> <a href="/tags/JMM/" style="font-size: 15px;">JMM</a> <a href="/tags/AQS/" style="font-size: 15px;">AQS</a> <a href="/tags/LRU/" style="font-size: 15px;">LRU</a> <a href="/tags/Netty/" style="font-size: 15px;">Netty</a> <a href="/tags/Reactor/" style="font-size: 15px;">Reactor</a> <a href="/tags/高性能/" style="font-size: 15px;">高性能</a> <a href="/tags/TCP/" style="font-size: 15px;">TCP</a> <a href="/tags/编译时注解/" style="font-size: 15px;">编译时注解</a> <a href="/tags/KAPT/" style="font-size: 15px;">KAPT</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="http://gityuan.com/" title="Gityuan" target="_blank">Gityuan</a><ul></ul><a href="https://richardwrq.github.io/" title="Richard Wu" target="_blank">Richard Wu</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Baidu Site Haritası</a> |  <a href="/atom.xml">订阅</a> |  <a href="/about/">关于</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">刘伟.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","weixin","tsina","qzone","linkedin","fbook","twi","print","renren","sqq","evernotecn","bdysc","tqq","tqf","bdxc","kaixin001","tieba","douban","bdhome","thx","ibaidu","meilishuo","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","people","xinhua","mail","isohu","yaolan","wealink","ty","iguba","h163","copy"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"]}};with(document)0[(getElementsByTagName('head')[0]||head).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script><script>(function(d, s) {
  var j, e = d.getElementsByTagName('body')[0];
  if (typeof LivereTower === 'function') { return; }
  j = d.createElement(s);
  j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
  j.async = true;
  e.appendChild(j);
})(document, 'script');
</script></body></html>