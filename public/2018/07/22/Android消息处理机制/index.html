<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="本网站主要供个人学习记录使用，如有侵权请立即邮件联系"><meta name="keywords" content="Android, Java, Linux, 数据结构"><title>Android消息处理机制 | Programmer Liu</title><link rel="stylesheet" type="text/css" href="//fonts.neworld.org/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Android消息处理机制</h1><a id="logo" href="/.">Programmer Liu</a><p class="description">一只有崇高理想的的程序猿</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Arama"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Android消息处理机制</h1><div class="post-meta"><a href="/2018/07/22/Android消息处理机制/#comments" class="comment-count"></a><p><span class="date">Jul 22, 2018</span><span><a href="/categories/Android系统/" class="category">Android系统</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>Android应用程序使用消息来驱动。Android应用程序的每一个线程在启动时，都可以首先在内部创建一个消息队列，然后进入一个无限循环中，不断检查它的消息队列中是否有新的消息需要处理，那么线程就会将它从消息队列中取出，并对它进行处理，否则线程就会进入休眠等待状态。</p>
<p>Android系统主要通过MessageQueue、Looper和Handler三个类来实现Android消息处理机制。MessageQueue用来描述消息队列；Looper用来创建消息队列，以及进入消息循环；Handler用来发送和处理消息。</p>
<p>Android应用程序的消息处理机制不仅在Java代码中使用，还可以在C++代码中使用。</p>
<h2 id="Java层"><a href="#Java层" class="headerlink" title="Java层"></a>Java层</h2><h3 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h3><p><img src="/2018/07/22/Android消息处理机制/message1.png" alt=""></p>
<pre><code>Looper有一个MessageQueue消息队列；
MessageQueue有一组待处理的Message；
Message中有一个用于处理消息的Handler；
Handler中有Looper和MessageQueue。
</code></pre><h3 id="1-1创建消息队列"><a href="#1-1创建消息队列" class="headerlink" title="1.1创建消息队列"></a>1.1创建消息队列</h3><p>Android应用程序消息队列MessageQueue，它可以通过Looper类的静态成员函数prepareMainLooper(主线程)或者prepare(子线程)创建，并且会在C++层中创建一个NativeMessageQueue对象【跳转2.1】。</p>
<h3 id="1-2-loop"><a href="#1-2-loop" class="headerlink" title="1.2 loop"></a>1.2 loop</h3><p>消息队列创建完成后调用Looper.loop(),进入循环模式，不断重复下面的操作，直到没有消息时退出循环：</p>
<pre><code>调用MessageQueue.next取出下一条Message；
把Message分发给相应的target；
再把分发后的Message回收到消息池，以便重复利用。
</code></pre><h4 id="MessageQueue-next"><a href="#MessageQueue-next" class="headerlink" title="MessageQueue.next"></a>MessageQueue.next</h4><p>从MessageQueue中提取下一条message。</p>
<p>当前线程如何得知自己是否有新的消息需要处理？【跳转2.2】    </p>
<h3 id="1-3-消息发送"><a href="#1-3-消息发送" class="headerlink" title="1.3 消息发送"></a>1.3 消息发送</h3><p>消息发送有很多方法，最终调用的都是MessageQueue.enqueueMessage(),将消息添加到消息队列中，when为系统当前的运行时间，不包括休眠时间。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">boolean enqueueMessage(Message msg, long <span class="keyword">when</span>) &#123;</span><br><span class="line">    <span class="comment">// 每一个普通Message必须有一个target</span></span><br><span class="line">    <span class="keyword">if</span> (msg.target == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> new IllegalArgumentException(<span class="string">"Message must have a target."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> new IllegalStateException(msg + <span class="string">" This message is already in use."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    synchronized (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123;  <span class="comment">//正在退出时，回收msg，加入到消息池</span></span><br><span class="line">            msg.recycle();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.<span class="keyword">when</span> = <span class="keyword">when</span>;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        boolean needWake;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span> || <span class="keyword">when</span> == <span class="number">0</span> || <span class="keyword">when</span> &lt; p.<span class="keyword">when</span>) &#123;</span><br><span class="line">            <span class="comment">//p为null(代表MessageQueue没有消息） 或者msg的触发时间是队列中最早的， 则进入该该分支</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked; <span class="comment">//当阻塞时需要唤醒</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//将消息按时间顺序插入到MessageQueue。一般地，不需要唤醒事件队列，除非</span></span><br><span class="line">            <span class="comment">//消息队头存在barrier，并且同时Message是队列中最早的异步消息。</span></span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="literal">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="literal">null</span> || <span class="keyword">when</span> &lt; p.<span class="keyword">when</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = p;</span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//消息没有退出，我们认为此时mPtr != 0</span></span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MessageQueue是按照Message触发时间的先后顺序排列的，队头的消息是将要最早触发的消息。当有消息需要加入消息队列时，会从队列头开始遍历，直到找到消息应该插入的合适位置，以保证所有消息的时间顺序。</p>
<ol>
<li>当插入的消息在目标消息队列的中间，由于目标消息队列头部没有发生变化，当前线程不需要对目标线程执行唤醒操作</li>
<li>当插入的消息在目标消息队列的头部，当前线程就需要将目标线程唤醒，使目标线程可以处理消息队列头部的消息。如果目标线程休眠，就要调用nativeWake()方法将其唤醒。【跳转2.3】</li>
</ol>
<h3 id="1-4-消息分发"><a href="#1-4-消息分发" class="headerlink" title="1.4 消息分发"></a>1.4 消息分发</h3><p>在Looper.loop()中，当发现有消息时，Message中有一个用于处理消息的Handler,调用消息的目标handler，执行dispatchMessage()方法来分发消息。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//当Message存在回调方法，回调msg.callback.run()方法；</span></span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//当Handler存在Callback成员变量时，回调方法handleMessage()；</span></span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Handler自身的回调方法handleMessage()</span></span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>当Message的回调方法不为空时，则回调方法msg.callback.run()，其中callBack数据类型为Runnable,否则进入步骤2；</li>
<li>当Handler的mCallback成员变量不为空时，则回调方法mCallback.handleMessage(msg),否则进入步骤3；</li>
<li>调用Handler自身的回调方法handleMessage()，该方法默认为空，Handler子类通过覆写该方法来完成具体的逻辑。</li>
</ol>
<p>平时开发中最常使用的是第三种情况，通过覆写handleMessage方法来实现自己的业务逻辑。</p>
<h2 id="Native层"><a href="#Native层" class="headerlink" title="Native层"></a>Native层</h2><h3 id="Native架构图"><a href="#Native架构图" class="headerlink" title="Native架构图"></a>Native架构图</h3><p><img src="/2018/07/22/Android消息处理机制/message2.png" alt=""></p>
<h3 id="2-1-创建消息队列"><a href="#2-1-创建消息队列" class="headerlink" title="2.1 创建消息队列"></a>2.1 创建消息队列</h3><p>Java层MessageQueue创建过程中调用NativeInit方法，它是由C++层中的<code>android_os_MessageQueue_nativeInit</code>方法实现。然后由它在C++层<code>new MessageQueue()</code>、<code>new Looper()</code>。</p>
<p>在C++层Looper中创建了一个管道pipe，这个管道在一个线程的消息循环过程中起到了非常大的作用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Looper::rebuildEpollLocked() &#123;</span><br><span class="line">    <span class="keyword">if</span> (mEpollFd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        close(mEpollFd); <span class="comment">//关闭旧的epoll实例</span></span><br><span class="line">    &#125;</span><br><span class="line">    mEpollFd = epoll_create(EPOLL_SIZE_HINT); <span class="comment">//创建新的epoll实例，并注册wake管道</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">eventItem</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp; eventItem, <span class="number">0</span>, <span class="keyword">sizeof</span>(epoll_event)); <span class="comment">//把未使用的数据区域进行置0操作</span></span><br><span class="line">    eventItem.events = EPOLLIN; <span class="comment">//可读事件</span></span><br><span class="line">    eventItem.data.fd = mWakeEventFd;</span><br><span class="line">    <span class="comment">//将唤醒事件(mWakeEventFd)添加到epoll实例(mEpollFd)</span></span><br><span class="line">    <span class="keyword">int</span> result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeEventFd, &amp; eventItem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mRequests.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> Request&amp; request = mRequests.valueAt(i);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">eventItem</span>;</span></span><br><span class="line">        request.initEventItem(&amp;eventItem);</span><br><span class="line">        <span class="comment">//将request队列的事件，分别添加到epoll实例</span></span><br><span class="line">        <span class="keyword">int</span> epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, request.fd, &amp; eventItem);</span><br><span class="line">        <span class="keyword">if</span> (epollResult &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">"Error adding epoll events for fd %d while rebuilding epoll set, errno=%d"</span>, request.fd, errno);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<a href="https://david1840.github.io/2018/07/21/I-O%E5%A4%9A%E8%B7%AF%E8%BD%AC%E6%8D%A2select%E3%80%81poll/" target="_blank" rel="noopener">Linux epoll机制</a>，当一个线程没有新的消息时，它就会休眠在这个管道的读端文件描述符上，直到有新的消息需要处理；其次，当其他线程向这个线程的消息队列发送一个消息后，其他线程就会通过这个管道的写端文件描述符往这个管道写入一个数据，从而唤醒这个线程，以便它可以对刚才发送给它的消息队列中的数据进行处理。</p>
<p><img src="/2018/07/22/Android消息处理机制/message7.png" alt=""></p>
<h3 id="2-2-取出消息"><a href="#2-2-取出消息" class="headerlink" title="2.2 取出消息"></a>2.2 取出消息</h3><p>MessageQueue.next中调用nativePollOnce方法，最终调用到C++层的Lopper.pollInner，使用epoll_wait方法监听2.1中创建的epoll实例的IO读写事件。</p>
<p><img src="/2018/07/22/Android消息处理机制/message6.png" alt=""></p>
<h3 id="2-3-发送消息"><a href="#2-3-发送消息" class="headerlink" title="2.3 发送消息"></a>2.3 发送消息</h3><p>向目标线程发送数据，如果线程处于休眠状态，就要先将其唤醒。在2.1中知道线程使用epoll机制监听是否需要处理消息。所以当前线程要唤醒目标线程就只要向它的写端文件描述符写入一个字符，就可以将其唤醒。</p>
<p><img src="/2018/07/22/Android消息处理机制/message5.png" alt=""></p>
<h2 id="Java层-和-Native层"><a href="#Java层-和-Native层" class="headerlink" title="Java层 和 Native层"></a>Java层 和 Native层</h2><p><img src="/2018/07/22/Android消息处理机制/message3.png" alt=""></p>
<ul>
<li>红色虚线关系：Java层和Native层的MessageQueue通过JNI建立关联，彼此之间能相互调用，搞明白这个互调关系，也就搞明白了Java如何调用C++代码，C++代码又是如何调用Java代码。</li>
<li>蓝色虚线关系：Handler/Looper/Message这三大类Java层与Native层并没有任何的真正关联，只是分别在Java层和Native层的handler消息模型中具有相似的功能。都是彼此独立的，各自实现相应的逻辑。</li>
<li>WeakMessageHandler继承于MessageHandler类，NativeMessageQueue继承于MessageQueue类</li>
</ul>
<p>另外，消息处理流程是先处理Native Message，再处理Native Request，最后处理Java Message。理解了该流程，也就明白有时上层消息很少，但响应时间却较长的真正原因。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/2018/07/22/Android消息处理机制/message4.png" alt=""></p>
<ul>
<li>Handler通过sendMessage()发送Message到MessageQueue队列；</li>
<li>Looper通过loop()，不断提取出达到触发条件的Message，并将Message交给target来处理；</li>
<li>经过dispatchMessage()后，交回给Handler的handleMessage()来进行相应地处理。</li>
<li>将Message加入MessageQueue时，处往管道写入字符，可以会唤醒loop线程；如果MessageQueue中没有Message，并处于Idle状态，则会执行IdelHandler接口中的方法，往往用于做一些清理性地工作。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://gityuan.com/2015/12/27/handler-message-native/" target="_blank" rel="noopener">Gityuan博客</a>、《Android系统源代码情景分析》</p>
</div><div class="tags"><a href="/tags/Android/">Android</a><a href="/tags/系统/">系统</a></div><div class="post-share"><div class="bdsharebuttonbox"><span style="float:left;line-height: 28px;height: 28px;font-size:16px;font-weight:blod">分享到：</span><a href="#" data-cmd="more" class="bds_more"></a><a href="#" data-cmd="mshare" title="分享到一键分享" class="bds_mshare"></a><a href="#" data-cmd="fbook" title="分享到Facebook" class="bds_fbook"></a><a href="#" data-cmd="twi" title="分享到Twitter" class="bds_twi"></a><a href="#" data-cmd="linkedin" title="分享到linkedin" class="bds_linkedin"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a></div></div><div class="post-nav"><a href="/2018/07/23/Linux进程管理/" class="pre">Linux进程管理</a><a href="/2018/07/21/Linux文件描述符/" class="next">Linux文件描述符</a></div><div id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC8zODA5Ny8xNDYyNw=="></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java层"><span class="toc-text">Java层</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#架构图"><span class="toc-text">架构图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1创建消息队列"><span class="toc-text">1.1创建消息队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-loop"><span class="toc-text">1.2 loop</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MessageQueue-next"><span class="toc-text">MessageQueue.next</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-消息发送"><span class="toc-text">1.3 消息发送</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-消息分发"><span class="toc-text">1.4 消息分发</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Native层"><span class="toc-text">Native层</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Native架构图"><span class="toc-text">Native架构图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-创建消息队列"><span class="toc-text">2.1 创建消息队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-取出消息"><span class="toc-text">2.2 取出消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-发送消息"><span class="toc-text">2.3 发送消息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java层-和-Native层"><span class="toc-text">Java层 和 Native层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-text">参考</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/11/23/FFmpeg常用结构体、方法简介/">FFmpeg常用结构体、方法简介</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/23/FFmpeg实现简单直播系统/">FFmpeg实现简单直播系统</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/22/FFmpeg常用命令/">FFmpeg常用命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/21/Mac下FFmpeg的下载-编译和安装/">FFmpeg的下载,编译和安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/19/音视频基础概念/">音视频基础概念</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/28/Netty学习-一/">Netty学习(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/24/Java内存分配及GC回收/">Java内存分配及GC回收</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/22/Android中的ClassLoader简析/">Android中的ClassLoader简析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/22/Java中的ClassLoader简析/">Java中的ClassLoader简析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/20/LinkedHashMap和LRU/">LinkedHashMap和LRU</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android系统/">Android系统</a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/C-C/">C/C++</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kotlin/">Kotlin</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux系统/">Linux系统</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Netty/">Netty</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web/">Web</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络/">网络</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/音视频/">音视频</a><span class="category-list-count">5</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/FFmpeg/" style="font-size: 15px;">FFmpeg</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/JNI/" style="font-size: 15px;">JNI</a> <a href="/tags/NDK/" style="font-size: 15px;">NDK</a> <a href="/tags/ClassLoader/" style="font-size: 15px;">ClassLoader</a> <a href="/tags/BroadCast/" style="font-size: 15px;">BroadCast</a> <a href="/tags/原理/" style="font-size: 15px;">原理</a> <a href="/tags/binder/" style="font-size: 15px;">binder</a> <a href="/tags/C-C/" style="font-size: 15px;">C/C++</a> <a href="/tags/指针/" style="font-size: 15px;">指针</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/多线程/" style="font-size: 15px;">多线程</a> <a href="/tags/源码/" style="font-size: 15px;">源码</a> <a href="/tags/音视频/" style="font-size: 15px;">音视频</a> <a href="/tags/系统/" style="font-size: 15px;">系统</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/系统调用/" style="font-size: 15px;">系统调用</a> <a href="/tags/内存/" style="font-size: 15px;">内存</a> <a href="/tags/GC/" style="font-size: 15px;">GC</a> <a href="/tags/同步/" style="font-size: 15px;">同步</a> <a href="/tags/JMM/" style="font-size: 15px;">JMM</a> <a href="/tags/AQS/" style="font-size: 15px;">AQS</a> <a href="/tags/LRU/" style="font-size: 15px;">LRU</a> <a href="/tags/Netty/" style="font-size: 15px;">Netty</a> <a href="/tags/Reactor/" style="font-size: 15px;">Reactor</a> <a href="/tags/高性能/" style="font-size: 15px;">高性能</a> <a href="/tags/TCP/" style="font-size: 15px;">TCP</a> <a href="/tags/编译时注解/" style="font-size: 15px;">编译时注解</a> <a href="/tags/KAPT/" style="font-size: 15px;">KAPT</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="http://gityuan.com/" title="Gityuan" target="_blank">Gityuan</a><ul></ul><a href="https://richardwrq.github.io/" title="Richard Wu" target="_blank">Richard Wu</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Baidu Site Haritası</a> |  <a href="/atom.xml">订阅</a> |  <a href="/about/">关于</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">刘伟.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","weixin","tsina","qzone","linkedin","fbook","twi","print","renren","sqq","evernotecn","bdysc","tqq","tqf","bdxc","kaixin001","tieba","douban","bdhome","thx","ibaidu","meilishuo","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","people","xinhua","mail","isohu","yaolan","wealink","ty","iguba","h163","copy"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"]}};with(document)0[(getElementsByTagName('head')[0]||head).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script><script>(function(d, s) {
  var j, e = d.getElementsByTagName('body')[0];
  if (typeof LivereTower === 'function') { return; }
  j = d.createElement(s);
  j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
  j.async = true;
  e.appendChild(j);
})(document, 'script');
</script></body></html>